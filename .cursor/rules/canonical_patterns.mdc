---
description:
globs: *.py
alwaysApply: false
---
# Cursor Rule: Canonical Patterns Reference

> **Status:** Canonical
> **Last Updated:** 2025-01-27
> **Purpose:** Definitive reference for all ONEX canonical patterns with file path examples

## Rule

All code in this repository must follow the canonical patterns established in the reference implementations. When implementing any subsystem, use these exact patterns and file structures. Deviations require explicit justification and maintainer approval.

## üèóÔ∏è Node Architecture

### Canonical Node Structure
**Primary Reference:** `src/omnibase/nodes/node_cli/`
**Secondary Reference:** `src/omnibase/nodes/node_kafka_event_bus/` (for complex backend patterns only)

```
node_name/
‚îú‚îÄ‚îÄ README.md                    # Node-level documentation (required at node root)
‚îú‚îÄ‚îÄ ARCHITECTURE_DECISIONS.md   # Architectural decisions with rationale
‚îú‚îÄ‚îÄ CLI_ARCHITECTURE_STATUS.md  # Implementation status (if applicable)
‚îú‚îÄ‚îÄ protocols/                  # Protocol interfaces (never versioned)
‚îÇ   ‚îú‚îÄ‚îÄ protocol_*.py          # Protocol definitions
‚îî‚îÄ‚îÄ v1_0_0/                    # Versioned implementation
    ‚îú‚îÄ‚îÄ SCHEMA_DECISIONS.md    # Schema-specific design decisions
    ‚îú‚îÄ‚îÄ contract.yaml          # Source of truth for models/errors
    ‚îú‚îÄ‚îÄ node_config.yaml       # Operational configuration (linked document)
    ‚îú‚îÄ‚îÄ deployment_config.yaml # Deployment configuration (linked document)
    ‚îú‚îÄ‚îÄ models/                # Pydantic models (auto-generated)
    ‚îÇ   ‚îú‚îÄ‚îÄ state.py          # Auto-generated from contract.yaml
    ‚îÇ   ‚îú‚îÄ‚îÄ error_codes.py    # Auto-generated error codes
    ‚îú‚îÄ‚îÄ tools/                 # Business logic tools
    ‚îÇ   ‚îú‚îÄ‚îÄ tool_*.py
    ‚îú‚îÄ‚îÄ registry/              # Registry implementation
    ‚îÇ   ‚îú‚îÄ‚îÄ registry_*.py
    ‚îú‚îÄ‚îÄ node_tests/            # All tests
    ‚îÇ   ‚îú‚îÄ‚îÄ conftest.py
    ‚îÇ   ‚îú‚îÄ‚îÄ test_scenarios.py
    ‚îú‚îÄ‚îÄ scenarios/             # Scenario YAMLs
    ‚îÇ   ‚îú‚îÄ‚îÄ index.yaml
    ‚îÇ   ‚îú‚îÄ‚îÄ scenario_*.yaml
    ‚îú‚îÄ‚îÄ snapshots/             # Snapshot YAMLs
    ‚îÇ   ‚îú‚îÄ‚îÄ snapshot_*.yaml
    ‚îú‚îÄ‚îÄ introspection.py       # Standards-compliant introspection
    ‚îú‚îÄ‚îÄ node.py               # Main reducer pattern implementation
    ‚îî‚îÄ‚îÄ node.onex.yaml        # Node metadata
```

### Canonical Contract Patterns
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/contract.yaml`

All contracts **must** include:

#### **1. Linked Document Architecture**
```yaml
# Links to associated configuration documents
associated_documents:
  node_config:
    $ref: "node_config.yaml"
  deployment_config:
    $ref: "deployment_config.yaml"
  # Optional documents for future capabilities
  optional_feature_config:
    $ref: "optional_config.yaml"
    optional: true
    required_capability: "feature_name"
```

#### **2. Canonical Base State Pattern**
```yaml
# Input state: Only node-specific fields (inherits from OnexInputState)
input_state:
  type: object
  properties:
    action:
      type: string
      enum: ["action1", "action2", "action3"]
    # Only node-specific fields here
  required: ["action"]

# Output state: Only node-specific fields (inherits from OnexOutputState)
output_state:
  type: object
  properties:
    # Only node-specific fields (common fields inherited)
    exit_code:
      type: integer
      default: 0
  required: []
```

#### **3. Shared Schema References**
```yaml
# Definitions: Reference shared schemas with project root paths
definitions:
  OnexFieldModel:
    $ref: 'schemas/onex_field_model.schema.yaml#/'
  SemVerModel:
    $ref: 'schemas/semver_model.schema.yaml#/'
  # Node-specific schemas
  NodeSpecificConfig:
    $ref: 'schemas/domain/node_specific.schema.yaml#/'
```

#### **4. Subcontract Architecture **
```yaml
# Main contract.yaml - Interface definition only
input_state:
  type: object
  properties:
    action:
      $ref: "contracts/contract_actions.yaml#/NodeActionModel"
    validation_config:
      $ref: "contracts/contract_validation.yaml#/ValidationConfig"

definitions:
  # External references only - no inline model definitions
  OnexFieldModel:
    $ref: 'omnibase/schemas/core/onex_field_model.schema.yaml#/'
  SemVerModel:
    $ref: 'omnibase/schemas/core/semver_model.schema.yaml#/'
```

**Subcontract Structure:**
```
v1_0_0/
‚îú‚îÄ‚îÄ contract.yaml                    # Main interface contract
‚îú‚îÄ‚îÄ contracts/                      # Subcontract definitions
‚îÇ   ‚îú‚îÄ‚îÄ contract_actions.yaml      # Action models and enums
‚îÇ   ‚îú‚îÄ‚îÄ contract_models.yaml       # Domain data structures
‚îÇ   ‚îú‚îÄ‚îÄ contract_validation.yaml   # Validation rules
‚îÇ   ‚îú‚îÄ‚îÄ contract_cli.yaml         # CLI interface (optional)
‚îÇ   ‚îî‚îÄ‚îÄ contract_capabilities.yaml # Execution capabilities (optional)
‚îî‚îÄ‚îÄ models/                        # Auto-generated backing models
    ‚îú‚îÄ‚îÄ state.py                   # Main state models
    ‚îú‚îÄ‚îÄ model_contract_actions.py
    ‚îú‚îÄ‚îÄ model_contract_models.py
    ‚îú‚îÄ‚îÄ model_contract_validation.py
    ‚îú‚îÄ‚îÄ model_contract_cli.py (optional)
    ‚îî‚îÄ‚îÄ model_contract_capabilities.py (optional)
```

#### **5. CLI Interface Pattern**
```yaml
# CLI Interface (if applicable)
cli_interface:
  entrypoint: "poetry run onex exec node_name"
  commands:
    - name: "info"
      description: "Get node information"
    - name: "system"
      description: "Get system information"

# Execution Capabilities
execution_capabilities:
  supported_node_types: ["full"]
  supported_delivery_modes: ["direct", "inmemory", "kafka"]
  performance_constraints:
    max_concurrent_executions: 10
    timeout_ms: 30000
```

### Node Implementation Pattern
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/node.py`

```python
class NodeCli:
    """Canonical reducer pattern with dependency injection."""

    def __init__(self, logger_tool: ProtocolLogger, registry: RegistryClass, **kwargs):
        # Protocol-pure dependency injection
        if logger_tool is None:
            raise OnexError("Logger tool required", CoreErrorCode.MISSING_REQUIRED_PARAMETER)
        if registry is None:
            raise OnexError("Registry required", CoreErrorCode.MISSING_REQUIRED_PARAMETER)

        self.logger_tool = logger_tool
        self.registry = registry

    def run(self, input_state: NodeCliInputState) -> NodeCliOutputState:
        """Canonical reducer pattern with model-only input."""
        # Business logic here
        return NodeCliOutputState(...)

    def bind(self, **kwargs) -> 'NodeCli':
        """Canonical binding pattern."""
        return NodeCli(**{**self.__dict__, **kwargs})
```

### Protocol-Only Tool Signatures Pattern
**Reference:** `src/omnibase/nodes/node_cli/protocols/protocol_node_discovery.py`

```python
class ProtocolNodeDiscovery(Protocol):
    """Canonical protocol with model-only signatures."""

    def discover_nodes(self, input_state: NodeCliInputState) -> NodeCliOutputState:
        """All protocol methods accept only validated Pydantic models."""
        ...

    def get_node_info(self, input_state: NodeCliInputState) -> NodeCliOutputState:
        """No dict, primitive, or argument model parameters allowed."""
        ...
```

### Tool Implementation Pattern
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/tools/tool_node_discovery.py`

```python
class ToolNodeDiscovery(ProtocolNodeDiscovery):
    """Canonical tool with model-only input pattern."""

    def __init__(self, logger: ProtocolLogger):
        self.logger = logger

    def discover_nodes(self, input_state: NodeCliInputState) -> NodeCliOutputState:
        """Extract needed fields from canonical input state model."""
        # Extract fields from input_state as needed
        action = input_state.action
        node_name = getattr(input_state, 'node_name', None)

        # Business logic here
        return NodeCliOutputState(...)
```

## üîß Registry Architecture

### Canonical Registry Pattern
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/registry/registry_cli.py`

```python
class RegistryCli(BaseOnexRegistry):
    """Canonical registry with CANONICAL_TOOLS fallback."""

    CANONICAL_TOOLS = {
        "tool_node_discovery": ToolNodeDiscovery,
        "tool_system_information": ToolSystemInformation,
    }

    def __init__(self, node_dir: Path, tool_collection: Optional[dict] = None, **kwargs):
        super().__init__(**kwargs)

        # CANONICAL PATTERN: Empty tool_collection falls back to canonical tools
        if tool_collection is not None and len(tool_collection) > 0:
            for name, tool_cls in tool_collection.items():
                self.register_tool(name, tool_cls)
        else:
            # Use canonical tools when tool_collection is None or empty
            for name, tool_cls in self.CANONICAL_TOOLS.items():
                self.register_tool(name, tool_cls)
```

## üß™ Testing Architecture

### Scenario-Driven Testing Pattern
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/node_tests/test_scenarios.py`

```python
@pytest.mark.parametrize("scenario_path", get_scenario_paths())
@pytest.mark.asyncio
async def test_scenario_yaml(scenario_path, scenario_test_harness, **kwargs):
    """Canonical scenario test pattern."""

    # CANONICAL PATTERN: Let harness use registry resolver
    registry = None  # Forces harness to use registry resolver with scenario tools

    # Dynamic fixture detection
    import inspect
    node_sig = inspect.signature(node_class)
    logger_tool = None
    if 'logger_tool' in node_sig.parameters:
        logger_tool = request.getfixturevalue('logger_tool')

    output, expected = await scenario_test_harness.run_scenario_test(
        node_class=node_class,
        scenario_path=scenario_path,
        registry=registry,  # None - forces registry resolver usage
        logger_tool=logger_tool,
        **kwargs
    )
```

## üîÑ Scenario Harness Pattern

### Registry Resolution Pattern
**Reference:** `src/omnibase/testing/testing_scenario_harness.py`

```python
# CANONICAL PATTERN: Registry preservation logic
if registry is None:
    # Only use registry resolver if no registry provided
    registry = self.registry_resolver.resolve_registry(
        registry_class=registry_class,
        scenario_path=scenario_path,
        logger=logger,
        target_node_class=node_class
    )
# If registry provided, use it as-is (preserves working registries)
```

### Fixture Injection Pattern
**Reference:** `src/omnibase/testing/testing_scenario_harness.py`

```python
# Dynamic fixture detection based on constructor signatures
import inspect
node_sig = inspect.signature(node_class)

# Only inject parameters that are actually required
if 'logger_tool' in node_sig.parameters and logger_tool:
    node_kwargs['logger_tool'] = logger_tool
if 'registry' in node_sig.parameters and registry:
    node_kwargs['registry'] = registry
```

### Scenario Harness Registry Fallback Pattern
**Reference:** `src/omnibase/testing/testing_scenario_harness.py`

```python
# CANONICAL PATTERN: Registry resolver with canonical tools fallback
if registry is None:
    try:
        # Try registry resolver first (merges scenario tools with canonical tools)
        registry = self.registry_resolver.resolve_registry(
            registry_class=registry_class,
            scenario_path=Path(scenario_path),
            target_node_class=node_class,
            logger=logger_tool
        )
    except Exception as e:
        # CANONICAL FALLBACK: Create registry with canonical tools when resolver fails
        if registry_class:
            try:
                # Create registry with canonical tools (tool_collection=None)
                registry_kwargs = {"tool_collection": None, "logger": logger_tool}

                # Add node_dir if registry supports it
                registry_sig = inspect.signature(registry_class)
                if "node_dir" in registry_sig.parameters:
                    node_dir = Path(scenario_path).parent.parent
                    registry_kwargs["node_dir"] = node_dir

                registry = registry_class(**registry_kwargs)
            except Exception:
                registry = None
```

### Scenario Harness Anti-Pattern
**‚ùå DON'T:** Set registry to None when resolver fails
```python
# WRONG: This breaks nodes that require a registry
except Exception as e:
    registry = None  # Node constructor will fail if it requires registry
```

**‚úÖ DO:** Fall back to canonical tools when resolver fails
```python
# CORRECT: Create registry with canonical tools as fallback
except Exception as e:
    if registry_class:
        registry = registry_class(tool_collection=None, logger=logger_tool)
    else:
        registry = None
```

## üìä Model Architecture

### Canonical Input/Output State Pattern
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/models/state.py`

```python
class NodeCliInputState(OnexInputState):
    """Canonical input state inheriting from OnexInputState."""
    action: str = Field(..., description="Action to perform")
    node_name: Optional[str] = Field(None, description="Target node name")
    node_version: Optional[str] = Field(None, description="Target node version")
    args: Optional[str] = Field(None, description="JSON-encoded arguments")

class NodeCliOutputState(OnexOutputState):
    """Canonical output state inheriting from OnexOutputState."""
    exit_code: int = Field(default=0, description="Exit code")
    # Common fields like status, message inherited from OnexOutputState
```

### Contract-Driven Generation
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/contract.yaml`

All models and error codes must be auto-generated from `contract.yaml` - never hand-written.

## üõ†Ô∏è Tool Architecture

### Tool Implementation Pattern
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/tools/`

```python
class ToolNodeDiscovery(ProtocolNodeDiscovery):
    """Canonical tool with model-only input pattern."""

    def __init__(self, logger: ProtocolLogger):
        self.logger = logger

    def discover_nodes(self, input_state: NodeCliInputState) -> NodeCliOutputState:
        """Extract needed fields from canonical input state model."""
        # Extract fields from input_state as needed
        action = input_state.action
        node_name = getattr(input_state, 'node_name', None)

        # Business logic here
        return NodeCliOutputState(...)
```

### Protocol Interface Pattern
**Reference:** `src/omnibase/nodes/node_cli/protocols/`

```python
class ProtocolNodeDiscovery(Protocol):
    """Canonical protocol with model-only signatures."""

    def discover_nodes(self, input_state: NodeCliInputState) -> NodeCliOutputState:
        """All protocol methods accept only validated Pydantic models."""
        ...

    def get_node_info(self, input_state: NodeCliInputState) -> NodeCliOutputState:
        """No dict, primitive, or argument model parameters allowed."""
        ...
```

## üîç CLI Architecture

### CLI Command Pattern
**Reference:** `src/omnibase/cli_tools/onex/v1_0_0/commands/`

```python
@click.command()
@click.argument('node_name')
@click.option('--version', help='Node version')
def command_name(node_name: str, version: Optional[str]):
    """Canonical CLI command pattern."""
    try:
        # Business logic here
        click.echo(f"Success: {result}")
    except OnexError as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)
```

### Event-Driven CLI Pattern
**Reference:** `src/omnibase/nodes/node_cli/v1_0_0/tools/tool_cli_event_publisher.py`

```python
class ToolCliEventPublisher:
    """Canonical CLI event publisher with model validation."""

    def publish_cli_event(self, input_state: NodeCliInputState) -> NodeCliOutputState:
        """Always validate input before dispatch to node_cli."""
        # Validate input state
        if not isinstance(input_state, NodeCliInputState):
            raise OnexError("Invalid input state", CoreErrorCode.INVALID_PARAMETER)

        # Dispatch to node_cli
        result = self.node_cli.run(input_state)
        return result
```

## üèÉ‚Äç‚ôÇÔ∏è Runtime Architecture

### Registry Resolver Pattern
**Reference:** `src/omnibase/runtimes/onex_runtime/v1_0_0/tools/tool_registry_resolver.py`

```python
def resolve_registry(self, registry_class: Type[ProtocolRegistry],
                    scenario_path: Optional[Path] = None, **kwargs) -> ProtocolRegistry:
    """Canonical registry resolution with validation."""

    # Parse scenario configuration
    context = self._parse_scenario_config(scenario_path, **kwargs)

    # Apply dependency mode tools
    final_tools_dict = self._apply_dependency_mode_tools(context, logger)

    # CANONICAL PATTERN: Merge scenario tools with canonical tools BEFORE creating registry
    merged_tools = {}

    # Start with canonical tools if registry class has them
    if hasattr(registry_class, 'CANONICAL_TOOLS'):
        merged_tools.update(registry_class.CANONICAL_TOOLS)

    # Override with scenario-specific tools (scenario tools take precedence)
    merged_tools.update(final_tools_dict)

    # Create registry with merged tools
    kwargs = {
        "tool_collection": merged_tools,  # Both canonical and scenario tools
        "logger": logger,
        "node_dir": context.node_dir,
        "dependency_mode": context.get_effective_dependency_mode()
    }

    registry = registry_class(**kwargs)
    return registry
```

**Key Principles:**
- Merge tools BEFORE registry creation (not after)
- Scenario tools override canonical tools when conflicts exist
- Clean tool collection management without complex error handling
- Single registry creation (not canonical first + scenario second)

## üìù Documentation Patterns

### README Structure
**Reference:** `src/omnibase/nodes/node_cli/README.md`

```markdown
# Node Name

## Overview
Brief description of node purpose and capabilities.

## Usage
```bash
poetry run onex run node_name --args='["param1", "param2"]'
```

## Configuration
Description of configuration options and models.

## Scenarios
List of available scenarios and their purposes.

## Development
Development setup and testing instructions.
```

### Docstring Pattern
**Reference:** Throughout codebase

```python
def method_name(self, param: ModelType) -> ModelReturnType:
    """
    Brief description of method purpose.

    Args:
        param: Description of parameter with type

    Returns:
        ModelReturnType: Description of return value

    Raises:
        OnexError: When specific error conditions occur

    Example:
        >>> result = instance.method_name(param_value)
        >>> assert result.status == "success"
    """
```

## üö´ Anti-Patterns (DO NOT USE)

### ‚ùå Non-Model Protocol Signatures
```python
# DON'T: Accept argument models or primitives
def discover_nodes(self, node_name: str, args: NodeInfoArgs) -> dict:

# DO: Accept only canonical input state model
def discover_nodes(self, input_state: NodeCliInputState) -> NodeCliOutputState:
```

### ‚ùå Manual Model Creation
```python
# DON'T: Hand-write models that should be generated
class ManualInputState(BaseModel):  # Generate from contract.yaml

# DO: Auto-generate from contract.yaml
# Models are generated automatically - never hand-written
```

### ‚ùå Legacy Contract Patterns

**DON'T:** Use old contract patterns without base state inheritance
```yaml
input_state:
  properties:
    # Direct field definitions without inheritance
```

**DO:** Use canonical base state inheritance
```yaml
input_state:
  type: object
  properties:
    action:
      type: string
      enum: ["info", "system", "discovery"]
  required: ["action"]
  # Inherits from OnexInputState automatically
```

## üîß Migration Checklist

When updating existing code to follow canonical patterns:

1. **Node Structure**: ‚úÖ Follow canonical directory structure
2. **Registry Pattern**: ‚úÖ Inherit from BaseOnexRegistry with CANONICAL_TOOLS
3. **Testing Pattern**: ‚úÖ Use scenario-driven tests with registry resolver
4. **Model Generation**: ‚úÖ Auto-generate from contract.yaml
5. **Protocol Interfaces**: ‚úÖ Use Protocol for all tool interfaces
6. **Dependency Injection**: ‚úÖ Constructor-based DI with protocol types
7. **Error Handling**: ‚úÖ Use OnexError with specific error codes
8. **Documentation**: ‚úÖ Follow canonical README and docstring patterns

## üìö Quick Reference

| Subsystem | Canonical Example | Key Pattern |
|-----------|------------------|-------------|
| **Node Implementation** | `node_cli/v1_0_0/node.py` | Reducer pattern with model-only input |
| **Contract Design** | `node_cli/v1_0_0/contract.yaml` | Linked documents + base state inheritance |
| **Protocol Interfaces** | `node_cli/protocols/` | Model-only signatures |
| **Tool Implementation** | `node_cli/v1_0_0/tools/` | Extract from canonical input state |
| **Registry** | `node_cli/v1_0_0/registry/` | BaseOnexRegistry + CANONICAL_TOOLS |
| **Testing** | `node_cli/v1_0_0/node_tests/` | Scenario-driven with registry resolver |
| **Models** | `node_cli/v1_0_0/models/` | Auto-generated from contract.yaml |
| **CLI Commands** | `cli_tools/onex/v1_0_0/commands/` | Click-based with error handling |
| **Scenarios** | `node_cli/v1_0_0/scenarios/` | YAML-driven test scenarios |

## üéØ Enforcement

- **Code Review**: All PRs must follow these canonical patterns
- **Automated Checks**: Linting and CI enforce pattern compliance
- **Documentation**: Any deviation requires explicit justification
- **Migration**: Existing code must be updated to follow these patterns

## üìñ Related Rules

- [Node Standards](mdc:node_standards.mdc) - Specific node requirements
- [Testing Standards](mdc:testing.mdc) - Testing methodology
- [Naming Conventions](mdc:naming_conventions.mdc) - File and class naming
- [Interface Design](mdc:interface_design_protocol_vs_abc.mdc) - Protocol vs ABC usage

---

**Remember**: When in doubt, copy the pattern from the canonical examples. These patterns are battle-tested and ensure consistency across the entire ONEX ecosystem.
