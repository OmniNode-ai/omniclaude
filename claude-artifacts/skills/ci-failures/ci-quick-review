#!/bin/bash
set -euo pipefail

# ============================================================================
# CI Quick Review - One-Command CI Failure Summary
# ============================================================================
# Simplified wrapper for quick CI failure reviews.
# Fetches CI data and displays a concise, colorized summary.
#
# Usage:
#   ci-quick-review 33                    # Review CI failures for PR #33
#   ci-quick-review my-branch             # Review CI failures for branch
#   ci-quick-review                       # Review CI failures for current branch
#   ci-quick-review --workflow ci-cd 33   # Filter to specific workflow
#   ci-quick-review --json 33             # JSON output only
# ============================================================================

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] [PR_NUMBER|BRANCH]

Quick CI failure review with concise summary and colorized output.

OPTIONS:
    --workflow WORKFLOW_NAME    Filter to specific workflow
    --json                      Output JSON only (no formatted display)
    --no-cache                  Bypass cache and fetch fresh data
    --help, -h                  Show this help

ARGUMENTS:
    PR_NUMBER                   Pull request number (e.g., 33)
    BRANCH                      Branch name (e.g., 'my-feature-branch')
    (none)                      Use current branch

EXAMPLES:
    # Quick review of current branch
    $(basename "$0")

    # Review specific PR
    $(basename "$0") 33

    # Review specific branch
    $(basename "$0") my-feature-branch

    # Filter to specific workflow
    $(basename "$0") --workflow ci-cd 33

    # JSON output for scripting
    $(basename "$0") --json 33 | jq '.summary'

EXIT CODES:
    0 - Success (CI data fetched)
    1 - Error (dependency missing, API failure, etc.)
    2 - No CI failures found (success!)
EOF
    exit 0
}

# Parse arguments for JSON mode
JSON_MODE=false
FETCH_ARGS=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --json)
            JSON_MODE=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            FETCH_ARGS+=("$1")
            shift
            ;;
    esac
done

# Fetch CI data - run once and capture both stdout and stderr
CI_DATA=""
FETCH_EXIT_CODE=0
FETCH_STDERR=""

# Create temp file for stderr capture
STDERR_FILE=$(mktemp)
trap "rm -f '$STDERR_FILE'" EXIT

# Single execution: capture stdout in CI_DATA, stderr in temp file
if ! CI_DATA=$("$SCRIPT_DIR/fetch-ci-data" "${FETCH_ARGS[@]}" 2>"$STDERR_FILE"); then
    FETCH_EXIT_CODE=$?
    FETCH_STDERR=$(cat "$STDERR_FILE")
fi

# If fetch failed with no data, show error from captured stderr
if [ $FETCH_EXIT_CODE -ne 0 ] && [ -z "$CI_DATA" ]; then
    echo -e "${RED}âœ— Failed to fetch CI data${NC}" >&2
    if [ -n "$FETCH_STDERR" ]; then
        echo "$FETCH_STDERR" | grep -E 'âœ—|Error|error' >&2 || echo "$FETCH_STDERR" >&2
    fi
    exit 1
fi

# If JSON mode, just output raw JSON
if [ "$JSON_MODE" = true ]; then
    echo "$CI_DATA"
    exit $FETCH_EXIT_CODE
fi

# Extract JSON - remove any non-JSON lines (ANSI codes, status messages)
# First try to extract just the JSON object
CI_JSON=$(echo "$CI_DATA" | sed -n '/^{/,/^}/p' | head -1)
# If that didn't work, try removing ANSI codes and filtering
if [ -z "$CI_JSON" ] || ! echo "$CI_JSON" | jq empty 2>/dev/null; then
    CI_JSON=$(echo "$CI_DATA" | sed 's/\x1b\[[0-9;]*m//g' | grep -v '^\[' | grep -v '^$' || echo "$CI_DATA")
fi

# Check if we got valid JSON
if ! echo "$CI_JSON" | jq empty 2>/dev/null; then
    echo -e "${RED}âœ— Invalid JSON response from fetch-ci-data${NC}" >&2
    exit 1
fi

# Parse summary
TOTAL=$(echo "$CI_JSON" | jq -r '.summary.total')
CRITICAL=$(echo "$CI_JSON" | jq -r '.summary.critical')
MAJOR=$(echo "$CI_JSON" | jq -r '.summary.major')
MINOR=$(echo "$CI_JSON" | jq -r '.summary.minor')
PR_NUMBER=$(echo "$CI_JSON" | jq -r '.pr_number')
REPO=$(echo "$CI_JSON" | jq -r '.repository')

# Display summary header
echo ""
echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${BOLD}â•‘${NC}           ${CYAN}${BOLD}CI FAILURES SUMMARY${NC}                              ${BOLD}â•‘${NC}"
echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""
echo -e "${BLUE}Repository:${NC} $REPO"
echo -e "${BLUE}PR Number:${NC} #$PR_NUMBER"
echo ""

# Check if there are any failures
if [ "$TOTAL" -eq 0 ]; then
    echo -e "${GREEN}${BOLD}âœ… No CI failures found!${NC}"
    echo ""
    echo -e "${GREEN}All workflows passed successfully.${NC}"
    echo ""
    exit 2
fi

# Display failure counts with color coding
echo -e "${BOLD}Failure Summary:${NC}"
echo ""

if [ "$CRITICAL" -gt 0 ]; then
    echo -e "  ${RED}${BOLD}ðŸ”´ CRITICAL:${NC} $CRITICAL failure(s) - ${RED}Must fix before merge${NC}"
fi

if [ "$MAJOR" -gt 0 ]; then
    echo -e "  ${YELLOW}${BOLD}ðŸŸ  MAJOR:${NC} $MAJOR failure(s) - ${YELLOW}Should fix before merge${NC}"
fi

if [ "$MINOR" -gt 0 ]; then
    echo -e "  ${BLUE}${BOLD}ðŸŸ¡ MINOR:${NC} $MINOR failure(s) - ${BLUE}Nice to fix${NC}"
fi

echo ""
echo -e "${BOLD}Total Failures:${NC} ${RED}$TOTAL${NC}"
echo ""

# ============================================================================
# Error Log Extraction Functions
# ============================================================================

extract_error_from_logs() {
    local run_id="$1"

    # Validate run_id parameter
    if [ -z "$run_id" ] || [ "$run_id" = "null" ]; then
        return 1
    fi

    # Validate run_id is numeric (workflow run IDs are always numeric)
    if ! [[ "$run_id" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    # Fetch logs for the run and extract errors
    # Use gh run view with --log to get full logs
    local logs
    logs=$(gh run view "$run_id" --log 2>/dev/null | grep -A 10 -B 2 -i "error\|fatal\|failed" | head -20 || echo "")

    if [ -z "$logs" ]; then
        return 1
    fi

    echo "$logs"
}

detect_error_pattern() {
    local error_text="$1"

    # Validate error_text parameter
    # Return 2 for empty input to distinguish from "no pattern matched" (return 1)
    if [ -z "$error_text" ]; then
        return 2
    fi

    # Docker build errors
    if echo "$error_text" | grep -qi "fatal: could not read Username"; then
        echo "ðŸ”§ Missing GitHub PAT for private repos"
        echo "   Root Cause: Docker build needs GH_PAT for private GitHub dependencies"
        echo "   Fix: Pass --build-arg GH_PAT=\${{ secrets.GH_PAT }} to docker build"
        return 0
    fi

    if echo "$error_text" | grep -qi "authentication required\|Authentication failed"; then
        echo "ðŸ”§ Authentication failure"
        echo "   Root Cause: Missing or invalid credentials for private resources"
        echo "   Fix: Check GitHub tokens, Docker credentials, or API keys"
        return 0
    fi

    # Poetry/Python dependency errors
    if echo "$error_text" | grep -qi "poetry.*failed\|poetry install.*error"; then
        echo "ðŸ”§ Poetry dependency installation failed"
        echo "   Root Cause: Check pyproject.toml dependencies or lock file"
        echo "   Fix: Run 'poetry lock --no-update' or check for incompatible versions"
        return 0
    fi

    # Python module errors
    if echo "$error_text" | grep -qi "ModuleNotFoundError\|ImportError"; then
        local module
        module=$(echo "$error_text" | grep -oP "(?<=No module named ')[^']+(?=')" | head -1 || echo "unknown")
        echo "ðŸ”§ Missing Python dependency: $module"
        echo "   Root Cause: Module not in requirements or not installed"
        echo "   Fix: Add '$module' to pyproject.toml dependencies"
        return 0
    fi

    # Test failures
    if echo "$error_text" | grep -qi "FAILED.*test_\|AssertionError\|pytest.*failed"; then
        echo "ðŸ”§ Test failures detected"
        echo "   Root Cause: Test assertions failing"
        echo "   Fix: Run 'pytest -v' locally to reproduce and debug"
        return 0
    fi

    # Type checking errors
    if echo "$error_text" | grep -qi "mypy.*error\|type.*error"; then
        echo "ðŸ”§ Type checking errors"
        echo "   Root Cause: Type annotations or type mismatches"
        echo "   Fix: Run 'mypy .' locally to see all type errors"
        return 0
    fi

    # Linting errors
    if echo "$error_text" | grep -qi "ruff.*found\|lint.*error"; then
        echo "ðŸ”§ Linting errors detected"
        echo "   Root Cause: Code style or lint rule violations"
        echo "   Fix: Run 'ruff check . --fix' to auto-fix"
        return 0
    fi

    # Docker service connection errors
    if echo "$error_text" | grep -qi "connection refused\|connection timeout"; then
        echo "ðŸ”§ Service connection failure"
        echo "   Root Cause: Service not ready or network issue"
        echo "   Fix: Add health checks or increase timeout in CI config"
        return 0
    fi

    # Generic error with snippet
    local error_line
    error_line=$(echo "$error_text" | grep -i "error\|fatal\|failed" | head -1 | sed 's/^[[:space:]]*//' | cut -c1-80)
    if [ -n "$error_line" ]; then
        echo "âŒ Error: $error_line"
        return 0
    fi

    # Fallback: error text exists but no recognizable pattern found
    # Provide first non-empty line as context instead of failing silently
    local first_line
    first_line=$(echo "$error_text" | grep -v '^[[:space:]]*$' | head -1 | sed 's/^[[:space:]]*//' | cut -c1-80)
    if [ -n "$first_line" ]; then
        echo "â“ Unrecognized error pattern. First log line:"
        echo "   $first_line"
        return 0
    fi

    # No useful content found in error text
    return 1
}

# Display failed jobs grouped by workflow
echo -e "${BOLD}Failed Jobs:${NC}"
echo ""

# Group failures by workflow
WORKFLOWS=$(echo "$CI_JSON" | jq -r '.failures[].workflow' | sort -u)

while IFS= read -r workflow; do
    if [ -z "$workflow" ]; then
        continue
    fi

    echo -e "${CYAN}${BOLD}$workflow:${NC}"

    # Get failures for this workflow
    echo "$CI_JSON" | jq -r --arg workflow "$workflow" '
        .failures[] |
        select(.workflow == $workflow) |
        "\(.severity)\t\(.workflow_id)\t\(.job)\t\(.step)"
    ' | while IFS=$'\t' read -r severity run_id job step; do
        # Color code by severity
        case $severity in
            critical)
                echo -e "    ${RED}ðŸ”´ CRITICAL:${NC} ${job} â†’ ${step}"
                ;;
            major)
                echo -e "    ${YELLOW}ðŸŸ  MAJOR:${NC} ${job} â†’ ${step}"
                ;;
            minor)
                echo -e "    ${BLUE}ðŸŸ¡ MINOR:${NC} ${job} â†’ ${step}"
                ;;
            *)
                echo -e "    ${NC}â—${NC} ${job} â†’ ${step}"
                ;;
        esac

        # Fetch and display error logs for this failure
        if [ -n "$run_id" ] && [ "$run_id" != "null" ]; then
            # Extract errors from logs
            error_logs=$(extract_error_from_logs "$run_id" 2>/dev/null || echo "")

            if [ -n "$error_logs" ]; then
                # Detect error pattern and provide diagnosis
                diagnosis=$(detect_error_pattern "$error_logs" 2>/dev/null || echo "")

                if [ -n "$diagnosis" ]; then
                    echo "$diagnosis" | while IFS= read -r line; do
                        echo -e "       ${MAGENTA}${line}${NC}"
                    done
                else
                    # Show first few lines of error log
                    echo -e "       ${MAGENTA}Error snippet:${NC}"
                    echo "$error_logs" | head -3 | sed 's/^/         /' | sed "s/\(error\|fatal\|failed\|Error\|Fatal\|Failed\)/${RED}\1${MAGENTA}/gi"
                fi
            fi
        fi

        echo ""
    done

    echo ""
done <<< "$WORKFLOWS"

# Display top error patterns (extract from step names)
echo -e "${BOLD}Top Error Patterns:${NC}"
echo ""

# Get unique step names and count occurrences
echo "$CI_JSON" | jq -r '.failures[].step' | sort | uniq -c | sort -rn | head -5 | while read -r count step; do
    echo -e "  ${MAGENTA}â—${NC} ${step} ${CYAN}(${count} occurrence(s))${NC}"
done

echo ""

# Generate helpful suggestions based on error patterns
echo -e "${BOLD}ðŸ’¡ Suggested Actions:${NC}"
echo ""

# Check for common patterns
HAS_TEST_FAILURES=$(echo "$CI_JSON" | jq -r '.failures[] | select(.step | test("[Tt]est|pytest"))' | wc -l)
HAS_LINT_FAILURES=$(echo "$CI_JSON" | jq -r '.failures[] | select(.step | test("[Ll]int|ruff|flake8"))' | wc -l)
HAS_TYPE_FAILURES=$(echo "$CI_JSON" | jq -r '.failures[] | select(.step | test("[Tt]ype|mypy"))' | wc -l)
HAS_BUILD_FAILURES=$(echo "$CI_JSON" | jq -r '.failures[] | select(.step | test("[Bb]uild|compile"))' | wc -l)

if [ "$HAS_TEST_FAILURES" -gt 0 ]; then
    echo -e "  ${GREEN}1.${NC} Review test failures - run tests locally to reproduce"
    echo -e "     ${CYAN}â†’ pytest -v tests/${NC}"
fi

if [ "$HAS_LINT_FAILURES" -gt 0 ]; then
    echo -e "  ${GREEN}2.${NC} Fix linting errors - run linter locally"
    echo -e "     ${CYAN}â†’ ruff check . --fix${NC}"
fi

if [ "$HAS_TYPE_FAILURES" -gt 0 ]; then
    echo -e "  ${GREEN}3.${NC} Fix type checking errors - run mypy locally"
    echo -e "     ${CYAN}â†’ mypy .${NC}"
fi

if [ "$HAS_BUILD_FAILURES" -gt 0 ]; then
    echo -e "  ${GREEN}4.${NC} Fix build failures - check dependencies and syntax"
    echo -e "     ${CYAN}â†’ Check requirements.txt and package.json${NC}"
fi

echo -e "  ${GREEN}5.${NC} View detailed logs on GitHub Actions"
echo -e "     ${CYAN}â†’ https://github.com/$REPO/pull/$PR_NUMBER/checks${NC}"

echo ""

# Display footer
echo -e "${BOLD}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

# Determine merge readiness
if [ "$CRITICAL" -gt 0 ]; then
    echo -e "${RED}${BOLD}âŒ NOT READY TO MERGE${NC} - Critical failures must be fixed"
elif [ "$MAJOR" -gt 0 ]; then
    echo -e "${YELLOW}${BOLD}âš ï¸  REVIEW NEEDED${NC} - Major failures should be addressed"
elif [ "$MINOR" -gt 0 ]; then
    echo -e "${BLUE}${BOLD}âœ“ READY TO MERGE${NC} - Minor issues can be addressed later"
else
    echo -e "${GREEN}${BOLD}âœ… READY TO MERGE${NC} - All checks passed"
fi

echo -e "${BOLD}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
echo ""

# Exit with appropriate code
if [ "$CRITICAL" -gt 0 ] || [ "$MAJOR" -gt 0 ]; then
    exit 1
else
    exit 0
fi
