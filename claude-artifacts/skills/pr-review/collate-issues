#!/bin/bash
set -euo pipefail

# ============================================================================
# PR Issue Collator - Automated Priority-Based Issue Aggregation
# ============================================================================
# Fetches, parses, categorizes, and prioritizes all PR review issues
# in a single automated command.
#
# Features:
#   - Single command execution: collate-issues <PR#>
#   - Automatic caching via fetch-pr-data
#   - Smart categorization by severity (Critical > Major > Minor > Nit)
#   - Deduplication of similar issues
#   - Token-efficient output (< 2000 tokens)
#   - Ready for agent consumption (no parsing needed)
# ============================================================================

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
FETCH_SCRIPT="$SCRIPT_DIR/fetch-pr-data"
SHOW_STATS=false
INCLUDE_NITPICKS=false
PARALLEL_SOLVE_FORMAT=false

# Usage
usage() {
    cat << 'EOF'
Usage: collate-issues <PR_NUMBER> [OPTIONS]

Automated PR issue collation and prioritization.

Arguments:
  PR_NUMBER    PR number (e.g., 33) or full GitHub URL

Options:
  --include-nitpicks       Include nitpick issues in output (default: excluded)
  --parallel-solve-format  Output in format ready for /parallel-solve command
  --stats                  Show statistics summary
  --help                   Show this help message

Output:
  Clean prioritized list of all PR issues by severity:
    ğŸ”´ CRITICAL - Must address before merge
    ğŸŸ  MAJOR    - Must address before merge
    ğŸŸ¡ MINOR    - Must address before merge
    âšª NITPICK  - Optional improvements (only with --include-nitpicks)

Examples:
  collate-issues 33                      # Critical, Major, Minor only
  collate-issues 33 --include-nitpicks   # Include nitpicks too
  collate-issues 33 --stats              # With statistics summary

Exit codes:
  0 - Success
  1 - Missing arguments or dependencies
  2 - PR data fetch failed
EOF
    exit 1
}

# Check dependencies
check_dependencies() {
    local missing_deps=()

    if [[ ! -x "$FETCH_SCRIPT" ]]; then
        missing_deps+=("fetch-pr-data script (not found or not executable)")
    fi

    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        echo "ERROR: Missing required dependencies:" >&2
        for dep in "${missing_deps[@]}"; do
            echo "  - $dep" >&2
        done
        exit 1
    fi
}

# Extract PR number from argument (handles URLs)
extract_pr_number() {
    local input="$1"

    # If it's a URL, extract the PR number
    if [[ "$input" =~ pull/([0-9]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    # If it's already a number, use it
    elif [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "$input"
    else
        echo "ERROR: Invalid PR number or URL: $input" >&2
        exit 1
    fi
}

# Main collation function
collate_pr_issues() {
    local pr_number="$1"

    # Fetch PR data (uses cache if available)
    local pr_data
    pr_data=$("$FETCH_SCRIPT" "$pr_number" 2>/dev/null) || {
        echo "ERROR: Failed to fetch PR data for PR #$pr_number" >&2
        echo "Try running: $FETCH_SCRIPT $pr_number" >&2
        exit 2
    }

    # Use jq to do ALL parsing and categorization
    # This is much more efficient and handles multiline bodies correctly
    local categorized
    categorized=$(echo "$pr_data" | jq -r '
        # Function to extract severity and summary from CodeRabbit comments
        def parse_coderabbit:
            if (. | test("^_âš ï¸ Potential issue_|^_ğŸ› ï¸ Refactor suggestion_")) then
                # Extract severity from first line
                (split("\n")[0] |
                    if test("ğŸ”´.*Critical") then "critical"
                    elif test("ğŸŸ .*Major") then "major"
                    elif test("ğŸŸ¡.*Minor") then "minor"
                    else "nit"
                    end
                ) as $severity |

                # Extract bold summary (look for **text**)
                ((split("\n") | map(select(test("^\\*\\*[^*]")) | gsub("^\\*\\*|\\*\\*$"; "")) | first) //
                 (split("\n")[1:3] | map(gsub("^[[:space:]]*|[[:space:]]*$"; "")) | map(select(length > 0)) | first)) as $summary |

                {severity: $severity, summary: $summary}
            else
                null
            end;

        # Function to extract actionable items from Claude bot structured reviews
        # Claude bot uses various formats including:
        #   - ## ğŸ› Potential Issues & Concerns
        #   - ### ğŸ”´ Critical: [title]
        #   - ### âš ï¸ Minor Concerns
        #   - ### Must Fix (Before Merge)
        #   - ### Should Fix (Near Term)
        #   - ## ğŸ¯ Final Recommendations
        # Also supports CodeRabbit format: ## ğŸ”´, ## âš ï¸ Moderate, ## ğŸ’¡ Suggestion
        def parse_claude_review:
            if (. | test("## ğŸ”´|## âš ï¸|## ğŸ›|### ğŸ”´|### âš ï¸|### Must Fix|### Should Fix|## ğŸ¯ Final")) then
                # Use simpler string splitting approach
                . as $body |
                [
                    # CodeRabbit: Critical Issues - extract ### N. **Title** items
                    (if ($body | test("## ğŸ”´")) then
                        ($body | split("## ğŸ”´")[1] // "" | split("\n## ")[0]) |
                        [scan("### \\d+\\.\\s*\\*\\*([^*]+)\\*\\*")] |
                        map({severity: "critical", location: "", summary: .[0]})
                    else [] end),

                    # CodeRabbit: Moderate Issues (Major) - extract ### N. **Title** items
                    (if ($body | test("## âš ï¸ Moderate")) then
                        ($body | split("## âš ï¸ Moderate")[1] // "" | split("\n## ")[0]) |
                        [scan("### \\d+\\.\\s*\\*\\*([^*]+)\\*\\*")] |
                        map({severity: "major", location: "", summary: .[0]})
                    else [] end),

                    # CodeRabbit: Suggestions (Minor) - extract ### N. **Title** items
                    (if ($body | test("## ğŸ’¡ Suggestion")) then
                        ($body | split("## ğŸ’¡ Suggestion")[1] // "" | split("\n## ")[0]) |
                        [scan("### \\d+\\.\\s*\\*\\*([^*]+)\\*\\*")] |
                        map({severity: "minor", location: "", summary: .[0]})
                    else [] end),

                    # Claude: ### ğŸ”´ Critical: [title] inline headers
                    (if ($body | test("### ğŸ”´ Critical")) then
                        [scan("### ğŸ”´ Critical[:\\s]*([^\n]+)")] |
                        map({severity: "critical", location: "", summary: .[0]})
                    else [] end),

                    # Claude: ### âš ï¸ Minor/Warning sections
                    (if ($body | test("### âš ï¸")) then
                        [scan("### âš ï¸[^:\n]*[:\\s]*([^\n]+)")] |
                        map({severity: "minor", location: "", summary: .[0]})
                    else [] end),

                    # Claude: ## ğŸ› Potential Issues section - extract numbered items
                    (if ($body | test("## ğŸ›")) then
                        ($body | split("## ğŸ›")[1] // "" | split("\n## ")[0]) |
                        [scan("### \\d+\\.\\s*\\*\\*([^*]+)\\*\\*")] |
                        map({severity: "major", location: "", summary: .[0]})
                    else [] end),

                    # Claude: ### Must Fix (Before Merge) items
                    (if ($body | test("### Must Fix")) then
                        ($body | split("### Must Fix")[1] // "" | split("\n### ")[0]) |
                        [scan("[-*]\\s*([^\n]+)")] |
                        map({severity: "critical", location: "", summary: .[0]})
                    else [] end),

                    # Claude: ### Should Fix (Near Term) items
                    (if ($body | test("### Should Fix")) then
                        ($body | split("### Should Fix")[1] // "" | split("\n### ")[0]) |
                        [scan("[-*]\\s*([^\n]+)")] |
                        map({severity: "major", location: "", summary: .[0]})
                    else [] end),

                    # Claude: ## ğŸ¯ Final Recommendations - extract action items
                    (if ($body | test("## ğŸ¯ Final")) then
                        ($body | split("## ğŸ¯ Final")[1] // "" | split("\n## ")[0]) |
                        [scan("[-*]\\s*\\*\\*([^*]+)\\*\\*|[-*]\\s*([^\n]{10,})")] |
                        map(.[0] // .[1]) | map(select(. != null)) |
                        map({severity: "major", location: "", summary: .})
                    else [] end),

                    # Action Items - Before Merge (Critical)
                    (if ($body | test("Before Merge \\(Critical\\)")) then
                        ($body | split("Before Merge (Critical)")[1] // "" |
                            split("Before Merge (Recommended)")[0] // split("Post-Merge")[0] // split("\n## ")[0]) |
                        [scan("\\d+\\.\\s*[âœ…âš ï¸ğŸ’¡â“]*\\s*(Fix[^\n]+|Standardize[^\n]+|Simplify[^\n]+)")] |
                        map({severity: "critical", location: "", summary: .[0]})
                    else [] end),

                    # Action Items - Before Merge (Recommended)
                    (if ($body | test("Before Merge \\(Recommended\\)")) then
                        ($body | split("Before Merge (Recommended)")[1] // "" |
                            split("Post-Merge")[0] // split("\n## ")[0]) |
                        [scan("\\d+\\.\\s*[âœ…âš ï¸ğŸ’¡â“]*\\s*([^\n]+)")] |
                        map({severity: "major", location: "", summary: .[0]})
                    else [] end)
                ] | flatten | map(select(.summary != null and (.summary | type == "string") and (.summary | length) > 3))
            else
                []
            end;

        # Function to extract first non-empty line
        def extract_summary:
            split("\n") | map(gsub("^[[:space:]]*|[[:space:]]*$"; "")) | map(select(length > 0)) | first // "";

        # Process all comments - split into regular and Claude bot reviews
        (
            [
                # Reviews
                (.reviews[]? |
                    {location: "", body: (.body // ""), is_claude: false}),

                # Inline comments
                (.inline_comments[]? |
                    {location: "[\(.path):\(.line)]", body: (.body // ""), is_claude: false}),

                # PR comments
                (.pr_comments[]? |
                    {location: "", body: (.body // ""), is_claude: (.author | test("claude"; "i"))}),

                # Issue comments
                (.issue_comments[]? |
                    {location: "", body: (.body // ""), is_claude: (.author | test("claude"; "i"))})
            ]
        ) as $all_comments |

        # Process Claude bot reviews separately to extract structured items
        # Pattern matches both Claude bot and CodeRabbit structured review formats
        ([$all_comments[] | select(.is_claude == true and (.body | test("## ğŸ”´|## âš ï¸|## ğŸ›|### ğŸ”´|### âš ï¸|### Must Fix|### Should Fix|## ğŸ¯ Final|## ğŸ’¡ Suggestion"))) | .body | parse_claude_review] | flatten | map(select(. != null and .summary != null))) as $claude_items |

        # Process non-Claude comments normally
        ([$all_comments[] |
            select(.is_claude == false or (.body | test("## ğŸ”´|## âš ï¸|## ğŸ›|### ğŸ”´|### âš ï¸|### Must Fix|### Should Fix|## ğŸ¯ Final|## ğŸ’¡ Suggestion") | not)) |
            select(.body != "" and .body != null) |

            # Skip already addressed
            select(.body | test("âœ… Addressed") | not) |

            # Skip auto-generated summary headers and standalone HTML comments
            select(.body | test("^\\*\\*Actionable comments posted:|^## Summary by CodeRabbit|^[[:space:]]*<!--.*-->[[:space:]]*$") | not) |

            # Skip positive feedback
            select(.body | test("^âœ…|^âœ”|excellent|great job|well done|looks good|lgtm|approved"; "i") | not) |

            # Parse CodeRabbit or extract summary
            (.body | parse_coderabbit) as $cr |

            if $cr != null then
                # Use CodeRabbit categorization
                {
                    severity: $cr.severity,
                    location: .location,
                    summary: $cr.summary
                }
            else
                # Manual categorization based on keywords
                (.body | extract_summary) as $summary |

                select($summary | length > 10) |
                select($summary | test("^<!--.*-->$") | not) |

                if (.body | test("(missing|vulnerable|unprotected|exposed|insecure).*(security|SQL|injection|XSS|CSRF)|deprecated.*(flag|option|command)|(test|tests).*(fail|failing|failure)|pytest-xdist.*(conflict|incompatible)|breaking.?change|crashes|critical.?bug"; "i")) then
                    {severity: "critical", location: .location, summary: $summary}
                elif (.body | test("(inconsistent|missing|should|need).*(API|contract|pattern|architecture)|(missing|no|lacks).*(error.?handling|validation|exit.?code)|standardize.*(exit.?code|error)|race.?condition|deadlock|performance.?issue"; "i")) then
                    {severity: "major", location: .location, summary: $summary}
                elif (.body | test("missing.*(documentation|docstring|YAML|frontmatter|test|type.?hint)|(should|need).*(document|test|edge.?case)|consider.*(add|document|test)"; "i")) then
                    {severity: "minor", location: .location, summary: $summary}
                elif (.body | test("nitpick|nit:|style|consider.?renaming|optional|minor.?improvement"; "i")) then
                    {severity: "nit", location: .location, summary: $summary}
                else
                    empty
                end
            end
        ]) as $regular_items |

        # Combine Claude items and regular items
        ($claude_items + $regular_items) |

        # Deduplicate by summary (keep first occurrence)
        unique_by(.summary) |

        # Group by severity
        group_by(.severity) |
        map({
            key: .[0].severity,
            value: map(if .location != "" then (.location + " " + .summary) else .summary end)
        }) |
        from_entries
    ')

    # Extract counts
    local critical_count=$(echo "$categorized" | jq -r '.critical // [] | length')
    local major_count=$(echo "$categorized" | jq -r '.major // [] | length')
    local minor_count=$(echo "$categorized" | jq -r '.minor // [] | length')
    local nit_count=$(echo "$categorized" | jq -r '.nit // [] | length')
    local total_count=$((critical_count + major_count + minor_count + nit_count))

    # Output results
    if [[ "$PARALLEL_SOLVE_FORMAT" == "true" ]]; then
        # Parallel-solve format - ready to pass to /parallel-solve command
        echo "Fix all PR #${pr_number} review issues:"
        echo ""

        # Critical issues
        if [[ $critical_count -gt 0 ]]; then
            echo "ğŸ”´ CRITICAL:"
            echo "$categorized" | jq -r '.critical // [] | to_entries | map("- \(.value)") | .[]'
            echo ""
        fi

        # Major issues
        if [[ $major_count -gt 0 ]]; then
            echo "ğŸŸ  MAJOR:"
            echo "$categorized" | jq -r '.major // [] | to_entries | map("- \(.value)") | .[]'
            echo ""
        fi

        # Minor issues
        if [[ $minor_count -gt 0 ]]; then
            echo "ğŸŸ¡ MINOR:"
            echo "$categorized" | jq -r '.minor // [] | to_entries | map("- \(.value)") | .[]'
            echo ""
        fi

        # Nitpicks (only if flag is set)
        if [[ "$INCLUDE_NITPICKS" == "true" ]] && [[ $nit_count -gt 0 ]]; then
            echo "âšª NITPICK:"
            echo "$categorized" | jq -r '.nit // [] | to_entries | map("- \(.value)") | .[]'
            echo ""
        fi
    else
        # Regular human-readable format
        echo "PR #${pr_number} Issues - Prioritized"
        echo ""

        # Critical issues
        if [[ $critical_count -gt 0 ]]; then
            echo "ğŸ”´ CRITICAL ($critical_count):"
            echo "$categorized" | jq -r '.critical // [] | to_entries | map("\(.key + 1). \(.value)") | .[]'
            echo ""
        fi

        # Major issues
        if [[ $major_count -gt 0 ]]; then
            echo "ğŸŸ  MAJOR ($major_count):"
            echo "$categorized" | jq -r '.major // [] | to_entries | map("\(.key + 1). \(.value)") | .[]'
            echo ""
        fi

        # Minor issues
        if [[ $minor_count -gt 0 ]]; then
            echo "ğŸŸ¡ MINOR ($minor_count):"
            echo "$categorized" | jq -r '.minor // [] | to_entries | map("\(.key + 1). \(.value)") | .[]'
            echo ""
        fi

        # Nitpicks (only if flag is set)
        if [[ "$INCLUDE_NITPICKS" == "true" ]] && [[ $nit_count -gt 0 ]]; then
            echo "âšª NITPICK ($nit_count):"
            echo "$categorized" | jq -r '.nit // [] | to_entries | map("\(.key + 1). \(.value)") | .[]'
            echo ""
        fi

        # Summary
        if [[ "$INCLUDE_NITPICKS" == "true" ]]; then
            echo "Summary: ${critical_count} critical, ${major_count} major, ${minor_count} minor, ${nit_count} nitpick = ${total_count} issues total"
        else
            local actionable_count=$((critical_count + major_count + minor_count))
            echo "Summary: ${critical_count} critical, ${major_count} major, ${minor_count} minor = ${actionable_count} actionable issues (nitpicks excluded)"
        fi
    fi

    # Optional statistics
    if [[ "$SHOW_STATS" == "true" ]]; then
        echo ""
        echo "Statistics:"
        local stats
        stats=$(echo "$pr_data" | jq -r '.summary |
            "  Total comments: \(.total_all_comments)",
            "  Reviews: \(.total_reviews)",
            "  Inline: \(.total_inline_comments)",
            "  PR comments: \(.total_pr_comments)",
            "  Issue comments: \(.total_issue_comments)"
        ')
        echo "$stats"
    fi
}

# Main
main() {
    local pr_number=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --include-nitpicks)
                INCLUDE_NITPICKS=true
                shift
                ;;
            --parallel-solve-format)
                PARALLEL_SOLVE_FORMAT=true
                shift
                ;;
            --stats)
                SHOW_STATS=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            *)
                if [[ -z "$pr_number" ]]; then
                    pr_number="$1"
                else
                    echo "ERROR: Unknown argument: $1" >&2
                    usage
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$pr_number" ]]; then
        usage
    fi

    check_dependencies

    pr_number=$(extract_pr_number "$pr_number")

    collate_pr_issues "$pr_number"
}

main "$@"
