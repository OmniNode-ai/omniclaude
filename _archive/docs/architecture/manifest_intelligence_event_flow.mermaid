%% Manifest Intelligence Event-Driven Architecture - Event Flow Diagram
%% This diagram illustrates the complete event flow for unified manifest intelligence gathering

sequenceDiagram
    participant Client as ManifestInjector<br/>(omniclaude)
    participant EventClient as IntelligenceEventClient<br/>(omniclaude)
    participant Kafka as Kafka Event Bus<br/>(192.168.86.200:9092)
    participant Consumer as Intelligence Adapter<br/>(omniarchon)
    participant Handler as ManifestHandler<br/>(omniarchon)
    participant Qdrant as Qdrant Backend
    participant PostgreSQL as PostgreSQL Backend
    participant Docker as Docker Backend
    participant KafkaAdmin as Kafka Admin API

    Note over Client,KafkaAdmin: UNIFIED MANIFEST REQUEST FLOW (Recommended Approach)

    %% Request Initiation
    Client->>Client: Generate correlation_id
    Client->>EventClient: request_manifest_intelligence()
    Note right of Client: sections: ["patterns",<br/>"infrastructure",<br/>"models",<br/>"database_schemas",<br/>"debug_intelligence"]

    %% Publish Request
    EventClient->>Kafka: Publish MANIFEST_REQUESTED
    Note right of EventClient: Topic:<br/>manifest.requested.v1<br/>Key: correlation_id

    %% Consumer Processing
    Kafka->>Consumer: Consume event
    Consumer->>Consumer: Route to ManifestHandler
    Consumer->>Handler: handle_request(request)

    %% Parallel Backend Queries
    Note over Handler,KafkaAdmin: PARALLEL QUERY EXECUTION (asyncio.gather)

    par Query Patterns
        Handler->>Qdrant: Query patterns<br/>(collections: execution_patterns,<br/>code_patterns)
        Qdrant-->>Handler: Patterns data<br/>(450ms)
    and Query Infrastructure
        Handler->>PostgreSQL: Get DB info
        PostgreSQL-->>Handler: Connection details
        Handler->>Docker: List services
        Docker-->>Handler: Service list
        Handler->>KafkaAdmin: Get topics
        KafkaAdmin-->>Handler: Topic list
        Handler->>Qdrant: Get collections
        Qdrant-->>Handler: Collection info
        Note right of Handler: Aggregated<br/>(650ms)
    and Query Models
        Handler->>Handler: Scan filesystem<br/>for ONEX models
        Handler-->>Handler: Model data<br/>(200ms)
    and Query Database Schemas
        Handler->>PostgreSQL: Query information_schema
        PostgreSQL-->>Handler: Table schemas<br/>(300ms)
    and Query Debug Intelligence
        Handler->>PostgreSQL: Query workflow_events<br/>+ agent_execution_logs
        PostgreSQL-->>Handler: Similar workflows<br/>(400ms)
    end

    %% Aggregate Results
    Handler->>Handler: Aggregate results
    Note right of Handler: Total time:<br/>max(450, 650, 200, 300, 400)<br/>= 650ms (parallel!)

    %% Build Response
    Handler->>Handler: Build unified response
    Note right of Handler: Summary:<br/>sections_succeeded: 5<br/>sections_failed: 0<br/>partial_results: false<br/>total_query_time_ms: 650

    %% Publish Response
    Handler->>Consumer: Return response
    Consumer->>Kafka: Publish MANIFEST_COMPLETED
    Note right of Consumer: Topic:<br/>manifest.completed.v1<br/>Key: correlation_id

    %% Client Receives Response
    Kafka->>EventClient: Consume response
    EventClient->>Client: Return manifest data

    %% Client Processing
    Client->>Client: Build manifest from response
    Client->>Client: Format for agent prompt
    Client->>Client: Store to database<br/>(agent_manifest_injections)
    Client->>Client: Cache to Valkey

    Note over Client,KafkaAdmin: Total end-to-end latency: ~850ms (publish + query + consume)

    %% Partial Failure Scenario
    Note over Client,KafkaAdmin: PARTIAL FAILURE SCENARIO

    par Query Success
        Handler->>Qdrant: Query patterns
        Qdrant-->>Handler: ✓ Success (450ms)
    and Query Success
        Handler->>Docker: List services
        Docker-->>Handler: ✓ Success (650ms)
    and Query Timeout
        Handler->>PostgreSQL: Query schemas
        Note right of Handler: Connection timeout!
        PostgreSQL--xHandler: ✗ Timeout (2000ms)
    and Query Success
        Handler->>PostgreSQL: Query workflows
        PostgreSQL-->>Handler: ✓ Success (400ms)
    end

    Handler->>Handler: Build partial response
    Note right of Handler: Summary:<br/>sections_succeeded: 3<br/>sections_failed: 1<br/>partial_results: true<br/>warnings: ["database_schemas<br/>unavailable"]

    Handler->>Consumer: Return partial response
    Consumer->>Kafka: Publish MANIFEST_COMPLETED<br/>(with partial results)
    Kafka->>EventClient: Consume response
    EventClient->>Client: Return partial manifest

    Client->>Client: Use fallback for failed sections
    Note right of Client: Graceful degradation:<br/>Empty schema list used
