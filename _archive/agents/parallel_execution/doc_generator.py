"""
Documentation Generator - Generates human-readable documentation from agent results

Responsible for:
- Converting agent results to Markdown documentation
- Creating structured README files
- Generating API documentation
- Creating architecture diagrams
- Preserving analysis insights and recommendations
"""

import os
from datetime import datetime
from typing import Any


class MarkdownDocGenerator:
    """Generates comprehensive Markdown documentation from agent results."""

    def __init__(self, output_dir: str = "generated_docs"):
        """Initialize documentation generator."""
        self.output_dir = output_dir
        self.ensure_directory(self.output_dir)

    def ensure_directory(self, directory_path: str) -> None:
        """Ensure directory exists."""
        os.makedirs(directory_path, exist_ok=True)

    def generate_from_results(self, results: dict[str, Any]) -> None:
        """Generate documentation from agent results."""
        try:
            # Extract results list from phase_results if needed
            results_list: list[Any] = []
            if "phase_results" in results:
                # Extract from phase results structure
                for phase in results["phase_results"]:
                    if "output_data" in phase and "results" in phase["output_data"]:
                        phase_results = phase["output_data"]["results"]
                        # Convert dict of results to list
                        if isinstance(phase_results, dict):
                            results_list.extend(phase_results.values())
                        else:
                            results_list.extend(phase_results)
            elif "results" in results:
                # Direct results structure
                results_data = results["results"]
                if isinstance(results_data, dict):
                    results_list = list(results_data.values())
                elif isinstance(results_data, list):
                    results_list = results_data
                else:
                    print(
                        f"[DocGenerator] Warning: Unexpected results format: {type(results_data)}"
                    )
                    return

            print(
                f"[DocGenerator] Generating documentation from {len(results_list)} results"
            )

            # Normalize structure for internal methods
            normalized_results = {"results": results_list}

            # Create main README
            print("[DocGenerator] Generating main README...")
            self._generate_main_readme(normalized_results)

            # Generate task-specific documentation
            print("[DocGenerator] Generating task docs...")
            self._generate_task_docs(normalized_results)

            # Generate API documentation
            print("[DocGenerator] Generating API docs...")
            self._generate_api_docs(normalized_results)

            # Generate architecture documentation
            print("[DocGenerator] Generating architecture docs...")
            self._generate_architecture_docs(normalized_results)

            # Generate implementation guide
            print("[DocGenerator] Generating implementation guide...")
            self._generate_implementation_guide(normalized_results)

            print("[DocGenerator] ✓ All documentation generated successfully")

        except Exception as e:
            import traceback

            print(f"[DocGenerator] ✗ Error: {e}")
            traceback.print_exc()

    def _generate_main_readme(self, results: dict[str, Any]) -> None:
        """Generate main README file."""
        readme_path = os.path.join(self.output_dir, "README.md")

        content = f"""# Generated ONEX Implementation

Generated by OmniClaude Agent Framework on {datetime.now().isoformat()}

## Overview

This directory contains a complete ONEX-compliant implementation generated through AI agent analysis and design.

## Components

### Generated Files
"""

        # Add file information
        if "results" in results:
            for result in results["results"]:
                # Skip if result is not a dict
                if not isinstance(result, dict):
                    continue
                if result.get("success"):
                    task_id = result.get("task_id", "")
                    agent_name = result.get("agent_name", "")
                    content += f"- **{task_id}** - Generated by {agent_name}\n"

        content += """
## Quick Start

1. **Review the architecture** - See `ARCHITECTURE.md`
2. **Check API documentation** - See `API.md`
3. **Follow implementation guide** - See `IMPLEMENTATION.md`
4. **Run tests** - See generated test files

## Agent Analysis Results

"""

        # Add agent results
        if "results" in results:
            for result in results["results"]:
                # Skip if result is not a dict
                if not isinstance(result, dict):
                    continue
                if result.get("success"):
                    task_id = result.get("task_id", "")
                    agent_name = result.get("agent_name", "")
                    output_data = result.get("output_data", {})

                    content += f"### {task_id} ({agent_name})\n\n"

                    # Add recommendations
                    recommendations = output_data.get("recommendations", [])
                    if recommendations:
                        content += "**Recommendations:**\n"
                        for i, rec in enumerate(recommendations, 1):
                            if isinstance(rec, str):
                                # Simple string recommendation
                                content += f"{i}. {rec}\n"
                            elif isinstance(rec, dict):
                                # Structured recommendation
                                content += f"{i}. **{rec.get('title', 'No title')}**\n"
                                content += f"   - *Priority*: {rec.get('priority', 'Unknown')}\n"
                                content += f"   - *Category*: {rec.get('category', 'Unknown')}\n"
                                if rec.get("implementation_steps"):
                                    content += "   - *Implementation Steps:*\n"
                                    for step in rec["implementation_steps"]:
                                        content += f"     - {step}\n"
                            content += "\n"

                    # Add analysis summary
                    if output_data.get("analysis_summary"):
                        content += f"**Analysis Summary:**\n{output_data['analysis_summary']}\n\n"

                    # Add key insights
                    if output_data.get("key_insights"):
                        content += "**Key Insights:**\n"
                        for insight in output_data["key_insights"]:
                            content += f"- {insight}\n"
                        content += "\n"

                    content += "---\n\n"

        with open(readme_path, "w") as f:
            f.write(content)

        print(f"[DocGenerator] Generated: {readme_path}")

    def _generate_task_docs(self, results: dict[str, Any]) -> None:
        """Generate task-specific documentation."""
        tasks_dir = os.path.join(self.output_dir, "tasks")
        self.ensure_directory(tasks_dir)

        if "results" not in results:
            return

        for result in results["results"]:
            # Skip if result is not a dict
            if not isinstance(result, dict):
                continue
            if not result.get("success"):
                continue

            task_id = result.get("task_id", "").replace("/", "_")
            agent_name = result.get("agent_name", "")
            output_data = result.get("output_data", {})

            # Create task-specific file
            task_file = os.path.join(tasks_dir, f"{task_id}.md")

            content = f"""# {task_id}

**Agent:** {agent_name}
**Generated:** {datetime.now().isoformat()}

## Analysis Results

"""

            # Add summary if available
            if output_data.get("analysis_summary"):
                content += f"## Summary\n\n{output_data['analysis_summary']}\n\n"

            # Add recommendations
            recommendations = output_data.get("recommendations", [])
            if recommendations:
                content += "## Recommendations\n\n"
                for i, rec in enumerate(recommendations, 1):
                    if isinstance(rec, str):
                        # Simple string recommendation
                        content += f"### {i}. {rec}\n\n"
                    elif isinstance(rec, dict):
                        # Structured recommendation
                        content += f"### {i}. {rec.get('title', 'No title')}\n\n"
                        content += f"**Priority:** {rec.get('priority', 'Unknown')}\n"
                        content += f"**Category:** {rec.get('category', 'Unknown')}\n"
                        content += (
                            f"**Effort:** {rec.get('estimated_effort', 'Unknown')}\n\n"
                        )

                        if rec.get("description"):
                            content += f"**Description:** {rec['description']}\n\n"

                        if rec.get("implementation_steps"):
                            content += "**Implementation Steps:**\n"
                            for step in rec["implementation_steps"]:
                                content += f"- {step}\n"
                            content += "\n"

                    content += "---\n\n"

            # Add key insights
            if output_data.get("key_insights"):
                content += "## Key Insights\n\n"
                for insight in output_data["key_insights"]:
                    content += f"- {insight}\n"
                content += "\n"

            # Add quality metrics if available
            if output_data.get("quality_metrics"):
                content += "## Quality Metrics\n\n"
                for key, value in output_data["quality_metrics"].items():
                    content += f"- **{key}:** {value}\n"
                content += "\n"

            with open(task_file, "w") as f:
                f.write(content)

            print(f"[DocGenerator] Generated task doc: {task_file}")

    def _generate_api_docs(self, results: dict[str, Any]) -> None:
        """Generate API documentation."""
        api_file = os.path.join(self.output_dir, "API.md")

        content = """# API Documentation

## Overview

This document describes the API interfaces and data contracts for the generated implementation.

## Core Interfaces

### NodeConsulAdapterEffect

Primary effect node for Consul API integration.

#### Operations

- `register` - Register a new service
- `deregister` - Remove a service
- `health_check` - Check service health
- `kv_get` - Get configuration value
- `kv_set` - Set configuration value
- `discover` - Discover service instances

#### Usage

```python
# Initialize adapter
adapter = NodeConsulAdapterEffect(consul_client)

# Register a service
result = await adapter.execute_effect({
    "operation": "register",
    "service_id": "my-service",
    "service_name": "my-service",
    "address": "192.168.1.100",
    "port": 8080
})

if result['success']:
    print(f"Service registered: {result['service_id']}")
```

## Data Contracts

### Input Contracts

#### Service Registration
- `operation` (str): Operation type
- `service_id` (str): Unique service identifier
- `service_name` (str): Human-readable service name
- `address` (str): Service IP address
- `port` (int): Service port
- `health_check_url` (str, optional): Health check endpoint
- `tags` (list, optional): Service tags

#### KV Operations
- `operation` (str): Operation type
- `key` (str): Configuration key
- `value` (str, optional): Configuration value

### Output Contracts

All operations return a dictionary with:
- `success` (bool): Operation success status
- `operation` (str): Operation type performed
- `error` (str, optional): Error message if failed
- Additional fields specific to operation type

## Error Handling

The system provides comprehensive error handling:
- Invalid input validation
- Network error handling
- Graceful degradation
- Detailed error messages

## Examples

See `tasks/` directory for detailed examples and usage patterns.
"""

        with open(api_file, "w") as f:
            f.write(content)

        print(f"[DocGenerator] Generated API docs: {api_file}")

    def _generate_architecture_docs(self, results: dict[str, Any]) -> None:
        """Generate architecture documentation."""
        arch_file = os.path.join(self.output_dir, "ARCHITECTURE.md")

        content = """# Architecture Documentation

## System Overview

This generated system follows ONEX architectural principles with clear separation of concerns and modular design.

## Core Components

### Effect Nodes
Handle external I/O operations and API interactions:
- **NodeConsulAdapterEffect**: Consul API integration
- **Interface**: Abstracts external system dependencies

### Model Contracts
Define data structures with validation rules:
- **Input Contracts**: Validate incoming data
- **Output Contracts**: Format response data
- **Error Contracts**: Handle error scenarios

## ONEX Framework Compliance

### Node Types
- **Effect Nodes**: Handle external I/O operations (Consul API calls)
- **Interface Segregation**: Clean, focused interfaces
- **Dependency Injection**: Testable, loosely coupled components

### Design Patterns Applied
- **Adapter Pattern**: Abstract external system dependencies
- **Strategy Pattern**: Configurable validation rules
- **Interface Segregation**: Clean, focused interfaces
- **Dependency Injection**: Testable, loosely coupled components

## Data Flow

```
Input Request
     ↓
[Input Validation]
     ↓
[Effect Node]
     ↓
[External API]
     ↓
[Response Processing]
     ↓
[Output Validation]
     ↓
Formatted Response
```

### Data Flow Steps

1. **Input Validation**: Model contracts validate incoming data
2. **Operation Routing**: Effect node routes to appropriate external operation
3. **API Interaction**: Client adapter handles HTTP communication
4. **Response Processing**: Results are validated and formatted
5. **Error Handling**: Comprehensive error management throughout

## Quality Assurance

- **Type Safety**: Strong typing with Pydantic models
- **Validation**: Input/output contract validation
- **Error Handling**: Graceful degradation and clear error messages
- **Logging**: Comprehensive logging for debugging and monitoring
- **Testing**: Mockable interfaces for unit testing

## Security Considerations

### Input Validation
- All inputs validated before processing
- Type checking and constraint validation via Pydantic models
- Sanitization of user-provided data

### Credential Management
- **NEVER store credentials in Consul KV** without encryption
- Use dedicated secret management systems:
  - HashiCorp Vault
  - AWS Secrets Manager
  - Azure Key Vault
  - GCP Secret Manager
- Store only references to secrets, not actual credentials
- Implement proper ACLs on sensitive configuration paths
- Rotate credentials regularly using automated processes

### Error Handling
- Sanitized error messages that don't expose internal details
- Avoid leaking sensitive information in stack traces
- Log security events for audit purposes

### Access Control
- Controlled external system access with proper authentication
- Implement least-privilege principle for service accounts
- Use mutual TLS for service-to-service communication
- Monitor and audit API access patterns

### Configuration Security
- Externalized configuration management
- Environment-specific configuration isolation
- Secure defaults for all configuration parameters
- Configuration validation at startup
"""

        with open(arch_file, "w") as f:
            f.write(content)

        print(f"[DocGenerator] Generated architecture docs: {arch_file}")

    def _generate_implementation_guide(self, results: dict[str, Any]) -> None:
        """Generate implementation guide."""
        impl_file = os.path.join(self.output_dir, "IMPLEMENTATION.md")

        content = """# Implementation Guide

## Getting Started

This guide provides step-by-step instructions for implementing and deploying the generated Consul adapter.

## Prerequisites

- Python 3.8+
- Consul server running
- Required dependencies installed
- Proper configuration set up

## Installation

1. **Install Dependencies**
   ```bash
   pip install -r requirements.txt
   ```

2. **Configure Consul Connection**
   ```python
   # Set environment variables
   export CONSUL_URL="http://localhost:8500"
   export CONSUL_TOKEN="your-token-if-needed"
   ```

3. **Initialize the Adapter**
   ```python
   from NodeConsulAdapterEffect import NodeConsulAdapterEffect
   from consul_client_adapter import ConsulClientAdapter

   # Create adapter instance
   consul_client = ConsulClientAdapter("http://localhost:8500")
   adapter = NodeConsulAdapterEffect(consul_client)
   ```

## Usage Examples

### Service Registration

```python
import asyncio
from model_contract_consul import ModelContractConsulServiceInput, ConsulOperationType

async def register_service():
    # Prepare service configuration
    service_config = {
        "operation": ConsulOperationType.REGISTER,
        "service_id": "web-api-v1",
        "service_name": "web-api",
        "address": "10.0.1.100",
        "port": 8080,
        "health_check_url": "http://10.0.1.100:8080/health",
        "tags": ["api", "v1", "web"]
    }

    # Validate input
    input_contract = ModelContractConsulServiceInput(**service_config)
    validation = input_contract.validate()

    if not validation.is_valid:
        print(f"Validation failed: {validation.errors}")
        return False

    # Register service
    result = await adapter.execute_effect(service_config)

    if result['success']:
        print(f"✅ Service registered: {result['service_id']}")
        return True
    else:
        print(f"❌ Registration failed: {result['error']}")
        return False

# Run the example
asyncio.run(register_service())
```

### Configuration Management

```python
async def manage_config():
    # Get configuration
    config = get_config()

    # ⚠️ SECURITY WARNING: This is a simplified example for demonstration purposes.
    #
    # In production environments:
    # 1. NEVER store credentials in Consul KV without encryption
    # 2. Use secret management systems (Vault, AWS Secrets Manager, etc.)
    # 3. Store only references to secrets, not the secrets themselves
    # 4. Implement proper ACLs on Consul KV paths containing sensitive data
    # 5. Use environment variables or secure secret injection at runtime
    #
    # Better approach: Store only connection metadata, retrieve credentials securely
    # Example: Store "db_host", "db_port", "db_name" separately,
    #          retrieve credentials from Vault at runtime

    # SAFE: Store non-sensitive connection metadata
    await adapter.execute_effect({
        "operation": "kv_set",
        "key": "config/database/host",
        "value": config.postgres_host
    })

    await adapter.execute_effect({
        "operation": "kv_set",
        "key": "config/database/port",
        "value": str(config.postgres_port)
    })

    await adapter.execute_effect({
        "operation": "kv_set",
        "key": "config/database/name",
        "value": config.postgres_db
    })

    # UNSAFE - DON'T DO THIS IN PRODUCTION:
    # Storing full connection strings with credentials exposes sensitive data
    # await adapter.execute_effect({
    #     "operation": "kv_set",
    #     "key": "config/database_url",
    #     "value": f"postgresql://user:password@{host}:{port}/{db}"  # ❌ NEVER DO THIS
    # })

    # RECOMMENDED: Reference secret manager path instead
    await adapter.execute_effect({
        "operation": "kv_set",
        "key": "config/database/credentials_path",
        "value": "vault://secrets/database/postgres/credentials"  # ✅ Reference, not secret
    })

    # Get configuration value
    result = await adapter.execute_effect({
        "operation": "kv_get",
        "key": "config/database/host"
    })

    if result['success']:
        print(f"Database Host: {result['value']}")

asyncio.run(manage_config())
```

### Service Discovery

```python
async def discover_services():
    result = await adapter.execute_effect({
        "operation": "discover",
        "service_name": "web-api"
    })

    if result['success']:
        print(f"Found {result['count']} instances:")
        for instance in result['instances']:
            print(f"  - {instance['address']}:{instance['port']}")

asyncio.run(discover_services())
```

## Testing

### Unit Testing

```python
import pytest
from unittest.mock import Mock, AsyncMock

@pytest.fixture
def mock_consul_client():
    client = Mock()
    client.register_service = AsyncMock(return_value=True)
    client.deregister_service = AsyncMock(return_value=True)
    return client

@pytest.fixture
def adapter(mock_consul_client):
    return NodeConsulAdapterEffect(mock_consul_client)

@pytest.mark.asyncio
async def test_service_registration(adapter):
    result = await adapter.execute_effect({
        "operation": "register",
        "service_id": "test-service",
        "service_name": "test",
        "address": "127.0.0.1",
        "port": 8080
    })

    assert result['success']
    assert result['service_id'] == "test-service"
    assert result['operation'] == "register"
```

### Integration Testing

```python
import pytest
import asyncio
from consul_client_adapter import ConsulClientAdapter
from NodeConsulAdapterEffect import NodeConsulAdapterEffect

@pytest.mark.integration
async def test_full_workflow():
    # Setup real Consul client
    consul_client = ConsulClientAdapter("http://localhost:8500")
    adapter = NodeConsulAdapterEffect(consul_client)

    # Test registration
    reg_result = await adapter.execute_effect({
        "operation": "register",
        "service_id": "integration-test",
        "service_name": "test-service",
        "address": "127.0.0.1",
        "port": 9999
    })

    assert reg_result['success']

    # Test discovery
    disc_result = await adapter.execute_effect({
        "operation": "discover",
        "service_name": "test-service"
    })

    assert disc_result['success']
    assert disc_result['count'] > 0

    # Cleanup
    await adapter.execute_effect({
        "operation": "deregister",
        "service_id": "integration-test"
    })
```

## Monitoring and Debugging

### Logging

The adapter provides comprehensive logging:

```python
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Adapter will automatically log:
# - Operation start/completion
# - Success/failure status
# - Error details
# - Performance metrics
```

### Health Checks

Monitor adapter health:

```python
async def health_check():
    # Check adapter connectivity
    result = await adapter.execute_effect({
        "operation": "health_check",
        "service_id": "consul-itself"
    })

    return result['success']

# Periodic health check
while await health_check():
    print("Adapter is healthy")
    await asyncio.sleep(30)
```

## Troubleshooting

### Common Issues

1. **Connection Refused**
   - Verify Consul server is running
   - Check network connectivity
   - Validate URL configuration

2. **Authentication Errors**
   - Verify ACL tokens
   - Check permissions
   - Validate token format

3. **Service Registration Failures**
   - Check input validation
   - Verify service ID uniqueness
   - Validate health check configuration

### Debug Mode

Enable debug logging:

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

This will provide detailed information about:
- HTTP requests/responses
- Internal state changes
- Validation results
- Error stack traces

## Production Deployment

### Configuration Management

Use environment variables for production:

```bash
# Required
CONSUL_URL="http://consul-production:8500"

# Optional
CONSUL_TOKEN="production-token"
LOG_LEVEL="INFO"
HEALTH_CHECK_INTERVAL="30s"
TIMEOUT="5s"
```

### Performance Optimization

- Use connection pooling
- Implement retry logic
- Cache frequently accessed data
- Monitor performance metrics

### Security Best Practices

#### Secret Management
- **NEVER hardcode credentials** in configuration files or code
- Use dedicated secret management systems (Vault, AWS Secrets Manager, etc.)
- Inject secrets at runtime via environment variables or secret providers
- Implement automatic credential rotation
- Audit all secret access with centralized logging

#### Network Security
- Use TLS/HTTPS for all Consul connections in production
- Implement mutual TLS (mTLS) for service-to-service communication
- Use network policies to restrict service access
- Enable certificate validation and pinning

#### Access Control
- Implement proper ACL policies with least-privilege principle
- Use service-specific tokens with minimal required permissions
- Rotate tokens regularly (recommended: every 30-90 days)
- Monitor and audit access logs for suspicious activity
- Implement token expiration and automatic renewal

#### Input Validation
- Validate all inputs at API boundaries
- Sanitize user-provided data to prevent injection attacks
- Implement rate limiting to prevent abuse
- Use schema validation for all configuration data

#### Example: Secure Configuration Loading

```python
import os
from pathlib import Path

# ✅ RECOMMENDED: Load from environment or secret manager
CONSUL_URL = os.getenv('CONSUL_URL', 'http://localhost:8500')
CONSUL_TOKEN = os.getenv('CONSUL_TOKEN')  # Retrieved from secret manager

# ✅ RECOMMENDED: Validate configuration at startup
if not CONSUL_URL.startswith(('http://', 'https://')):
    raise ValueError("Invalid CONSUL_URL format")

# ❌ NEVER DO THIS: Hardcoded credentials
# CONSUL_TOKEN = "hardcoded-token-value"  # DON'T DO THIS

# ❌ NEVER DO THIS: Credentials in version control
# with open('.secrets.json') as f:  # DON'T COMMIT THIS FILE
#     secrets = json.load(f)
```
"""

        with open(impl_file, "w") as f:
            f.write(content)

        print(f"[DocGenerator] Generated implementation guide: {impl_file}")

    def _sanitize_filename(self, filename: str) -> str:
        """Sanitize filename for file system."""
        import re

        # Replace problematic characters
        sanitized = re.sub(r"[^\w\-_\.]", "_", filename)
        # Ensure it starts with alphanumeric
        if sanitized and not sanitized[0].isalnum():
            sanitized = f"file_{sanitized}"
        return sanitized.lower() if sanitized else "unknown"
