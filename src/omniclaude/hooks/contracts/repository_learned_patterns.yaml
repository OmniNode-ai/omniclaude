# SPDX-License-Identifier: MIT
# Copyright (c) 2025 OmniNode Team
#
# Learned Patterns Repository Contract
#
# Defines database operations for pattern injection via contract-driven access.
# This contract is consumed by PostgresRepositoryRuntime from omnibase_infra.
#
# Part of OMN-1779: Wire ManifestInjector to contract runtime
#
# Schema Mapping (learned_patterns table → PatternRecord):
# ─────────────────────────────────────────────────────────
# The SQL aliases map database columns to PatternRecord fields. If the
# learned_patterns table schema changes, update these mappings accordingly:
#
#   DB Column                      → PatternRecord Field
#   ────────────────────────────────────────────────────────
#   id::text                       → pattern_id
#   domain_id                      → domain
#   pattern_signature              → title
#   compiled_snippet               → description
#   confidence                     → confidence
#   recurrence_count               → usage_count
#   (computed from rolling stats)  → success_rate
#   NULL                           → example_reference (not stored)
#   status                         → lifecycle_state (only in list_injectable_patterns)
#   evidence_tier                  → evidence_tier (UNMEASURED/MEASURED/VERIFIED)
#
# Default Values:
# - success_rate default: 0.5 (50%) - Used when no injection history exists.
#   Represents a neutral prior that doesn't bias toward or against new patterns.
#   This Bayesian prior allows new patterns to be tried without unfair penalty.

# Contract metadata
name: learned_patterns
engine: postgres
database_ref: omninode_bridge
description: >
  Repository contract for learned patterns used in context injection.
  Patterns are stored in the learned_patterns table and injected into
  Claude Code sessions to improve response quality.

# Tables this contract is allowed to access (enforced by validators)
tables:
  - learned_patterns

# Pydantic models for row mapping
# Format: alias -> module:class
models:
  PatternRow: omniclaude.hooks.handler_context_injection:PatternRecord

# Database operations
ops:
  # READ: List validated patterns for injection (primary operation)
  list_validated_patterns:
    mode: read
    description: >
      Retrieve patterns that are validated, enabled, and current.
      Results are ordered by quality_score descending then id
      for deterministic ordering.
    sql: |
      SELECT
        id::text AS pattern_id,
        domain_id AS domain,
        pattern_signature AS title,
        COALESCE(compiled_snippet, '') AS description,
        confidence,
        recurrence_count AS usage_count,
        CASE
          WHEN injection_count_rolling_20 > 0
          THEN success_count_rolling_20::float / injection_count_rolling_20
          ELSE 0.5  -- See header: Bayesian prior for new patterns
        END AS success_rate,
        NULL::text AS example_reference,
        COALESCE(evidence_tier, 'UNMEASURED') AS evidence_tier
      FROM learned_patterns
      WHERE status = 'validated'
        AND deprecated_at IS NULL
        AND is_current = TRUE
      ORDER BY quality_score DESC NULLS LAST, id ASC
      LIMIT $1
    params:
      limit:
        name: limit
        param_type: integer
        required: false
        nullable: false
        default:
          value_type: number
          number_value:
            value: 10
            value_type: integer
        ge: 1
        le: 200
        description: Maximum number of patterns to return
    returns:
      model_ref: PatternRow
      many: true

  # READ: Get single pattern by ID
  get_pattern_by_id:
    mode: read
    description: Retrieve a specific pattern by its ID.
    sql: |
      SELECT
        id::text AS pattern_id,
        domain_id AS domain,
        pattern_signature AS title,
        COALESCE(compiled_snippet, '') AS description,
        confidence,
        recurrence_count AS usage_count,
        CASE
          WHEN injection_count_rolling_20 > 0
          THEN success_count_rolling_20::float / injection_count_rolling_20
          ELSE 0.5  -- See header: Bayesian prior for new patterns
        END AS success_rate,
        NULL::text AS example_reference,
        COALESCE(evidence_tier, 'UNMEASURED') AS evidence_tier
      FROM learned_patterns
      WHERE id = $1::uuid
    params:
      pattern_id:
        name: pattern_id
        param_type: uuid
        required: true
        nullable: false
        description: The pattern UUID to retrieve
    returns:
      model_ref: PatternRow
      many: false

  # READ: List patterns by domain
  list_patterns_by_domain:
    mode: read
    description: >
      Retrieve validated patterns filtered by domain.
      Includes 'general' domain patterns that apply to all domains.
    sql: |
      SELECT
        id::text AS pattern_id,
        domain_id AS domain,
        pattern_signature AS title,
        COALESCE(compiled_snippet, '') AS description,
        confidence,
        recurrence_count AS usage_count,
        CASE
          WHEN injection_count_rolling_20 > 0
          THEN success_count_rolling_20::float / injection_count_rolling_20
          ELSE 0.5  -- See header: Bayesian prior for new patterns
        END AS success_rate,
        NULL::text AS example_reference,
        COALESCE(evidence_tier, 'UNMEASURED') AS evidence_tier
      FROM learned_patterns
      WHERE status = 'validated'
        AND deprecated_at IS NULL
        AND is_current = TRUE
        AND (domain_id = $1 OR domain_id = 'general')
      ORDER BY quality_score DESC NULLS LAST, id ASC
      LIMIT $2
    params:
      domain:
        name: domain
        param_type: string
        required: true
        nullable: false
        description: The domain to filter by
      limit:
        name: limit
        param_type: integer
        required: false
        nullable: false
        default:
          value_type: number
          number_value:
            value: 10
            value_type: integer
        ge: 1
        le: 200
        description: Maximum number of patterns to return
    returns:
      model_ref: PatternRow
      many: true

  # READ: List injectable patterns (validated + provisional) for graduated injection
  # Part of OMN-2042: Graduated Injection Policy
  list_injectable_patterns:
    mode: read
    description: >
      Retrieve patterns that are injectable (validated or provisional), enabled,
      and current. Includes the status column so the handler can differentiate
      between validated and provisional patterns for annotation and dampening.
      Validated patterns are ordered first, then by quality_score descending.
      Note: min_confidence filtering is done in Python (select_patterns_for_injection)
      rather than SQL. For large tables, pushing confidence >= $2 to SQL would
      reduce data transfer (tracked as optimization opportunity).
    sql: |
      SELECT
        id::text AS pattern_id,
        domain_id AS domain,
        pattern_signature AS title,
        COALESCE(compiled_snippet, '') AS description,
        confidence,
        recurrence_count AS usage_count,
        CASE
          WHEN injection_count_rolling_20 > 0
          THEN success_count_rolling_20::float / injection_count_rolling_20
          ELSE 0.5  -- See header: Bayesian prior for new patterns
        END AS success_rate,
        NULL::text AS example_reference,
        status AS lifecycle_state,
        COALESCE(evidence_tier, 'UNMEASURED') AS evidence_tier
      FROM learned_patterns
      WHERE status IN ('validated', 'provisional')
        AND deprecated_at IS NULL
        AND is_current = TRUE
      ORDER BY CASE WHEN status = 'validated' THEN 0 ELSE 1 END,
               quality_score DESC NULLS LAST, id ASC
      LIMIT $1
    params:
      limit:
        name: limit
        param_type: integer
        required: false
        nullable: false
        default:
          value_type: number
          number_value:
            value: 10
            value_type: integer
        ge: 1
        le: 200
        description: Maximum number of patterns to return
    returns:
      model_ref: PatternRow
      many: true
