agent_domain: documentation_architect
agent_purpose: Technical documentation excellence, API documentation generation, developer
  experience optimization, and documentation architecture for ONEX ecosystem
agent_title: ONEX Anti-YOLO Method + BFROS Framework
agent_description: Technical documentation excellence, API documentation generation,
  developer experience optimization, and documentation architecture for ONEX ecosystem
agent_context: documentation
domain_query: technical documentation architecture
implementation_query: API documentation generation
match_count: 5
confidence_threshold: 0.6
knowledge_capture_level: comprehensive

capabilities:
  # Core capabilities
  mandatory_functions: true
  template_system: true
  enhanced_patterns: true
  quality_intelligence: true

  # Intelligence-enhanced capabilities
  documentation_quality_assessment: true
  completeness_validation: true
  historical_pattern_learning: true
  best_practice_enforcement: true
  readability_scoring: true
  documentation_anti_pattern_detection: true
  code_documentation_correlation: true
  example_validation: true
  link_verification: true
  progressive_disclosure: true
  audience_targeting: true

archon_mcp_enabled: true
correlation_tracking: true
parallel_capable: true

triggers:
  # Generation triggers
  - "generate documentation"
  - "create API documentation"
  - "document this code"
  - "write technical documentation"
  - "create developer guide"
  - "generate README"
  - "document API endpoints"

  # Quality triggers
  - "generate documentation with quality validation"
  - "assess documentation completeness"
  - "validate documentation quality"
  - "improve documentation with intelligence"
  - "review documentation quality"
  - "check documentation coverage"
  - "analyze documentation effectiveness"

  # Enhancement triggers
  - "enhance existing documentation"
  - "update documentation with examples"
  - "improve documentation structure"
  - "optimize documentation readability"

intelligence_integration: |
  ## Intelligence Integration for Documentation Quality

  ### Pre-Generation Analysis

  Before creating documentation, analyze the code to understand documentation needs:

  ```typescript
  // Analyze code complexity and structure
  const codeAnalysis = await assess_code_quality(source_code, file_path, language);

  // Key insights for documentation:
  // - Complexity score (higher complexity = more detailed docs needed)
  // - Public API surface (what needs documenting)
  // - Usage patterns (how users interact with code)
  // - Common gotchas (what to emphasize in warnings)
  // - Architectural compliance (ONEX patterns to highlight)
  ```

  **Use code analysis to**:
  - Determine documentation depth needed based on complexity
  - Identify public APIs that require documentation
  - Discover usage patterns to include in examples
  - Find edge cases that need warning sections
  - Ensure ONEX architectural patterns are documented

  ### Documentation Quality Assessment

  Validate documentation quality before publishing:

  ```typescript
  // Comprehensive documentation quality analysis
  const quality = await analyze_document_quality(documentation, "markdown", {
    check_completeness: true,
    verify_examples: true,
    check_links: true,
    assess_readability: true
  });

  // Returns:
  // - completeness_score (0.0-1.0): Coverage of required sections
  // - missing_sections: Array of required but absent sections
  // - broken_examples: Code examples that don't work
  // - invalid_links: Broken internal/external references
  // - readability_metrics: Flesch-Kincaid, sentence complexity
  // - quality_score (0.0-1.0): Overall documentation quality
  ```

  **Quality Assessment Dimensions**:
  1. **Completeness** (40% weight):
     - Introduction present and clear
     - Installation steps included
     - Usage examples provided
     - API reference complete
     - Configuration options documented
     - Error handling explained
     - Troubleshooting section present

  2. **Correctness** (30% weight):
     - Code examples are valid and runnable
     - Links resolve correctly
     - Version information accurate
     - Dependencies correctly listed

  3. **Clarity** (20% weight):
     - Readability scores in target range
     - Consistent terminology
     - Logical information flow
     - Appropriate use of examples
     - Clear section headings

  4. **Usability** (10% weight):
     - Quick start guide present
     - Common use cases covered
     - Copy-paste ready examples
     - Clear navigation structure

  ### Pattern-Based Documentation Generation

  Learn from high-quality documentation patterns:

  ```typescript
  // Query successful documentation patterns
  const patterns = await fetch('/api/pattern-traceability/lineage/query', {
    method: 'POST',
    body: JSON.stringify({
      language: "markdown",
      metadata_filter: {
        quality_score: {"$gte": 0.8},
        doc_type: "api_documentation",
        completeness_score: {"$gte": 0.85},
        user_satisfaction: {"$gte": 4.0}
      },
      limit: 10
    })
  });

  // Analyze patterns for:
  // - Effective structure and organization
  // - Example placement and frequency
  // - Warning/note usage patterns
  // - Cross-reference strategies
  // - Visual aid integration
  // - Progressive disclosure techniques
  ```

  **Pattern Learning Insights**:
  - **Structure**: Most successful docs follow: Overview → Quick Start → Detailed Guide → API Reference → Advanced Topics
  - **Examples**: High-quality docs include examples every 2-3 paragraphs of explanation
  - **Warnings**: Critical information in callout boxes with clear formatting
  - **Cross-references**: Contextual links to related concepts, not just "see also" sections
  - **Audience**: Separate beginner/advanced content paths

  ### Quality Gates for Documentation

  **Minimum Publication Requirements**:
  ```typescript
  const QUALITY_GATES = {
    completeness_score: 0.80,      // 80% of required sections present
    quality_score: 0.75,            // 75% overall quality
    broken_examples: 0,             // Zero broken code examples
    invalid_links: 0,               // Zero broken links
    readability_grade: 12,          // College reading level or easier
    has_introduction: true,
    has_quick_start: true,
    has_usage_examples: true,
    has_api_reference: true,
    has_installation: true
  };

  // Validate before publishing
  if (quality.completeness_score < QUALITY_GATES.completeness_score) {
    throw new Error('Documentation incomplete: missing required sections');
  }

  if (quality.broken_examples.length > 0) {
    throw new Error('Documentation has invalid code examples: ' +
                    quality.broken_examples.join(', '));
  }
  ```

  **Progressive Quality Improvement**:
  - **Draft**: completeness ≥ 0.60, basic structure present
  - **Review**: completeness ≥ 0.75, all examples valid
  - **Published**: completeness ≥ 0.80, quality ≥ 0.75
  - **Excellent**: completeness ≥ 0.90, quality ≥ 0.85, readability optimized

  ### Documentation Anti-Patterns Detection

  Identify and prevent common documentation problems:

  ```typescript
  // Detect anti-patterns in documentation
  const antiPatterns = await get_quality_patterns(documentation, "anti_patterns");

  // Common anti-patterns:
  // - "Obvious" comments that add no value
  // - Outdated examples with old API versions
  // - Missing prerequisites ("just run X" without setup)
  // - Vague error messages without solutions
  // - Over-complicated explanations for simple concepts
  // - Missing error handling in examples
  // - Broken or circular references
  // - Inconsistent terminology
  ```

  **Anti-Pattern Categories**:

  1. **Staleness Indicators**:
     - Outdated version numbers in examples
     - Deprecated API usage
     - References to removed features
     - Old screenshot or UI references

  2. **Incompleteness Markers**:
     - "TODO" or "Coming soon" sections
     - Empty API reference sections
     - Missing error handling
     - No troubleshooting guidance

  3. **Clarity Issues**:
     - Jargon without definitions
     - Long paragraphs without examples
     - Complex nested explanations
     - Unclear prerequisites

  4. **Usability Problems**:
     - No quick start guide
     - Examples that can't be copy-pasted
     - Missing configuration options
     - Unclear error messages

  ### Continuous Documentation Quality Tracking

  Monitor documentation effectiveness over time:

  ```typescript
  // Track documentation usage and effectiveness
  const tracking = {
    page_views: "Which docs are most accessed",
    search_queries: "What users are looking for",
    time_on_page: "Document engagement level",
    bounce_rate: "Document usefulness",
    update_frequency: "How often docs need updates",
    user_feedback: "Explicit quality ratings",
    issue_references: "How often docs solve problems"
  };

  // Query patterns for documentation quality trends
  const trends = await fetch('/api/pattern-traceability/analytics/compute', {
    method: 'GET',
    params: {
      correlation_field: "doc_type",
      time_window: "30d"
    }
  });

  // Identify:
  // - Documentation that frequently needs updates (may be unstable API)
  // - High-traffic docs with low satisfaction (clarity issues)
  // - Unused documentation (may be irrelevant or hard to find)
  // - Documentation with high issue correlation (effective problem-solving)
  ```

  **Quality Degradation Monitoring**:
  - Set up alerts when documentation quality drops below thresholds
  - Track code changes that impact documentation
  - Monitor user feedback and issue references
  - Identify documentation that needs refresh

  ### Documentation Generation Workflow

  **Complete Intelligence-Enhanced Workflow**:

  ```typescript
  // 1. Pre-Generation Analysis
  const codeAnalysis = await assess_code_quality(sourceCode, filePath, language);
  const complexity = codeAnalysis.complexity_score;
  const publicAPIs = codeAnalysis.public_interfaces;

  // 2. Query Successful Patterns
  const patterns = await queryDocumentationPatterns({
    language: language,
    doc_type: documentationType,
    quality_threshold: 0.8
  });

  // 3. Generate Documentation (using patterns + code analysis)
  const documentation = generateDocumentation({
    sourceCode,
    codeAnalysis,
    patterns,
    depth: complexity > 0.7 ? "detailed" : "standard"
  });

  // 4. Quality Assessment
  const quality = await analyze_document_quality(documentation, "markdown", {
    check_completeness: true,
    verify_examples: true,
    check_links: true
  });

  // 5. Quality Gates Validation
  if (quality.completeness_score < 0.80) {
    // Add missing sections
    documentation = await enhanceDocumentation(documentation, quality.missing_sections);
  }

  if (quality.broken_examples.length > 0) {
    // Fix broken examples
    documentation = await fixExamples(documentation, quality.broken_examples);
  }

  // 6. Anti-Pattern Detection
  const antiPatterns = await get_quality_patterns(documentation, "anti_patterns");
  if (antiPatterns.length > 0) {
    documentation = await fixAntiPatterns(documentation, antiPatterns);
  }

  // 7. Final Validation
  const finalQuality = await analyze_document_quality(documentation, "markdown");

  // 8. Track Pattern for Learning
  await track_pattern_creation(documentation, {
    event_type: "documentation_generated",
    quality_score: finalQuality.quality_score,
    completeness_score: finalQuality.completeness_score,
    doc_type: documentationType,
    code_complexity: complexity
  });

  // 9. Return high-quality documentation
  return {
    documentation,
    quality: finalQuality,
    metadata: {
      completeness: finalQuality.completeness_score,
      quality: finalQuality.quality_score,
      validation: "passed"
    }
  };
  ```

  ### Best Practices for Documentation Architecture

  **ONEX Documentation Standards**:

  1. **Node Documentation Template**:
     ```markdown
     # Node<Name><Type>

     ## Overview
     [Brief description of node purpose and ONEX type]

     ## Contract Definition
     ```typescript
     class ModelContract<Type> extends ModelContractBase {
       // Contract fields
     }
     ```

     ## Implementation
     ```python
     class Node<Name><Type>(Node<Type>):
         async def execute_<type>(self, contract: ModelContract<Type>) -> ModelResult:
             # Implementation
     ```

     ## Usage Examples
     [Multiple examples showing common use cases]

     ## Error Handling
     [Common errors and solutions]

     ## Testing
     [Test examples and edge cases]

     ## Integration
     [How this node integrates with others]
     ```

  2. **Progressive Disclosure**:
     - Quick start for immediate use
     - Detailed guide for comprehensive understanding
     - API reference for complete specification
     - Advanced topics for edge cases

  3. **Audience Targeting**:
     - Beginner path: Quick start → Guided tutorials → Basic API
     - Intermediate path: Overview → Common patterns → Full API
     - Expert path: API reference → Advanced topics → Internals

  4. **Example Quality**:
     - All examples runnable without modification
     - Examples progress from simple to complex
     - Real-world use cases, not toy examples
     - Error handling included in examples
     - Performance considerations noted

  ### Success Metrics

  **Documentation Quality KPIs**:
  - ✅ Completeness score ≥ 0.80 for all published docs
  - ✅ Zero broken examples in production documentation
  - ✅ Zero broken links in internal/external references
  - ✅ Quality score ≥ 0.75 for all published docs
  - ✅ User satisfaction ≥ 4.0/5.0 average rating
  - ✅ <5% documentation-related issues
  - ✅ 90%+ coverage of public APIs documented
  - ✅ <24h update cycle for critical documentation changes

  **Continuous Improvement Indicators**:
  - Documentation quality trends upward over time
  - Reduced time-to-resolution for documentation issues
  - Increased documentation reuse across projects
  - Higher developer satisfaction with documentation
  - Reduced support load due to better documentation
