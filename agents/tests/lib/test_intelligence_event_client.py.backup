#!/usr/bin/env python3
"""
Comprehensive Test Suite for IntelligenceEventClient

Tests event-based intelligence integration with Kafka, including:
- Client lifecycle management (start/stop)
- Request-response pattern with correlation tracking
- Pattern discovery and code analysis operations
- Timeout handling and graceful degradation
- Error handling and edge cases
- Background consumer task management

Coverage Target: >90%
Reference: EVENT_INTELLIGENCE_INTEGRATION_PLAN.md Section 2.1
"""

import asyncio
import json
import pytest
from datetime import UTC, datetime
from unittest.mock import AsyncMock, MagicMock, Mock, patch, call
from uuid import uuid4, UUID

from aiokafka.errors import KafkaError

from agents.lib.intelligence_event_client import (
    IntelligenceEventClient,
    IntelligenceEventClientContext,
)


# ============================================================================
# Test Fixtures
# ============================================================================

@pytest.fixture
def test_config():
    """Test configuration for event client."""
    return {
        "bootstrap_servers": "localhost:29092",
        "request_timeout_ms": 5000,
        "topic_request": "dev.archon-intelligence.intelligence.code-analysis-requested.v1",
        "topic_completed": "dev.archon-intelligence.intelligence.code-analysis-completed.v1",
        "topic_failed": "dev.archon-intelligence.intelligence.code-analysis-failed.v1",
    }


@pytest.fixture
async def mock_kafka_producer():
    """Mock AIOKafkaProducer."""
    producer = AsyncMock()
    producer.start = AsyncMock()
    producer.stop = AsyncMock()
    producer.send_and_wait = AsyncMock()
    return producer


@pytest.fixture
async def mock_kafka_consumer():
    """Mock AIOKafkaConsumer."""
    consumer = AsyncMock()
    consumer.start = AsyncMock()
    consumer.stop = AsyncMock()
    consumer.getone = AsyncMock()
    consumer.seek_to_beginning = AsyncMock()
    consumer.seek_to_end = AsyncMock()

    # Make consumer async iterable
    async def async_iter():
        yield MagicMock()

    consumer.__aiter__ = lambda self: async_iter()
    return consumer


@pytest.fixture
async def event_client(test_config, mock_kafka_producer, mock_kafka_consumer):
    """Initialized event client with mocked Kafka."""
    with patch('agents.lib.intelligence_event_client.AIOKafkaProducer', return_value=mock_kafka_producer), \
         patch('agents.lib.intelligence_event_client.AIOKafkaConsumer', return_value=mock_kafka_consumer):

        client = IntelligenceEventClient(
            bootstrap_servers=test_config["bootstrap_servers"],
            timeout_ms=test_config["request_timeout_ms"],
        )
        await client.start()
        yield client
        await client.stop()


@pytest.fixture
def sample_correlation_id():
    """Sample correlation ID for testing."""
    return uuid4()


@pytest.fixture
def sample_request_payload():
    """Sample request payload."""
    return {
        "source_path": "node_*_effect.py",
        "language": "python",
        "operation_type": "PATTERN_EXTRACTION",
        "options": {
            "include_tests": False,
            "max_patterns": 10,
        }
    }


@pytest.fixture
def sample_completed_response(sample_correlation_id):
    """Sample completed response payload."""
    return {
        "correlation_id": str(sample_correlation_id),
        "event_type": "code_analysis_completed",
        "timestamp": "2025-10-23T10:30:00Z",
        "payload": {
            "source_path": "node_*_effect.py",
            "patterns": [
                {
                    "file_path": "node_db_effect.py",
                    "confidence": 0.95,
                    "pattern_type": "database_effect",
                    "code_snippet": "async def execute_effect(self, contract):",
                },
                {
                    "file_path": "node_api_effect.py",
                    "confidence": 0.88,
                    "pattern_type": "api_effect",
                    "code_snippet": "async def execute_effect(self, contract):",
                },
            ],
            "metadata": {
                "total_files_scanned": 150,
                "processing_time_ms": 450,
            }
        },
    }


@pytest.fixture
def sample_failed_response(sample_correlation_id):
    """Sample failed response payload."""
    return {
        "correlation_id": str(sample_correlation_id),
        "event_type": "code_analysis_failed",
        "timestamp": "2025-10-23T10:30:00Z",
        "payload": {
            "error_code": "PATTERN_NOT_FOUND",
            "error_message": "No patterns found matching criteria",
            "details": {
                "source_path": "node_*_effect.py",
                "scanned_directories": ["/src/nodes"],
            }
        },
    }


# ============================================================================
# Unit Tests: Initialization and Lifecycle
# ============================================================================

class TestInitialization:
    """Test IntelligenceEventClient initialization."""

    @pytest.mark.asyncio
    async def test_init_creates_producer_consumer(self, test_config):
        """Test initialization creates Kafka producer and consumer."""
        with patch('agents.lib.intelligence_event_client.AIOKafkaProducer') as MockProducer, \
             patch('agents.lib.intelligence_event_client.AIOKafkaConsumer') as MockConsumer:

            client = IntelligenceEventClient(
                bootstrap_servers=test_config["bootstrap_servers"],
                timeout_ms=test_config["request_timeout_ms"],
            )

            # Verify producer created with correct config
            MockProducer.assert_called_once()
            producer_kwargs = MockProducer.call_args[1]
            assert producer_kwargs["bootstrap_servers"] == test_config["bootstrap_servers"]

            # Verify consumer created with correct topics
            MockConsumer.assert_called_once()
            consumer_args = MockConsumer.call_args[0]
            assert test_config["topic_completed"] in consumer_args
            assert test_config["topic_failed"] in consumer_args

    @pytest.mark.asyncio
    async def test_start_initializes_kafka_infrastructure(self, mock_kafka_producer, mock_kafka_consumer):
        """Test start() initializes Kafka producer and consumer."""
        with patch('agents.lib.intelligence_event_client.AIOKafkaProducer', return_value=mock_kafka_producer), \
             patch('agents.lib.intelligence_event_client.AIOKafkaConsumer', return_value=mock_kafka_consumer):

            client = IntelligenceEventClient(
                bootstrap_servers="localhost:29092",
                timeout_ms=5000,
            )

            await client.start()

            # Verify producer started
            mock_kafka_producer.start.assert_called_once()

            # Verify consumer started
            mock_kafka_consumer.start.assert_called_once()

    @pytest.mark.asyncio
    async def test_stop_closes_connections(self, event_client, mock_kafka_producer, mock_kafka_consumer):
        """Test stop() gracefully closes Kafka connections."""
        await event_client.stop()

        # Verify producer stopped
        mock_kafka_producer.stop.assert_called_once()

        # Verify consumer stopped
        mock_kafka_consumer.stop.assert_called_once()


# ============================================================================
# Unit Tests: Request-Response Pattern
# ============================================================================

class TestRequestResponse:
    """Test request-response pattern with correlation tracking."""

    @pytest.mark.asyncio
    async def test_request_pattern_discovery_success(
        self,
        event_client,
        mock_kafka_producer,
        mock_kafka_consumer,
        sample_correlation_id,
        sample_completed_response,
    ):
        """Test successful pattern discovery via events."""
        # Mock successful response
        mock_kafka_consumer.getone.return_value = MagicMock(
            value=json.dumps(sample_completed_response).encode('utf-8')
        )

        # Execute request
        patterns = await event_client.request_pattern_discovery(
            source_path="node_*_effect.py",
            language="python",
            operation_type="PATTERN_EXTRACTION",
            timeout_ms=5000,
        )

        # Verify request published
        mock_kafka_producer.send_and_wait.assert_called_once()
        call_args = mock_kafka_producer.send_and_wait.call_args

        # Verify request contains correlation_id
        request_value = json.loads(call_args[1]["value"].decode('utf-8'))
        assert "correlation_id" in request_value
        assert UUID(request_value["correlation_id"])  # Valid UUID

        # Verify patterns returned
        assert isinstance(patterns, list)
        assert len(patterns) == 2
        assert patterns[0]["file_path"] == "node_db_effect.py"
        assert patterns[0]["confidence"] == 0.95
        assert patterns[1]["file_path"] == "node_api_effect.py"

    @pytest.mark.asyncio
    async def test_request_code_analysis_success(
        self,
        event_client,
        mock_kafka_producer,
        mock_kafka_consumer,
        sample_completed_response,
    ):
        """Test successful code analysis request."""
        # Mock successful response
        mock_kafka_consumer.getone.return_value = MagicMock(
            value=json.dumps(sample_completed_response).encode('utf-8')
        )

        # Execute request
        result = await event_client.request_code_analysis(
            source_path="test.py",
            content="def test(): pass",
            language="python",
            options={"analyze_complexity": True},
            timeout_ms=10000,
        )

        # Verify request published
        mock_kafka_producer.send_and_wait.assert_called_once()

        # Verify result structure
        assert isinstance(result, dict)
        assert "patterns" in result
        assert "metadata" in result

    @pytest.mark.asyncio
    async def test_correlation_id_tracking(
        self,
        event_client,
        mock_kafka_producer,
        mock_kafka_consumer,
    ):
        """Test correlation ID matches request and response."""
        correlation_id = uuid4()

        # Mock response with matching correlation_id
        response = {
            "correlation_id": str(correlation_id),
            "event_type": "code_analysis_completed",
            "payload": {"patterns": []},
        }
        mock_kafka_consumer.getone.return_value = MagicMock(
            value=json.dumps(response).encode('utf-8')
        )

        # Execute request with specific correlation_id (via mocking internal method)
        with patch.object(event_client, '_generate_correlation_id', return_value=correlation_id):
            await event_client.request_pattern_discovery(
                source_path="test.py",
                language="python",
                operation_type="PATTERN_EXTRACTION",
                timeout_ms=5000,
            )

        # Verify request used same correlation_id
        call_args = mock_kafka_producer.send_and_wait.call_args
        request_value = json.loads(call_args[1]["value"].decode('utf-8'))
        assert request_value["correlation_id"] == str(correlation_id)


# ============================================================================
# Unit Tests: Timeout and Error Handling
# ============================================================================

class TestTimeoutHandling:
    """Test timeout handling and error scenarios."""

    @pytest.mark.asyncio
    async def test_request_pattern_discovery_timeout(
        self,
        event_client,
        mock_kafka_consumer,
    ):
        """Test timeout handling in pattern discovery."""
        # Mock timeout by never returning response
        async def timeout_func(*args, **kwargs):
            await asyncio.sleep(10)  # Longer than timeout
            return None

        mock_kafka_consumer.getone.side_effect = timeout_func

        # Execute request with short timeout
        with pytest.raises(TimeoutError) as exc_info:
            await event_client.request_pattern_discovery(
                source_path="test.py",
                language="python",
                operation_type="PATTERN_EXTRACTION",
                timeout_ms=100,  # Very short timeout
            )

        assert "timeout" in str(exc_info.value).lower()

    @pytest.mark.asyncio
    async def test_multiple_concurrent_requests(
        self,
        event_client,
        mock_kafka_producer,
        mock_kafka_consumer,
    ):
        """Test multiple concurrent requests with correlation tracking."""
        # Create unique responses for each correlation_id
        responses = []
        for i in range(3):
            correlation_id = uuid4()
            response = {
                "correlation_id": str(correlation_id),
                "event_type": "code_analysis_completed",
                "payload": {"patterns": [{"id": i}]},
            }
            responses.append((correlation_id, response))

        # Mock consumer to return responses in order
        response_values = [
            MagicMock(value=json.dumps(resp[1]).encode('utf-8'))
            for resp in responses
        ]
        mock_kafka_consumer.getone.side_effect = response_values

        # Execute concurrent requests
        tasks = []
        for corr_id, _ in responses:
            with patch.object(event_client, '_generate_correlation_id', return_value=corr_id):
                task = event_client.request_pattern_discovery(
                    source_path=f"test_{corr_id}.py",
                    language="python",
                    operation_type="PATTERN_EXTRACTION",
                    timeout_ms=5000,
                )
                tasks.append(task)

        # Wait for all requests
        results = await asyncio.gather(*tasks)

        # Verify all requests completed
        assert len(results) == 3
        for i, result in enumerate(results):
            assert result[0]["id"] == i

    @pytest.mark.asyncio
    async def test_kafka_connection_error_handling(self, test_config):
        """Test graceful handling of Kafka connection errors."""
        with patch('agents.lib.intelligence_event_client.AIOKafkaProducer') as MockProducer:
            MockProducer.side_effect = Exception("Connection refused")

            with pytest.raises(KafkaError) as exc_info:
                client = IntelligenceEventClient(
                    bootstrap_servers=test_config["bootstrap_servers"],
                    timeout_ms=5000,
                )
                await client.start()

            assert "connection" in str(exc_info.value).lower()

    @pytest.mark.asyncio
    async def test_malformed_response_handling(
        self,
        event_client,
        mock_kafka_consumer,
    ):
        """Test handling of malformed response data."""
        # Mock malformed JSON response
        mock_kafka_consumer.getone.return_value = MagicMock(
            value=b"invalid json{{{",
        )

        # Execute request
        with pytest.raises((KafkaError, ValueError, json.JSONDecodeError)) as exc_info:
            await event_client.request_pattern_discovery(
                source_path="test.py",
                language="python",
                operation_type="PATTERN_EXTRACTION",
                timeout_ms=5000,
            )

        # May raise various parsing errors depending on implementation


# ============================================================================
# Integration Tests (with testcontainers or mock Kafka)
# ============================================================================

class TestIntegration:
    """Integration tests with mock Kafka environment."""

    @pytest.mark.integration
    @pytest.mark.asyncio
    async def test_end_to_end_request_response(
        self,
        test_config,
        sample_completed_response,
    ):
        """Test full end-to-end request-response flow with mock handler."""
        # Create event client
        with patch('agents.lib.intelligence_event_client.AIOKafkaProducer') as MockProducer, \
             patch('agents.lib.intelligence_event_client.AIOKafkaConsumer') as MockConsumer:

            producer = AsyncMock()
            consumer = AsyncMock()

            MockProducer.return_value = producer
            MockConsumer.return_value = consumer

            # Mock handler response
            consumer.getone.return_value = MagicMock(
                value=json.dumps(sample_completed_response).encode('utf-8')
            )

            client = IntelligenceEventClient(
                bootstrap_servers=test_config["bootstrap_servers"],
                timeout_ms=5000,
            )
            await client.start()

            # Execute request
            patterns = await client.request_pattern_discovery(
                source_path="node_*_effect.py",
                language="python",
                operation_type="PATTERN_EXTRACTION",
                timeout_ms=5000,
            )

            # Verify patterns received
            assert len(patterns) > 0
            assert patterns[0]["confidence"] > 0.0

            await client.stop()

    @pytest.mark.integration
    @pytest.mark.asyncio
    async def test_timeout_with_no_response(self, test_config):
        """Test timeout scenario with no response from handler."""
        with patch('agents.lib.intelligence_event_client.AIOKafkaProducer') as MockProducer, \
             patch('agents.lib.intelligence_event_client.AIOKafkaConsumer') as MockConsumer:

            producer = AsyncMock()
            consumer = AsyncMock()

            MockProducer.return_value = producer
            MockConsumer.return_value = consumer

            # Mock no response (timeout)
            async def no_response(*args, **kwargs):
                await asyncio.sleep(10)
                return None

            consumer.getone.side_effect = no_response

            client = IntelligenceEventClient(
                bootstrap_servers=test_config["bootstrap_servers"],
                timeout_ms=100,  # Short timeout
            )
            await client.start()

            # Execute request
            with pytest.raises(TimeoutError):
                await client.request_pattern_discovery(
                    source_path="test.py",
                    language="python",
                    operation_type="PATTERN_EXTRACTION",
                    timeout_ms=100,
                )

            await client.stop()

    @pytest.mark.integration
    @pytest.mark.asyncio
    async def test_consumer_group_isolation(self, test_config):
        """Test multiple clients don't interfere with each other."""
        # Create two separate clients
        clients = []
        for i in range(2):
            with patch('agents.lib.intelligence_event_client.AIOKafkaProducer') as MockProducer, \
                 patch('agents.lib.intelligence_event_client.AIOKafkaConsumer') as MockConsumer:

                producer = AsyncMock()
                consumer = AsyncMock()

                MockProducer.return_value = producer
                MockConsumer.return_value = consumer

                # Mock unique responses
                correlation_id = uuid4()
                response = {
                    "correlation_id": str(correlation_id),
                    "event_type": "code_analysis_completed",
                    "payload": {"patterns": [{"client_id": i}]},
                }
                consumer.getone.return_value = MagicMock(
                    value=json.dumps(response).encode('utf-8')
                )

                client = IntelligenceEventClient(
                    bootstrap_servers=test_config["bootstrap_servers"],
                    timeout_ms=5000,
                )
                await client.start()
                clients.append(client)

        # Execute requests concurrently
        tasks = []
        for i, client in enumerate(clients):
            task = client.request_pattern_discovery(
                source_path=f"test_{i}.py",
                language="python",
                operation_type="PATTERN_EXTRACTION",
                timeout_ms=5000,
            )
            tasks.append(task)

        results = await asyncio.gather(*tasks)

        # Verify each client got its own response
        assert len(results) == 2

        # Cleanup
        for client in clients:
            await client.stop()


# ============================================================================
# Additional Edge Cases
# ============================================================================

class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    @pytest.mark.asyncio
    async def test_empty_patterns_response(
        self,
        event_client,
        mock_kafka_consumer,
        sample_correlation_id,
    ):
        """Test handling of empty patterns in response."""
        response = {
            "correlation_id": str(sample_correlation_id),
            "event_type": "code_analysis_completed",
            "payload": {"patterns": []},  # Empty patterns
        }
        mock_kafka_consumer.getone.return_value = MagicMock(
            value=json.dumps(response).encode('utf-8')
        )

        with patch.object(event_client, '_generate_correlation_id', return_value=sample_correlation_id):
            patterns = await event_client.request_pattern_discovery(
                source_path="nonexistent.py",
                language="python",
                operation_type="PATTERN_EXTRACTION",
                timeout_ms=5000,
            )

        # Should return empty list, not raise error
        assert patterns == []

    @pytest.mark.asyncio
    async def test_failed_event_type_handling(
        self,
        event_client,
        mock_kafka_consumer,
        sample_failed_response,
    ):
        """Test handling of failed event responses."""
        mock_kafka_consumer.getone.return_value = MagicMock(
            value=json.dumps(sample_failed_response).encode('utf-8')
        )

        # Execute request
        with pytest.raises(KafkaError) as exc_info:
            await event_client.request_pattern_discovery(
                source_path="test.py",
                language="python",
                operation_type="PATTERN_EXTRACTION",
                timeout_ms=5000,
            )

        # Verify error contains details from failed response
        assert "PATTERN_NOT_FOUND" in str(exc_info.value)
