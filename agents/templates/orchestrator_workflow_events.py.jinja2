{# Orchestrator Workflow Event Publishing Methods #}
{# Adds workflow state tracking and event publishing for orchestrators #}

    async def _publish_workflow_started(
        self, correlation_id: UUID, workflow_context: dict[str, Any]
    ) -> None:
        """
        Publish WORKFLOW_STARTED event when orchestration begins.

        Args:
            correlation_id: Unique workflow identifier
            workflow_context: Initial workflow context and parameters
        """
        if not hasattr(self, 'event_publisher') or self.event_publisher is None:
            self.logger.warning("Event publisher not initialized, skipping workflow event")
            return

        try:
            workflow_event = {
                "event_type": "omninode.orchestration.workflow_started.v1",
                "workflow_id": str(correlation_id),
                "orchestrator_name": "{{ node_name }}",
                "orchestrator_type": "{{ node_type }}",
                "service_name": "{{ service_name }}",
                "workflow_context": workflow_context,
                "timestamp": datetime.utcnow().isoformat(),
                "metadata": {
                    "domain": "{{ domain }}",
                    "version": "{{ version }}",
                    "instance_id": str(self._instance_id) if hasattr(self, '_instance_id') else "unknown",
                },
            }

            self.event_publisher.publish(
                topic="omninode.orchestration.workflow.v1",
                event_type="WORKFLOW_STARTED",
                payload=workflow_event,
                correlation_id=correlation_id,
            )

            self.logger.info(
                f"Published WORKFLOW_STARTED | "
                f"workflow_id={correlation_id} | "
                f"orchestrator={{ node_name }}"
            )

        except Exception as e:
            self.logger.error(f"Failed to publish workflow started event: {e}", exc_info=True)
            # Don't raise - event publishing failure shouldn't block workflow execution

    async def _publish_stage_started(
        self, correlation_id: UUID, stage_name: str, stage_context: dict[str, Any]
    ) -> None:
        """
        Publish STAGE_STARTED event when a workflow stage begins.

        Args:
            correlation_id: Workflow identifier
            stage_name: Name of the stage being started
            stage_context: Stage-specific context and parameters
        """
        if not hasattr(self, 'event_publisher') or self.event_publisher is None:
            return

        try:
            stage_event = {
                "event_type": "omninode.orchestration.stage_started.v1",
                "workflow_id": str(correlation_id),
                "stage_name": stage_name,
                "orchestrator_name": "{{ node_name }}",
                "stage_context": stage_context,
                "timestamp": datetime.utcnow().isoformat(),
            }

            self.event_publisher.publish(
                topic="omninode.orchestration.stage.v1",
                event_type="STAGE_STARTED",
                payload=stage_event,
                correlation_id=correlation_id,
            )

            self.logger.info(
                f"Published STAGE_STARTED | "
                f"workflow_id={correlation_id} | "
                f"stage={stage_name}"
            )

        except Exception as e:
            self.logger.error(f"Failed to publish stage started event: {e}", exc_info=True)

    async def _publish_stage_completed(
        self,
        correlation_id: UUID,
        stage_name: str,
        stage_result: dict[str, Any],
        duration_ms: int = 0,
    ) -> None:
        """
        Publish STAGE_COMPLETED event when a workflow stage finishes.

        Args:
            correlation_id: Workflow identifier
            stage_name: Name of the completed stage
            stage_result: Stage execution results
            duration_ms: Stage execution duration in milliseconds
        """
        if not hasattr(self, 'event_publisher') or self.event_publisher is None:
            return

        try:
            stage_event = {
                "event_type": "omninode.orchestration.stage_completed.v1",
                "workflow_id": str(correlation_id),
                "stage_name": stage_name,
                "orchestrator_name": "{{ node_name }}",
                "stage_result": stage_result,
                "duration_ms": duration_ms,
                "timestamp": datetime.utcnow().isoformat(),
            }

            self.event_publisher.publish(
                topic="omninode.orchestration.stage.v1",
                event_type="STAGE_COMPLETED",
                payload=stage_event,
                correlation_id=correlation_id,
            )

            self.logger.info(
                f"Published STAGE_COMPLETED | "
                f"workflow_id={correlation_id} | "
                f"stage={stage_name} | "
                f"duration={duration_ms}ms"
            )

        except Exception as e:
            self.logger.error(f"Failed to publish stage completed event: {e}", exc_info=True)

    async def _publish_stage_failed(
        self,
        correlation_id: UUID,
        stage_name: str,
        error: str,
        error_type: str = "UnknownError",
        duration_ms: int = 0,
    ) -> None:
        """
        Publish STAGE_FAILED event when a workflow stage encounters an error.

        Args:
            correlation_id: Workflow identifier
            stage_name: Name of the failed stage
            error: Error message or description
            error_type: Type/class of the error
            duration_ms: Stage execution duration before failure
        """
        if not hasattr(self, 'event_publisher') or self.event_publisher is None:
            return

        try:
            stage_event = {
                "event_type": "omninode.orchestration.stage_failed.v1",
                "workflow_id": str(correlation_id),
                "stage_name": stage_name,
                "orchestrator_name": "{{ node_name }}",
                "error": error,
                "error_type": error_type,
                "duration_ms": duration_ms,
                "timestamp": datetime.utcnow().isoformat(),
            }

            self.event_publisher.publish(
                topic="omninode.orchestration.stage.v1",
                event_type="STAGE_FAILED",
                payload=stage_event,
                correlation_id=correlation_id,
            )

            self.logger.error(
                f"Published STAGE_FAILED | "
                f"workflow_id={correlation_id} | "
                f"stage={stage_name} | "
                f"error={error_type}"
            )

        except Exception as e:
            self.logger.error(f"Failed to publish stage failed event: {e}", exc_info=True)

    async def _publish_workflow_completed(
        self,
        correlation_id: UUID,
        workflow_result: dict[str, Any],
        total_duration_ms: int = 0,
        stages_executed: list[str] = None,
    ) -> None:
        """
        Publish WORKFLOW_COMPLETED event when orchestration finishes successfully.

        Args:
            correlation_id: Workflow identifier
            workflow_result: Final workflow execution results
            total_duration_ms: Total workflow execution duration
            stages_executed: List of stages that were executed
        """
        if not hasattr(self, 'event_publisher') or self.event_publisher is None:
            return

        try:
            workflow_event = {
                "event_type": "omninode.orchestration.workflow_completed.v1",
                "workflow_id": str(correlation_id),
                "orchestrator_name": "{{ node_name }}",
                "workflow_result": workflow_result,
                "total_duration_ms": total_duration_ms,
                "stages_executed": stages_executed or [],
                "timestamp": datetime.utcnow().isoformat(),
                "metadata": {
                    "service_name": "{{ service_name }}",
                    "domain": "{{ domain }}",
                    "version": "{{ version }}",
                },
            }

            self.event_publisher.publish(
                topic="omninode.orchestration.workflow.v1",
                event_type="WORKFLOW_COMPLETED",
                payload=workflow_event,
                correlation_id=correlation_id,
            )

            self.logger.info(
                f"Published WORKFLOW_COMPLETED | "
                f"workflow_id={correlation_id} | "
                f"duration={total_duration_ms}ms | "
                f"stages={len(stages_executed or [])}"
            )

        except Exception as e:
            self.logger.error(f"Failed to publish workflow completed event: {e}", exc_info=True)

    async def _publish_workflow_failed(
        self,
        correlation_id: UUID,
        error: str,
        error_type: str = "WorkflowError",
        total_duration_ms: int = 0,
        failed_stage: str = None,
    ) -> None:
        """
        Publish WORKFLOW_FAILED event when orchestration fails.

        Args:
            correlation_id: Workflow identifier
            error: Error message or description
            error_type: Type/class of the error
            total_duration_ms: Total workflow execution duration before failure
            failed_stage: Name of the stage where failure occurred
        """
        if not hasattr(self, 'event_publisher') or self.event_publisher is None:
            return

        try:
            workflow_event = {
                "event_type": "omninode.orchestration.workflow_failed.v1",
                "workflow_id": str(correlation_id),
                "orchestrator_name": "{{ node_name }}",
                "error": error,
                "error_type": error_type,
                "failed_stage": failed_stage,
                "total_duration_ms": total_duration_ms,
                "timestamp": datetime.utcnow().isoformat(),
            }

            self.event_publisher.publish(
                topic="omninode.orchestration.workflow.v1",
                event_type="WORKFLOW_FAILED",
                payload=workflow_event,
                correlation_id=correlation_id,
            )

            self.logger.error(
                f"Published WORKFLOW_FAILED | "
                f"workflow_id={correlation_id} | "
                f"failed_stage={failed_stage} | "
                f"error={error_type}"
            )

        except Exception as e:
            self.logger.error(f"Failed to publish workflow failed event: {e}", exc_info=True)
