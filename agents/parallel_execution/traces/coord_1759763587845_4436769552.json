{
  "trace_id": "coord_1759763587845_4436769552",
  "coordinator_type": "parallel",
  "start_time": 1759763587.8453288,
  "end_time": 1759763595.807752,
  "duration_ms": 7962.423086166382,
  "total_agents": 2,
  "completed_agents": 2,
  "failed_agents": 0,
  "agent_traces": [
    {
      "trace_id": "agent_agent-contract-driven-generator_1759763587847_4436769552",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "start_time": 1759763587.8473148,
      "end_time": null,
      "duration_ms": null,
      "status": "running",
      "events": [
        {
          "timestamp": 1759763587.847326,
          "datetime_str": "2025-10-06T11:13:07.847327",
          "event_type": "AGENT_START",
          "level": "INFO",
          "agent_name": "agent-contract-driven-generator",
          "task_id": "task1",
          "coordinator_id": null,
          "message": "Agent started: agent-contract-driven-generator for task task1",
          "metadata": {
            "domain": "contract_driven_generator",
            "input_data": {
              "contract": {
                "name": "UserAuthentication",
                "description": "Contract for user authentication operations",
                "input_model": {
                  "username": {
                    "type": "str",
                    "description": "User's username"
                  },
                  "password": {
                    "type": "str",
                    "description": "User's password"
                  }
                },
                "output_model": {
                  "success": {
                    "type": "bool",
                    "description": "Authentication success status"
                  },
                  "token": {
                    "type": "str | None",
                    "description": "JWT token if successful"
                  },
                  "error_message": {
                    "type": "str | None",
                    "description": "Error message if failed"
                  }
                }
              },
              "node_type": "Effect",
              "language": "python"
            }
          },
          "duration_ms": null,
          "parent_trace_id": "coord_1759763587845_4436769552"
        }
      ],
      "result": null,
      "error": null
    },
    {
      "trace_id": "agent_agent-contract-driven-generator_1759763587918_4436769552",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "start_time": 1759763587.918942,
      "end_time": 1759763595.793422,
      "duration_ms": 7874.4800090789795,
      "status": "completed",
      "events": [
        {
          "timestamp": 1759763587.918957,
          "datetime_str": "2025-10-06T11:13:07.918958",
          "event_type": "AGENT_START",
          "level": "INFO",
          "agent_name": "agent-contract-driven-generator",
          "task_id": "task2",
          "coordinator_id": null,
          "message": "Agent started: agent-contract-driven-generator for task task2",
          "metadata": {
            "domain": "contract_driven_generator",
            "input_data": {
              "code": "\ndef calculate_total(items):\n    total = 0\n    for item in items:\n        if item[\"active\"]:\n            total += item[\"price\"]\n    return total\n\nclass UserManager:\n    def __init__(self):\n        self.users = []\n\n    def add_user(self, user):\n        self.users.append(user)\n        return True\n\n    def get_user(self, user_id):\n        for user in self.users:\n            if user[\"id\"] == user_id:\n                return user\n        return None\n",
              "file_path": "user_manager.py",
              "language": "python",
              "error": "AttributeError: 'NoneType' object has no attribute 'id'"
            }
          },
          "duration_ms": null,
          "parent_trace_id": "coord_1759763587845_4436769552"
        },
        {
          "timestamp": 1759763595.737779,
          "datetime_str": "2025-10-06T11:13:15.737780",
          "event_type": "AGENT_END",
          "level": "INFO",
          "agent_name": "agent-contract-driven-generator",
          "task_id": "task2",
          "coordinator_id": null,
          "message": "Agent completed: agent-contract-driven-generator (7818.80ms)",
          "metadata": {
            "result": {
              "task_id": "task2",
              "agent_name": "agent-contract-driven-generator",
              "success": true,
              "output_data": {
                "generated_code": "\"\"\"\nUnknownContract - ONEX Compute Node\n\n\n\"\"\"\n\nfrom typing import Any, Dict\nfrom pydantic import BaseModel, Field\n\n\nclass UnknownContractInput(BaseModel):\n    \"\"\"Input model for UnknownContract.\"\"\"\n    pass\n\n\nclass UnknownContractOutput(BaseModel):\n    \"\"\"Output model for UnknownContract.\"\"\"\n    pass\n\n\nclass NodeUnknownContractCompute:\n    \"\"\"\n    ONEX Compute node for UnknownContract.\n    \n    \n    \"\"\"\n\n    async def execute(self, input_data: UnknownContractInput) -> UnknownContractOutput:\n        \"\"\"\n        Execute compute operation.\n        \n        Args:\n            input_data: Validated input model\n        \n        Returns:\n            Validated output model\n        \"\"\"\n        # TODO: Implement compute logic\n        # Intelligence gathered: 2 sources\n        \n        # Placeholder implementation\n        return UnknownContractOutput()",
                "node_type": "Compute",
                "contract": {},
                "intelligence_gathered": {
                  "domain_patterns": {
                    "success": true,
                    "query": "contract-driven development patterns",
                    "context": "api_development",
                    "timestamp": "2025-10-06T15:13:08.015386",
                    "duration_ms": 2874,
                    "sources_queried": [
                      "RAG/Enhanced Search",
                      "Qdrant Vector DB",
                      "Memgraph Knowledge Graph"
                    ],
                    "sources_successful": [
                      "RAG",
                      "Vector Search",
                      "Knowledge Graph"
                    ],
                    "total_results": 5,
                    "results": {
                      "rag_search": {
                        "success": true,
                        "source": "rag_search",
                        "results": [],
                        "query": "contract-driven development patterns",
                        "reranked": false
                      },
                      "vector_search": {
                        "success": true,
                        "source": "qdrant_vector_search",
                        "results": [
                          {
                            "entity_id": "b8b1a5f4-c6bf-49e0-9a51-3b5c107ca917",
                            "entity_type": "page",
                            "title": "Two-Way Registration Pattern - Event-Driven Service Discovery",
                            "content": "Two-Way Registration Pattern - Event-Driven Service Discovery\n\nThe Two-Way Registration Pattern is an event-driven service discovery architecture that enables dynamic node registration and resilient service coordination across the ONEX ecosystem",
                            "url": null,
                            "relevance_score": 0.4368675,
                            "semantic_score": 0.4368675,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": "2025-10-03T12:34:16.872145",
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "b8b1a5f4-c6bf-49e0-9a51-3b5c107ca917",
                            "entity_type": "page",
                            "title": "Two-Way Registration Pattern - Event-Driven Service Discovery",
                            "content": "Two-Way Registration Pattern - Event-Driven Service Discovery\n\nThe Two-Way Registration Pattern is an event-driven service discovery architecture that enables dynamic node registration and resilient service coordination across the ONEX ecosystem",
                            "url": null,
                            "relevance_score": 0.4368675,
                            "semantic_score": 0.4368675,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": "2025-10-03T12:34:17.898506",
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_457990293851",
                            "entity_type": "page",
                            "title": "Composed Node Base Classes",
                            "content": "Composed Node Base Classes\n\n# ONEX Composed Node Base Classes - Design Specification\n\n**Version**: 1.0.0\n**Status**: \ud83d\udea7 Proposed Design\n**Last Updated**: 2025-10-01\n**Related**: NODE_GROUP_STRUCTURE.md, SHARED_RESOURCE_VERSIONING.md\n\n---\n\n## Problem Statement\n\nCurrently, **each node manually composes the subcontracts it needs**, leading to:\n- \u274c Boilerplate repetition across similar nodes\n- \u274c Inconsistent subcontract usage patterns\n- \u274c Difficult to enforce best practices\n- \u274c No clear templates for new nodes\n\n**Current State** (ModelContractEffect):\n```python\nclass ModelContractEffect(ModelContractBase):\n    # Only 3 subcontracts out of 14 available!\n    event_type: ModelEventTypeSubcontract | None = None\n    caching: ModelCachingSubcontract | None = None\n    routing: ModelRoutingSubcontract | None = None\n```\n\n**Missing Subcontracts** not in base contracts:\n1. ModelConfigurationSubcontract\n2. ModelWorkflowCoordinationSubcontract\n3. ModelServiceResolutionSubcontract \u2b50\n4. ModelExternalDependenciesSubcontract\n5. ModelHealthCheckSubcontract\n6. ModelIntrospectionSubcontract\n7. ModelPerformanceMonitoringSubcontract\n8. ModelRequestResponseSubcontract\n9. ModelAggregationSubcontract (Reducer only?)\n10. ModelFSMSubcontract (in base, but not mentioned)\n11. ModelStateManagementSubcontract (in base, but not mentioned)\n\n---\n\n## Solution: Composed Base Classes\n\nCreate **pre-composed base contract classes** that aggregate common subcontract patterns for typical use cases.\n\n### Design Principles\n\n1. **Layered Composition**: Multiple levels of composition for flexibility\n2. **Progressive Enhancement**: Start minimal, add features as needed\n3. **Clear Naming**: Names indicate included subcontracts\n4. **Backward Compatible**: Existing contracts still work\n5. **Zero Duplication**: DRY principle for subcontract aggregation\n\n---\n\n## Proposed Hierarchy\n\n```\nModelContractBase (foundation)\n    \u2193\nModelContract{Type} (current: minimal)\n    \u2193\nModelContract{Type}Standard (common patterns)\n    \u2193\nModelContract{Type}Full (all applicable subcontracts)\n```\n\n---\n\n## Composed Base Classes Design\n\n### 1. Effect Node Compositions\n\n#### ModelContractEffectStandard\n**Common patterns for typical Effect nodes**\n\n```python\nclass ModelContractEffectStandard(ModelContractEffect):\n    \"\"\"\n    Standard Effect node with common operational patterns.\n\n    Includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n\n    Use for: Most production Effect nodes\n    \"\"\"\n\n    # === OPERATIONAL SUBCONTRACTS ===\n    service_resolution: ModelServiceResolutionSubcontract = Field(\n        default_factory=ModelServiceResolutionSubcontract,\n        description=\"Service discovery and dependency injection\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Health monitoring and readiness checks\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Performance metrics and monitoring\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Configuration management\",\n    )\n\n    request_response: ModelRequestResponseSubcontract = Field(\n        default_factory=ModelRequestResponseSubcontract,\n        description=\"Request/response pattern support\",\n    )\n\n    # Inherit from parent: event_type, caching, routing\n```\n\n#### ModelContractEffectFull\n**All applicable Effect subcontracts**\n\n```python\nclass ModelContractEffectFull(ModelContractEffectStandard):\n    \"\"\"\n    Full-featured Effect node with all operational capabilities.\n\n    Adds to Standard:\n    - External dependencies tracking\n    - Runtime introspection\n    - Advanced state management\n    - FSM patterns\n\n    Use for: Complex infrastructure nodes, critical services\n    \"\"\"\n\n    # === ADVANCED SUBCONTRACTS ===\n    external_dependencies: ModelExternalDependenciesSubcontract = Field(\n        default_factory=ModelExternalDependenciesSubcontract,\n        description=\"External dependency management\",\n    )\n\n    introspection: ModelIntrospectionSubcontract = Field(\n        default_factory=ModelIntrospectionSubcontract,\n        description=\"Runtime introspection capabilities\",\n    )\n\n    state_management: ModelStateManagementSubcontract | None = Field(\n        default=None,\n        description=\"Advanced state management (optional)\",\n    )\n\n    fsm: ModelFSMSubcontract | None = Field(\n        default=None,\n        description=\"Finite state machine patterns (optional)\",\n    )\n```\n\n---\n\n### 2. Compute Node Compositions\n\n#### ModelContractComputeStandard\n**Common patterns for typical Compute nodes**\n\n```python\nclass ModelContractComputeStandard(ModelContractCompute):\n    \"\"\"\n    Standard Compute node with performance optimization patterns.\n\n    Includes:\n    - Caching (critical for pure functions)\n    - Performance monitoring\n    - Configuration management\n    - Health checks\n\n    Use for: Most Compute nodes with caching needs\n    \"\"\"\n\n    # === PERFORMANCE SUBCONTRACTS ===\n    caching: ModelCachingSubcontract = Field(\n        default_factory=ModelCachingSubcontract,\n        description=\"Result caching for pure computations\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Computation performance tracking\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Algorithm configuration\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Computation health monitoring\",\n    )\n```\n\n#### ModelContractComputeFull\n**All applicable Compute subcontracts**\n\n```python\nclass ModelContractComputeFull(ModelContractComputeStandard):\n    \"\"\"\n    Full-featured Compute node for complex computations.\n\n    Adds to Standard:\n    - Service resolution (for external data sources)\n    - Request/response patterns\n    - Introspection capabilities\n\n    Use for: Complex algorithmic nodes, ML inference nodes\n    \"\"\"\n\n    service_resolution: ModelServiceResolutionSubcontract | None = Field(\n        default=None,\n        description=\"External data source resolution (optional)\",\n    )\n\n    request_response: ModelRequestResponseSubcontractt | None = Field(\n        default=None,\n        description=\"Request/response patterns (optional)\",\n    )\n\n    introspection: ModelIntrospectionSubcontract | None = Field(\n        default=None,\n        description=\"Runtime introspection (optional)\",\n    )\n```\n\n---\n\n### 3. Reducer Node Compositions\n\n#### ModelContractReducerStandard\n**Common patterns for typical Reducer nodes**\n\n```python\nclass ModelContractReducerStandard(ModelContractReducer):\n    \"\"\"\n    Standard Reducer node with aggregation patterns.\n\n    Includes:\n    - Aggregation (core reducer functionality)\n    - State management\n    - Caching\n    - Performance monitoring\n\n    Use for: Most Reducer nodes\n    \"\"\"\n\n    # === AGGREGATION SUBCONTRACTS ===\n    aggregation: ModelAggregationSubcontract = Field(\n        default_factory=ModelAggregationSubcontract,\n        description=\"Data aggregation strategies\",\n    )\n\n    state_management: ModelStateManagementSubcontract = Field(\n        default_factory=ModelStateManagementSubcontract,\n        description=\"Aggregation state management\",\n    )\n\n    caching: ModelCachingSubcontract = Field(\n        default_factory=ModelCachingSubcontract,\n        description=\"Aggregation result caching\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Aggregation performance tracking\",\n    )\n```\n\n---\n\n### 4. Orchestrator Node Compositions\n\n#### ModelContractOrchestratorStandard\n**Common patterns for typical Orchestrator nodes**\n\n```python\nclass ModelContractOrchestratorStandard(ModelContractOrchestrator):\n    \"\"\"\n    Standard Orchestrator node with workflow coordination.\n\n    Includes:\n    - Workflow coordination (core orchestrator functionality)\n    - Routing\n    - Service resolution\n    - Health monitoring\n    - Event coordination\n\n    Use for: Most Orchestrator nodes\n    \"\"\"\n\n    # === ORCHESTRATION SUBCONTRACTS ===\n    workflow_coordination: ModelWorkflowCoordinationSubcontract = Field(\n        default_factory=ModelWorkflowCoordinationSubcontract,\n        description=\"Multi-node workflow coordination\",\n    )\n\n    routing: ModelRoutingSubcontract = Field(\n        default_factory=ModelRoutingSubcontract,\n        description=\"Node routing and load balancing\",\n    )\n\n    service_resolution: ModelServiceResolutionSubcontract = Field(\n        default_factory=ModelServiceResolutionSubcontract,\n        description=\"Node and service discovery\",\n    )\n\n    event_type: ModelEventTypeSubcontract = Field(\n        default_factory=ModelEventTypeSubcontract,\n        description=\"Event-driven orchestration\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Orchestration health monitoring\",\n    )\n```\n\n#### ModelContractOrchestratorFull\n**All applicable Orchestrator subcontracts**\n\n```python\nclass ModelContractOrchestratorFull(ModelContractOrchestratorStandard):\n    \"\"\"\n    Full-featured Orchestrator with advanced capabilities.\n\n    Adds to Standard:\n    - FSM patterns for complex workflows\n    - State management\n    - Performance monitoring\n    - Configuration management\n\n    Use for: Complex multi-stage workflows, critical orchestration\n    \"\"\"\n\n    fsm: ModelFSMSubcontract = Field(\n        default_factory=ModelFSMSubcontract,\n        description=\"State machine-based workflow control\",\n    )\n\n    state_management: ModelStateManagementSubcontract = Field(\n        default_factory=ModelStateManagementSubcontract,\n        description=\"Workflow state management\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Orchestration performance tracking\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Workflow configuration management\",\n    )\n```\n\n---\n\n## Subcontract-to-Node Type Matrix\n\n| Subcontract | Effect | Compute | Reducer | Orchestrator | Notes |\n|------------|--------|---------|---------|--------------|-------|\n| **ServiceResolution** | \u2705 Standard | Optional | Optional | \u2705 Standard | DI pattern |\n| **HealthCheck** | \u2705 Standard | \u2705 Standard | \u2705 Standard | \u2705 Standard | Universal |\n| **PerformanceMonitoring** | \u2705 Standard | \u2705 Standard | \u2705 Standard | Optional | Universal |\n| **Configuration** | \u2705 Standard | \u2705 Standard | Optional | Optional | Common |\n| **RequestResponse** | \u2705 Standard | Optional | \u274c | \u274c | Effect/Compute only |\n| **Caching** | Optional | \u2705 Standard | \u2705 Standard | \u274c | Performance |\n| **EventType** | Optional | \u274c | \u274c | \u2705 Standard | Event-driven |\n| **Routing** | Optional | \u274c | \u274c | \u2705 Standard | Orchestration |\n| **WorkflowCoordination** | \u274c | \u274c | \u274c | \u2705 Standard | Orchestrator only |\n| **Aggregation** | \u274c | \u274c | \u2705 Standard | \u274c | Reducer only |\n| **StateManagement** | Optional | \u274c | \u2705 Standard | Optional | Stateful nodes |\n| **FSM** | Optional | \u274c | \u274c | Optional | Complex workflows |\n| **ExternalDependencies** | Optional | Optional | \u274c | \u274c | Integration nodes |\n| **Introspection** | Optional | Optional | \u274c | \u274c | Debugging/monitoring |\n\n**Legend**:\n- \u2705 Standard: Included in `{Type}Standard` composition\n- Optional: Available in `{Type}Full` or can be added manually\n- \u274c: Not applicable to this node type\n\n---\n\n## Usage Examples\n\n### Example 1: Simple Effect Node (Minimal)\n\n```python\n# Use base contract - minimal subcontracts\nfrom omnibase_core.models.contracts import ModelContractEffect\n\nclass ToolSimpleFileWriter(NodeEffect):\n    \"\"\"Minimal Effect node - just the essentials.\"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffect with basic I/O only\n```\n\n### Example 2: Production Effect Node (Standard)\n\n```python\n# Use Standard composition - common operational patterns\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass ToolProductionAPIClient(NodeEffect):\n    \"\"\"\n    Production Effect node with standard operational patterns.\n\n    Automatically includes:\n    - Service resolution\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffectStandard\n        # All standard subcontracts available automatically\n```\n\n### Example 3: Complex Infrastructure Node (Full)\n\n```python\n# Use Full composition - all capabilities\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n\nclass ToolDatabaseConnector(NodeEffect):\n    \"\"\"\n    Complex infrastructure node with all operational capabilities.\n\n    Includes all Standard features PLUS:\n    - External dependencies tracking\n    - Runtime introspection\n    - State management\n    - FSM patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffectFull\n        # Maximum operational capabilities\n```\n\n### Example 4: Custom Composition\n\n```python\n# Start with Standard, customize as needed\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\nfrom omnibase_core.models.contracts.subcontracts import ModelFSMSubcontract\n\nclass ToolCustomProcessor(NodeEffect):\n    \"\"\"Custom composition: Standard + FSM, no caching.\"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract in YAML can specify custom subcontracts\n        # Inherits Standard patterns, adds FSM, removes caching\n```\n\n---\n\n## Contract YAML Examples\n\n### Minimal Effect (base)\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"effect\"\n# Uses: ModelContractEffect\n# Subcontracts: event_type, caching, routing (all optional)\n\nio_operations:\n  - operation_type: \"file_write\"\n    path: \"/data/output.json\"\n```\n\n### Standard Effect\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"effect\"\ncomposed_type: \"standard\"  # \ud83c\udd95 Triggers ModelContractEffectStandard\n# Automatically includes: service_resolution, health_check,\n# performance_monitoring, configuration, request_response\n\nio_operations:\n  - operation_type: \"api_call\"\n    endpoint: \"${SERVICE_URL}/api/data\"\n\nservice_resolution:\n  service_name: \"data_api\"\n  discovery_method: \"dns\"\n\nhealth_check:\n  endpoint: \"/health\"\n  interval_seconds: 30\n\nperformance_monitoring:\n  enable_metrics: true\n  sample_rate: 1.0\n```\n\n### Full Orchestrator\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"orchestrator\"\ncomposed_type: \"full\"  # \ud83c\udd95 Triggers ModelContractOrchestratorFull\n# All orchestration capabilities enabled\n\nworkflow_coordination:\n  max_concurrent_workflows: 100\n  execution_timeout_seconds: 300\n\nrouting:\n  strategy: \"round_robin\"\n  load_balancing: true\n\nfsm:\n  initial_state: \"pending\"\n  states:\n    - name: \"pending\"\n      transitions: [\"processing\"]\n    - name: \"processing\"\n      transitions: [\"completed\", \"failed\"]\n```\n\n---\n\n## Migration Strategy\n\n### Phase 1: Create Composed Base Classes (omnibase_core)\n1. \u2705 Audit all 14 subcontracts\n2. \ud83c\udd95 Create `model_contract_{type}_standard.py` for each node type\n3. \ud83c\udd95 Create `model_contract_{type}_full.py` for each node type\n4. \u2705 Update `__init__.py` exports\n\n### Phase 2: Update Documentation\n1. \ud83c\udd95 Update NODE_GROUP_STRUCTURE.md with composed classes\n2. \ud83c\udd95 Create this document (COMPOSED_NODE_BASE_CLASSES.md)\n3. \ud83c\udd95 Update ONEX examples to show all three levels\n4. \ud83c\udd95 Create migration guide for existing nodes\n\n### Phase 3: Gradual Adoption\n1. \u2705 Keep existing base contracts (backward compatible)\n2. \ud83c\udd95 New nodes use `Standard` by default\n3. \ud83c\udd95 Complex nodes use `Full` when needed\n4. \u23f8\ufe0f Migrate existing nodes gradually (optional)\n\n### Phase 4: Tooling Support\n1. \ud83c\udd95 CLI: `onex create node --template standard|full|minimal`\n2. \ud83c\udd95 Validator: Check subcontract usage against patterns\n3. \ud83c\udd95 Generator: Auto-generate composed contracts from specs\n\n---\n\n## Benefits\n\n### \u2705 Developer Experience\n- **Faster Development**: Pre-composed patterns reduce boilerplate\n- **Best Practices**: Standard patterns enforce good architecture\n- **Clear Templates**: Three levels (minimal/standard/full) guide choices\n- **Gradual Complexity**: Start minimal, add features as needed\n\n### \u2705 Consistency\n- **Uniform Patterns**: Same operational patterns across similar nodes\n- **Predictable Behavior**: Standard nodes behave consistently\n- **Easier Onboarding**: Clear examples of typical compositions\n\n### \u2705 Maintainability\n- **DRY Principle**: Subcontract aggregation in one place\n- **Centralized Updates**: Update composed class, all nodes benefit\n- **Clear Dependencies**: Explicit subcontract requirements\n\n### \u2705 Flexibility\n- **Progressive Enhancement**: Start small, grow as needed\n- **Custom Compositions**: Can still compose manually\n- **Backward Compatible**: Existing nodes unchanged\n\n---\n\n## Implementation Checklist\n\n### omnibase_core Updates\n- [ ] Create `model_contract_effect_standard.py`\n- [ ] Create `model_contract_effect_full.py`\n- [ ] Create `model_contract_compute_standard.py`\n- [ ] Create `model_contract_compute_full.py`\n- [ ] Create `model_contract_reducer_standard.py`\n- [ ] Create `model_contract_orchestrator_standard.py`\n- [ ] Create `model_contract_orchestrator_full.py`\n- [ ] Update `__init__.py` exports\n- [ ] Add validation for `composed_type` field\n- [ ] Unit tests for all composed classes\n\n### Documentation Updates\n- [ ] Update NODE_GROUP_STRUCTURE.md\n- [ ] Create examples for all 14 subcontracts\n- [ ] Update ONEX examples (docs/onex/examples/)\n- [ ] Create migration guide\n- [ ] Update CLAUDE.md\n\n### Tooling\n- [ ] CLI: Node creation with templates\n- [ ] Validator: Pattern compliance checking\n- [ ] Generator: Auto-generate from specs\n\n---\n\n## References\n\n- **Node Structure**: NODE_GROUP_STRUCTURE.md\n- **Subcontracts**: omnibase_core/models/contracts/subcontracts/\n- **Base Contracts**: omnibase_core/models/contracts/model_contract_*.py\n- **Versioning**: SHARED_RESOURCE_VERSIONING.md\n\n---\n\n**Status**: \ud83d\udea7 Proposed Design - Ready for Review\n**Version**: 1.0.0\n**Last Updated**: 2025-10-01\n**Next Steps**: Review \u2192 Implement in omnibase_core \u2192 Update documentation",
                            "url": null,
                            "relevance_score": 0.41716355,
                            "semantic_score": 0.41716355,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_111439200485",
                            "entity_type": "page",
                            "title": "Onex Architecture Patterns Complete",
                            "content": "Onex Architecture Patterns Complete\n\n# ONEX Architecture Patterns - Complete Reference\n\n**Version**: 1.0.0\n**Generated**: 2025-10-01\n**Purpose**: Comprehensive ONEX patterns for AI-assisted development with hooks integration\n\n---\n\n## Core Architecture\n\n### 4-Node Architecture Pattern\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   EFFECT    \u2502\u2500\u2500\u2500\u25b6\u2502   COMPUTE   \u2502\u2500\u2500\u2500\u25b6\u2502   REDUCER   \u2502\u2500\u2500\u2500\u25b6\u2502ORCHESTRATOR \u2502\n\u2502   (Input)   \u2502    \u2502 (Process)   \u2502    \u2502(Aggregate)  \u2502    \u2502(Coordinate) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Unidirectional Data Flow**: EFFECT \u2192 COMPUTE \u2192 REDUCER \u2192 ORCHESTRATOR\n\n---\n\n## 1. Node Types\n\n### NodeEffect\n**Purpose**: Side effect management and external interactions\n**File Pattern**: `node_*_effect.py`\n**Contract**: `ModelContractEffect`\n\n**Responsibilities**:\n- I/O operations (file, database, API)\n- Transaction management with rollback\n- Retry policies and circuit breakers\n- Event emission\n- Metrics collection\n\n**Method Signature**:\n```python\nasync def execute_effect(self, contract: ModelContractEffect) -> Any:\n    \"\"\"Execute side effect with transaction support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Database writes\n- File operations\n- API calls\n- Event publishing\n\n---\n\n### NodeCompute\n**Purpose**: Pure computational operations\n**File Pattern**: `node_*_compute.py`\n**Contract**: `ModelContractCompute`\n\n**Responsibilities**:\n- Data transformations\n- Calculations and computations\n- Caching and memoization\n- Parallel processing\n- Pure functions (no side effects)\n\n**Method Signature**:\n```python\nasync def execute_compute(self, contract: ModelContractCompute) -> Any:\n    \"\"\"Execute computation with caching support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Data transformations\n- Calculations\n- Filtering/mapping\n- Validation logic\n\n---\n\n### NodeReducer\n**Purpose**: Data aggregation and state reduction\n**File Pattern**: `node_*_reducer.py`\n**Contract**: `ModelContractReducer`\n\n**Responsibilities**:\n- Data aggregation\n- State reduction\n- Conflict resolution\n- Streaming support\n- Statistical operations\n\n**Method Signature**:\n```python\nasync def execute_reduction(self, contract: ModelContractReducer) -> Any:\n    \"\"\"Execute reduction with streaming support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Data aggregation\n- Statistics calculation\n- State merging\n- Report generation\n\n---\n\n### NodeOrchestrator\n**Purpose**: Workflow coordination\n**File Pattern**: `node_*_orchestrator.py`\n**Contract**: `ModelContractOrchestrator`\n\n**Responsibilities**:\n- Workflow coordination\n- Thunk emission\n- Dependency management\n- Pipeline orchestration\n- Error recovery\n\n**Method Signature**:\n```python\nasync def execute_orchestration(self, contract: ModelContractOrchestrator) -> Any:\n    \"\"\"Execute orchestration with dependency management.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Multi-step workflows\n- Pipeline coordination\n- Dependency resolution\n- Error recovery flows\n\n---\n\n## 2. Contract System\n\n### Base Contract\n**Class**: `ModelContractBase`\n**File Pattern**: `model_contract_base.py`\n\n**Core Fields**:\n- `name: str` - Contract identifier\n- `version: str` - Semantic version\n- `description: str` - Human-readable description\n- `node_type: EnumNodeType` - Node type (EFFECT/COMPUTE/REDUCER/ORCHESTRATOR)\n\n### Specialized Contracts\n\n1. **ModelContractEffect** - For EFFECT nodes\n2. **ModelContractCompute** - For COMPUTE nodes\n3. **ModelContractReducer** - For REDUCER nodes\n4. **ModelContractOrchestrator** - For ORCHESTRATOR nodes\n\n---\n\n## 3. Subcontract System\n\n**Pattern**: `Model<Type>Subcontract`\n**File Pattern**: `model_*_subcontract.py`\n\n### 6 Core Subcontract Types\n\n1. **ModelFSMSubcontract** - Finite State Machine functionality\n   - State transitions\n   - Event-driven state changes\n   - Guards and actions\n\n2. **ModelEventTypeSubcontract** - Event-driven architecture\n   - Event definitions\n   - Event handlers\n   - Pub/sub patterns\n\n3. **ModelAggregationSubcontract** - Data aggregation\n   - Aggregation strategies\n   - Statistical operations\n   - Group by operations\n\n4. **ModelStateManagementSubcontract** - State persistence\n   - State storage\n   - State synchronization\n   - State recovery\n\n5. **ModelRoutingSubcontract** - Request routing\n   - Load balancing\n   - Request routing\n   - Endpoint selection\n\n6. **ModelCachingSubcontract** - Performance optimization\n   - Cache strategies\n   - TTL management\n   - Cache invalidation\n\n---\n\n## 4. Naming Conventions\n\n### File Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Models | `model_<name>.py` | `model_task_data.py` |\n| Enums | `enum_<name>.py` | `enum_task_status.py` |\n| TypedDicts | `typed_dict_<name>.py` | `typed_dict_result_kwargs.py` |\n| Nodes | `node_<type>_<name>.py` | `node_effect_database.py` |\n| Contracts | `model_contract_<type>.py` | `model_contract_effect.py` |\n| Subcontracts | `model_<type>_subcontract.py` | `model_fsm_subcontract.py` |\n| Protocols | `protocol_<name>.py` | `protocol_event_bus.py` |\n\n### Class Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Pydantic Models | `Model<Name>` | `ModelTaskData` |\n| Enums | `Enum<Name>` | `EnumTaskStatus` |\n| TypedDicts | `TypedDict<Name>` | `TypedDictResultKwargs` |\n| Protocols | `Protocol<Name>` | `ProtocolEventBus` |\n| Nodes | `Node<Name><Type>` | `NodeDatabaseWriterEffect` |\n\n---\n\n## 5. Architecture Principles\n\n### Zero Tolerance for Any Types\n```python\n# \u2705 Correct - Strongly typed\ndef process_data(data: ModelTaskData) -> ModelResult:\n    pass\n\n# \u274c Incorrect - Using Any\ndef process_data(data: Any) -> Any:\n    pass\n```\n\n### Contract-Driven Development\n```python\n# \u2705 Correct - Contract defines behavior\nclass NodeDatabaseWriterEffect:\n    async def execute_effect(self, contract: ModelContractEffect) -> ModelResult:\n        # Implementation follows contract spec\n        pass\n```\n\n### Composition Over Inheritance\n```python\n# \u2705 Correct - Subcontract composition\ncontract = ModelContractEffect(\n    name=\"database_write\",\n    state_transitions=ModelFSMSubcontract(...),  # Compose FSM\n    caching=ModelCachingSubcontract(...)  # Compose caching\n)\n```\n\n### Unidirectional Data Flow\n```python\n# \u2705 Correct - Left to right flow\neffect_result = await effect_node.execute_effect(effect_contract)\ncompute_result = await compute_node.execute_compute(compute_contract)\nreducer_result = await reducer_node.execute_reduction(reducer_contract)\nfinal_result = await orchestrator.execute_orchestration(orch_contract)\n```\n\n---\n\n## 6. Quick Reference Templates\n\n### Creating an Effect Node\n```python\nfrom omnibase.core.models.contracts import ModelContractEffect\nfrom omnibase.core.nodes import NodeEffect\n\nclass NodeMyOperationEffect(NodeEffect):\n    \"\"\"My custom effect node.\"\"\"\n\n    async def execute_effect(self, contract: ModelContractEffect) -> ModelResult:\n        # Transaction management\n        async with self.transaction_manager.begin():\n            # Your side effect logic here\n            result = await self._perform_operation(contract)\n            return ModelResult(success=True, data=result)\n```\n\n### Creating a Compute Node\n```python\nfrom omnibase.core.models.contracts import ModelContractCompute\nfrom omnibase.core.nodes import NodeCompute\n\nclass NodeMyTransformCompute(NodeCompute):\n    \"\"\"My custom compute node.\"\"\"\n\n    async def execute_compute(self, contract: ModelContractCompute) -> ModelResult:\n        # Pure computation with caching\n        cached = self.cache.get(contract.cache_key)\n        if cached:\n            return cached\n\n        result = self._transform_data(contract.input_data)\n        self.cache.set(contract.cache_key, result)\n        return ModelResult(success=True, data=result)\n```\n\n### Contract YAML Template\n```yaml\nname: my_operation\nversion: 1.0.0\ndescription: \"My operation description\"\nnode_type: EFFECT  # or COMPUTE, REDUCER, ORCHESTRATOR\n\n# Optional subcontracts\nstate_transitions:\n  initial_state: PENDING\n  transitions:\n    - from: PENDING\n      to: PROCESSING\n      event: START\n    - from: PROCESSING\n      to: COMPLETED\n      event: FINISH\n\ncaching:\n  strategy: LRU\n  ttl_seconds: 3600\n  max_entries: 1000\n```\n\n---\n\n## 7. Best Practices\n\n### DO \u2705\n- Use unidirectional data flow (EFFECT \u2192 COMPUTE \u2192 REDUCER \u2192 ORCHESTRATOR)\n- Apply contract-driven development\n- Compose subcontracts for reusable functionality\n- Use strong typing (zero `Any` types)\n- Follow naming conventions consistently\n- Implement proper error handling and logging\n- Use UUID correlation IDs for tracing\n\n### DON'T \u274c\n- Skip contract validation\n- Use `Any` types in models\n- Create side effects in compute nodes\n- Break unidirectional flow\n- Mix responsibilities across node types\n- Hardcode configuration (use contracts)\n- Ignore transaction management in effects\n\n---\n\n## 8. Integration Checklist\n\nWhen creating new nodes:\n\n- [ ] Choose correct node type (Effect/Compute/Reducer/Orchestrator)\n- [ ] Follow file naming convention (`node_<type>_<name>.py`)\n- [ ] Follow class naming convention (`Node<Type><Name>`)\n- [ ] Create contract YAML with all required fields\n- [ ] Implement correct method signature (`execute_effect/compute/reduction/orchestration`)\n- [ ] Use appropriate subcontracts (FSM, caching, etc.)\n- [ ] Add proper error handling and logging\n- [ ] Include UUID correlation tracking\n- [ ] Write comprehensive tests\n- [ ] Document in contract YAML\n\n---\n\n**References**:\n- omnibase_core: Node implementations\n- omnibase_3: Contract and subcontract models\n- omnibase_infra: Production examples (PostgreSQL, Kafka adapters)",
                            "url": null,
                            "relevance_score": 0.4168243,
                            "semantic_score": 0.4168243,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_718927590691",
                            "entity_type": "page",
                            "title": "ONEX Implementation Guide",
                            "content": "ONEX Implementation Guide\n\n# ONEX Implementation Guide\n\n**Version**: 2.0.0\n**Status**: \u2705 Canonical Reference\n**Last Updated**: 2025-10-01\n**Purpose**: Comprehensive guide for implementing ONEX nodes and node groups\n\n---\n\n## \ud83d\udcd6 What to Read First\n\n**New to ONEX?** Start here:\n1. Read this guide's [Quick Start](#quick-start) section\n2. Review [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md) for patterns and examples\n3. Explore [examples/](examples/) directory for real implementations\n\n**Looking for specific info?**\n- **Directory structure** \u2192 [Structure Guide](#directory-structure)\n- **Base classes** \u2192 [Composed Base Classes](#composed-base-classes)\n- **Naming patterns** \u2192 [Naming Conventions](#naming-conventions)\n- **Shared resources** \u2192 [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md)\n- **Quick patterns** \u2192 [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md)\n\n---\n\n## \ud83d\ude80 Quick Start\n\n### 3-Tier Base Class System\n\nONEX provides **three levels** of base contracts for progressive enhancement:\n\n```python\n# Level 1: MINIMAL (advanced use cases)\nfrom omnibase_core.models.contracts import ModelContractEffect\n\n# Level 2: STANDARD (recommended for most nodes) \u2b50\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\n# Level 3: FULL (complex infrastructure nodes)\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n```\n\n**Use Standard for 90% of nodes** - includes common operational patterns like service resolution, health monitoring, performance tracking, and configuration management.\n\n### Creating Your First Node\n\n```python\n#!/usr/bin/env python3\n\"\"\"My Effect Node - Production-ready with standard patterns.\"\"\"\n\nfrom pathlib import Path\nfrom omnibase.constants.contract_constants import CONTRACT_FILENAME\nfrom omnibase.core.node_base import NodeBase\nfrom omnibase.core.node_effect import NodeEffect\nfrom omnibase_core.models.core import ModelOnexContainer\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nfrom .models.model_input_state import ModelMyNodeInputState\nfrom .models.model_output_state import ModelMyNodeOutputState\n\n\nclass ToolMyNodeProcessor(NodeEffect):\n    \"\"\"\n    My production Effect node using Standard composition.\n\n    Automatically includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Your initialization here\n\n    async def execute_effect(\n        self, contract: ModelContractEffectStandard\n    ) -> ModelMyNodeOutputState:\n        \"\"\"Main processing method.\"\"\"\n        # Your business logic here\n        pass\n\n\ndef main():\n    \"\"\"One-line main function.\"\"\"\n    return NodeBase(Path(__file__).parent / CONTRACT_FILENAME)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n## \ud83d\udcc1 Directory Structure\n\n### Minimum Viable Structure\n\n**Use this** for new nodes (production-ready):\n\n```\n<node_group>/                           # e.g., \"canary\"\n\u251c\u2500\u2500 __init__.py                         # Group package\n\u251c\u2500\u2500 README.md                           # Main documentation\n\u2502\n\u251c\u2500\u2500 deployment/                         # Deployment configs\n\u2502   \u251c\u2500\u2500 docker-compose.<group>.yml\n\u2502   \u2514\u2500\u2500 *.env files\n\u2502\n\u2514\u2500\u2500 <node_name>/                        # e.g., \"my_tool\"\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 v1_0_0/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 node.py                     # ONLY node class + main()\n        \u2502\n        \u251c\u2500\u2500 contract.yaml               # Main interface\n        \u251c\u2500\u2500 node_config.yaml            # Runtime config\n        \u251c\u2500\u2500 deployment_config.yaml      # Deployment config\n        \u2502\n        \u251c\u2500\u2500 contracts/                  # YAML subcontracts\n        \u2502   \u251c\u2500\u2500 contract_actions.yaml\n        \u2502   \u251c\u2500\u2500 contract_cli.yaml\n        \u2502   \u251c\u2500\u2500 contract_examples.yaml\n        \u2502   \u2514\u2500\u2500 contract_models.yaml\n        \u2502\n        \u2514\u2500\u2500 models/                     # Node-specific models\n            \u251c\u2500\u2500 __init__.py\n            \u251c\u2500\u2500 model_input_state.py\n            \u2514\u2500\u2500 model_output_state.py\n```\n\n### Maximum Recommended Structure\n\n**Evolve to this** as needs arise (best practices):\n\n```\n<node_group>/                           # e.g., \"canary\"\n\u2502\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 API_REFERENCE.md\n\u251c\u2500\u2500 compatibility.yaml                  # Version compatibility matrix\n\u2502\n\u251c\u2500\u2500 shared/                             # LAZY: Only when 2+ nodes share\n\u2502   \u251c\u2500\u2500 models/                         # Independent versioning\n\u2502   \u2502   \u251c\u2500\u2500 v1/                         # Major version 1 (stable)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 model_*.py\n\u2502   \u2502   \u2514\u2500\u2500 v2/                         # Major version 2 (breaking changes)\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py\n\u2502   \u2502       \u2514\u2500\u2500 model_*.py\n\u2502   \u2514\u2500\u2500 protocols/                      # Shared protocols (if needed)\n\u2502       \u251c\u2500\u2500 v1/\n\u2502       \u2514\u2500\u2500 v2/\n\u2502\n\u251c\u2500\u2500 tests/                              # Group-level integration tests\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2502   \u2514\u2500\u2500 test_node_interactions.py\n\u2502   \u2514\u2500\u2500 fixtures/\n\u2502\n\u251c\u2500\u2500 deployment/\n\u2502   \u251c\u2500\u2500 docker-compose.<group>.yml\n\u2502   \u2514\u2500\u2500 *.env files\n\u2502\n\u2514\u2500\u2500 <node_name>/                        # e.g., \"my_tool\"\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 v1_0_0/\n        \u251c\u2500\u2500 README.md                   # Node documentation\n        \u251c\u2500\u2500 CHANGELOG.md                # Version history\n        \u251c\u2500\u2500 node.py                     # ONLY node class + main()\n        \u2502\n        \u251c\u2500\u2500 contract.yaml               # Main interface\n        \u251c\u2500\u2500 node_config.yaml\n        \u251c\u2500\u2500 deployment_config.yaml\n        \u251c\u2500\u2500 state_transitions.yaml      # State machine (if needed)\n        \u251c\u2500\u2500 workflow_testing.yaml       # Testing workflows (if needed)\n        \u251c\u2500\u2500 security_config.yaml        # Security (Effect nodes)\n        \u2502\n        \u251c\u2500\u2500 contracts/                  # YAML subcontracts\n        \u2502   \u251c\u2500\u2500 contract_actions.yaml\n        \u2502   \u251c\u2500\u2500 contract_cli.yaml\n        \u2502   \u251c\u2500\u2500 contract_examples.yaml\n        \u2502   \u251c\u2500\u2500 contract_models.yaml\n        \u2502   \u2514\u2500\u2500 contract_validation.yaml\n        \u2502\n        \u251c\u2500\u2500 models/                     # Node-specific models\n        \u2502   \u251c\u2500\u2500 __init__.py\n        \u2502   \u251c\u2500\u2500 model_input_state.py\n        \u2502   \u251c\u2500\u2500 model_output_state.py\n        \u2502   \u2514\u2500\u2500 enum_*.py\n        \u2502\n        \u251c\u2500\u2500 protocols/                  # Node-specific protocols\n        \u2502   \u251c\u2500\u2500 __init__.py\n        \u2502   \u2514\u2500\u2500 protocol_<node>.py\n        \u2502\n        \u251c\u2500\u2500 tests/                      # Node unit tests\n        \u2502   \u251c\u2500\u2500 unit/\n        \u2502   \u2502   \u2514\u2500\u2500 test_node.py\n        \u2502   \u2514\u2500\u2500 fixtures/\n        \u2502\n        \u2514\u2500\u2500 mock_configurations/        # Testing mocks (optional)\n            \u251c\u2500\u2500 event_bus_mock_behaviors.yaml\n            \u251c\u2500\u2500 llm_mock_responses.yaml\n            \u2514\u2500\u2500 uuid_mock_behaviors.yaml\n```\n\n---\n\n## \ud83c\udfaf Core Principles\n\n### 1. Composed Base Classes (Recommended Approach) \u2b50\n\n**Use pre-composed base classes** that aggregate common subcontract patterns:\n\n#### Three Levels of Composition\n\n```\nModelContract{Type} (minimal)           \u2190 Advanced use cases\n    \u2193\nModelContract{Type}Standard (common)    \u2190 90% of nodes \u2b50\n    \u2193\nModelContract{Type}Full (complete)      \u2190 Complex infrastructure\n```\n\n#### When to Use Each Level\n\n| Level | Use When | Example |\n|-------|----------|---------|\n| **Minimal** | Custom subcontract composition needed | Specialized nodes |\n| **Standard** \u2b50 | Most production nodes | API clients, file processors |\n| **Full** | Complex infrastructure nodes | Database connectors, message brokers |\n\n**Recommendation**: Start with **Standard**, downgrade to Minimal only if you need custom composition.\n\n### 2. Lazy Promotion for Shared Resources\n\n**Don't create `shared/` upfront**. Follow this progression:\n\n```\nPhase 1: Model in node\nnode_1/v1_0_0/models/model_data.py\n\nPhase 2: Second node needs it \u2192 Promote to shared/v1/\nshared/models/v1/model_data.py\nnode_1/v1_0_0/  # updates imports\nnode_2/v1_0_0/  # uses shared version\n\nPhase 3: Breaking change needed \u2192 Create v2\nshared/models/v1/model_data.py  # Old version (frozen)\nshared/models/v2/model_data.py  # New version (breaking changes)\n```\n\n**Promotion Criteria** (ALL must be true):\n1. \u2705 Actually used by 2+ consumers (not \"might be\")\n2. \u2705 Same semantic meaning across consumers\n3. \u2705 Same version lifecycle requirements\n4. \u2705 Detected by duplication analysis (not speculative)\n\nSee [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md) for complete details.\n\n### 3. Protocols: Hybrid Approach\n\n**Both locations are valid** based on scope:\n\n| Protocol Scope | Location | Example |\n|----------------|----------|---------|\n| Node-specific | `node/v1_0_0/protocols/` | `protocol_my_node.py` |\n| Shared (2+ nodes) | `shared/protocols/v1/` | `protocol_common.py` |\n| Framework-wide | `omnibase_spi/protocols/` | `ProtocolOnexNode` |\n\n**Start node-local**, promote when actually shared.\n\n### 4. Container Type: ModelOnexContainer Only\n\n**Always use ModelOnexContainer** (proper Pydantic container):\n\n```python\n# \u2705 CORRECT\nfrom omnibase_core.models.core import ModelOnexContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n```\n\n```python\n# \u274c WRONG - Legacy technical debt\nfrom omnibase.core.onex_container import ONEXContainer\n```\n\n### 5. Node.py Purity\n\n**node.py contains ONLY**:\n- \u2705 One node class (Effect/Compute/Reducer/Orchestrator)\n- \u2705 main() function (one-liner)\n- \u2705 Class-level constants (if needed)\n- \u274c NO other classes\n- \u274c NO enums (use `models/enum_*.py`)\n- \u274c NO helper functions (use separate modules)\n\n### 6. Independent Node Versioning\n\n\u2705 Each node has `v1_0_0/`, `v2_0_0/`, etc.\n\u2705 Nodes evolve independently\n\u2705 Use `compatibility.yaml` to track which versions work together\n\u274c NO group-level versioning (breaks independence)\n\n---\n\n## \ud83c\udfa8 Composed Base Classes\n\n### Overview\n\nPre-composed base classes provide **zero-boilerplate** operational patterns:\n\n```python\n# Instead of manually composing subcontracts...\nclass ModelContractEffect(ModelContractBase):\n    service_resolution: ModelServiceResolutionSubcontract | None = None\n    health_check: ModelHealthCheckSubcontract | None = None\n    performance_monitoring: ModelPerformanceMonitoringSubcontract | None = None\n    configuration: ModelConfigurationSubcontract | None = None\n    # ... etc (boilerplate!)\n\n# Use pre-composed Standard for common patterns:\nclass ModelContractEffectStandard(ModelContractEffect):\n    # All common subcontracts included with sensible defaults!\n```\n\n### Effect Node Compositions\n\n#### ModelContractEffectStandard \u2b50\n**Common patterns for typical Effect nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass ToolProductionAPIClient(NodeEffect):\n    \"\"\"\n    Production Effect node with standard operational patterns.\n\n    Automatically includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `service_resolution` - Service discovery and DI\n- \u2705 `health_check` - Health monitoring\n- \u2705 `performance_monitoring` - Performance metrics\n- \u2705 `configuration` - Configuration management\n- \u2705 `request_response` - Request/response patterns\n- Plus inherited: `event_type`, `caching`, `routing`\n\n#### ModelContractEffectFull\n**All applicable Effect subcontracts**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n\nclass ToolDatabaseConnector(NodeEffect):\n    \"\"\"\n    Complex infrastructure node with all operational capabilities.\n\n    Includes Standard features PLUS:\n    - External dependencies tracking\n    - Runtime introspection\n    - State management\n    - FSM patterns\n    \"\"\"\n```\n\n**Adds to Standard**:\n- \u2705 `external_dependencies` - External dependency management\n- \u2705 `introspection` - Runtime introspection\n- \u2705 `state_management` - Advanced state management (optional)\n- \u2705 `fsm` - Finite state machine patterns (optional)\n\n### Compute Node Compositions\n\n#### ModelContractComputeStandard \u2b50\n**Common patterns for typical Compute nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractComputeStandard\n\nclass ToolDataTransformer(NodeCompute):\n    \"\"\"\n    Standard Compute node with performance optimization patterns.\n\n    Includes:\n    - Caching (critical for pure functions)\n    - Performance monitoring\n    - Configuration management\n    - Health checks\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `caching` - Result caching for pure computations\n- \u2705 `performance_monitoring` - Computation performance tracking\n- \u2705 `configuration` - Algorithm configuration\n- \u2705 `health_check` - Computation health monitoring\n\n#### ModelContractComputeFull\n**All applicable Compute subcontracts**\n\n**Adds to Standard**:\n- \u2705 `service_resolution` - External data source resolution (optional)\n- \u2705 `request_response` - Request/response patterns (optional)\n- \u2705 `introspection` - Runtime introspection (optional)\n\n### Reducer Node Compositions\n\n#### ModelContractReducerStandard \u2b50\n**Common patterns for typical Reducer nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractReducerStandard\n\nclass ToolDataAggregator(NodeReducer):\n    \"\"\"\n    Standard Reducer node with aggregation patterns.\n\n    Includes:\n    - Aggregation (core reducer functionality)\n    - State management\n    - Caching\n    - Performance monitoring\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `aggregation` - Data aggregation strategies\n- \u2705 `state_management` - Aggregation state management\n- \u2705 `caching` - Aggregation result caching\n- \u2705 `performance_monitoring` - Aggregation performance tracking\n\n### Orchestrator Node Compositions\n\n#### ModelContractOrchestratorStandard \u2b50\n**Common patterns for typical Orchestrator nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractOrchestratorStandard\n\nclass ToolWorkflowCoordinator(NodeOrchestrator):\n    \"\"\"\n    Standard Orchestrator node with workflow coordination.\n\n    Includes:\n    - Workflow coordination (core orchestrator functionality)\n    - Routing\n    - Service resolution\n    - Health monitoring\n    - Event coordination\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `workflow_coordination` - Multi-node workflow coordination\n- \u2705 `routing` - Node routing and load balancing\n- \u2705 `service_resolution` - Node and service discovery\n- \u2705 `event_type` - Event-driven orchestration\n- \u2705 `health_check` - Orchestration health monitoring\n\n#### ModelContractOrchestratorFull\n**All applicable Orchestrator subcontracts**\n\n**Adds to Standard**:\n- \u2705 `fsm` - State machine-based workflow control\n- \u2705 `state_management` - Workflow state management\n- \u2705 `performance_monitoring` - Orchestration performance tracking\n- \u2705 `configuration` - Workflow configuration management\n\n### Subcontract-to-Node Type Matrix\n\n| Subcontract | Effect | Compute | Reducer | Orchestrator |\n|------------|--------|---------|---------|--------------|\n| **ServiceResolution** | \u2705 Standard | Optional | Optional | \u2705 Standard |\n| **HealthCheck** | \u2705 Standard | \u2705 Standard | \u2705 Standard | \u2705 Standard |\n| **PerformanceMonitoring** | \u2705 Standard | \u2705 Standard | \u2705 Standard | Optional |\n| **Configuration** | \u2705 Standard | \u2705 Standard | Optional | Optional |\n| **RequestResponse** | \u2705 Standard | Optional | \u274c | \u274c |\n| **Caching** | Optional | \u2705 Standard | \u2705 Standard | \u274c |\n| **EventType** | Optional | \u274c | \u274c | \u2705 Standard |\n| **Routing** | Optional | \u274c | \u274c | \u2705 Standard |\n| **WorkflowCoordination** | \u274c | \u274c | \u274c | \u2705 Standard |\n| **Aggregation** | \u274c | \u274c | \u2705 Standard | \u274c |\n| **StateManagement** | Optional | \u274c | \u2705 Standard | Optional |\n| **FSM** | Optional | \u274c | \u274c | Optional |\n| **ExternalDependencies** | Optional | Optional | \u274c | \u274c |\n| **Introspection** | Optional | Optional | \u274c | \u274c |\n\n**Legend**:\n- \u2705 Standard: Included in `{Type}Standard` composition\n- Optional: Available in `{Type}Full` or can be added manually\n- \u274c: Not applicable to this node type\n\n---\n\n## \ud83d\udcdd Naming Conventions\n\n### File Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Nodes | `node_<name>_<type>.py` | `node_database_writer_effect.py` |\n| Models | `model_<name>.py` | `model_task_data.py` |\n| Enums | `enum_<name>.py` | `enum_task_status.py` |\n| Contracts | `model_contract_<type>.py` | `model_contract_effect.py` |\n| Subcontracts | `model_<type>_subcontract.py` | `model_fsm_subcontract.py` |\n| Protocols | `protocol_<name>.py` | `protocol_event_bus.py` |\n\n### Class Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Nodes | `Node<Name><Type>` | `NodeDatabaseWriterEffect` |\n| Models | `Model<Name>` | `ModelTaskData` |\n| Enums | `Enum<Name>` | `EnumTaskStatus` |\n| Contracts | `ModelContract<Type>` | `ModelContractEffect` |\n| Subcontracts | `Model<Type>Subcontract` | `ModelFSMSubcontract` |\n| Protocols | `Protocol<Name>` | `ProtocolEventBus` |\n\n**Key Point**: Naming is **SUFFIX-based** - the type comes LAST:\n- `NodeDatabaseWriter**Effect**` (not `NodeEffectDatabaseWriter`)\n- `node_database_writer_**effect**.py` (not `node_effect_database_writer.py`)\n\n---\n\n## \ud83d\udd27 Framework Components\n\n### DO NOT DUPLICATE\n\nThese are imported from `omnibase_core`:\n\n#### Base Contracts\n```python\nfrom omnibase_core.models.contracts import (\n    ModelContractBase,\n    ModelContractEffect,\n    ModelContractCompute,\n    ModelContractReducer,\n    ModelContractOrchestrator,\n)\n```\n\n#### Composed Base Contracts \u2b50\n```python\nfrom omnibase_core.models.contracts import (\n    ModelContractEffectStandard,\n    ModelContractEffectFull,\n    ModelContractComputeStandard,\n    ModelContractComputeFull,\n    ModelContractReducerStandard,\n    ModelContractOrchestratorStandard,\n    ModelContractOrchestratorFull,\n)\n```\n\n#### Subcontracts\n```python\nfrom omnibase_core.models.contracts.subcontracts import (\n    ModelFSMSubcontract,\n    ModelEventTypeSubcontract,\n    ModelAggregationSubcontract,\n    ModelStateManagementSubcontract,\n    ModelRoutingSubcontract,\n    ModelCachingSubcontract,\n    ModelServiceResolutionSubcontract,\n    ModelHealthCheckSubcontract,\n    ModelPerformanceMonitoringSubcontract,\n    ModelConfigurationSubcontract,\n    ModelRequestResponseSubcontract,\n    ModelExternalDependenciesSubcontract,\n    ModelIntrospectionSubcontract,\n    ModelWorkflowCoordinationSubcontract,\n)\n```\n\n#### Container\n```python\nfrom omnibase_core.models.core import ModelOnexContainer\n```\n\n---\n\n## \u274c Anti-Patterns\n\n### 1. Premature Shared Resources\n\n```\n# \u274c WRONG - Creating shared/ upfront\nnode_group/\n\u251c\u2500\u2500 shared/\n\u2502   \u2514\u2500\u2500 models/v1/      # Created \"just in case\"\n\u2502       \u2514\u2500\u2500 model_*.py  # No nodes use it yet\n\n# \u2705 CORRECT - Start with node-level models\nnode_group/\n\u2514\u2500\u2500 node_1/\n    \u2514\u2500\u2500 v1_0_0/\n        \u2514\u2500\u2500 models/\n            \u2514\u2500\u2500 model_*.py  # Only promote when 2+ nodes need it\n```\n\n### 2. Using Minimal When Standard Would Work\n\n```python\n# \u274c WRONG - Manual composition when Standard exists\nfrom omnibase_core.models.contracts import ModelContractEffect\n\nclass MyNode(NodeEffect):\n    # Manually adding all standard subcontracts...\n    # (boilerplate repetition!)\n\n# \u2705 CORRECT - Use Standard composition\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass MyNode(NodeEffect):\n    # All standard subcontracts included automatically!\n```\n\n### 3. Multiple Classes in node.py\n\n```python\n# \u274c WRONG - Multiple classes in node.py\nclass MyDataModel(BaseModel):      # Should be in models/\n    pass\n\nclass MyEnum(Enum):                 # Should be in models/\n    pass\n\nclass MyNode(NodeEffect):           # Only this should be in node.py\n    pass\n\n# \u2705 CORRECT - One class in node.py\n# node.py\nfrom .models.model_data import MyDataModel\nfrom .models.enum_status import MyEnum\n\nclass MyNode(NodeEffect):\n    pass\n```\n\n### 4. Using Legacy Container\n\n```python\n# \u274c WRONG - Legacy container (technical debt)\nfrom omnibase.core.onex_container import ONEXContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ONEXContainer) -> None:\n        pass\n\n# \u2705 CORRECT - Proper Pydantic container\nfrom omnibase_core.models.core import ModelOnexContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ModelOnexContainer) -> None:\n        pass\n```\n\n### 5. Group-Level Versioning\n\n```\n# \u274c WRONG - Version at group level\nnode_group/\n\u2514\u2500\u2500 v1_0_0/         # Breaks independent node evolution\n    \u251c\u2500\u2500 node_1/\n    \u2514\u2500\u2500 node_2/\n\n# \u2705 CORRECT - Version per node\nnode_group/\n\u251c\u2500\u2500 node_1/\n\u2502   \u2514\u2500\u2500 v1_0_0/    # Independent versioning\n\u2514\u2500\u2500 node_2/\n    \u2514\u2500\u2500 v2_0_0/    # Can be different version\n```\n\n### 6. Premature Protocol Promotion\n\n```\n# \u274c WRONG - Moving protocol to omnibase_spi prematurely\nomnibase_spi/protocols/\n\u2514\u2500\u2500 protocol_experimental.py  # Only one node uses it!\n\n# \u2705 CORRECT - Keep in node until actually shared\nnode/v1_0_0/protocols/\n\u2514\u2500\u2500 protocol_experimental.py  # Promote when 2+ nodes need it\n```\n\n---\n\n## \ud83d\udd04 Migration Strategy\n\n### From Current to Best Practices\n\n**Phase 1: Adopt Composed Base Classes**\n1. \u2705 Update imports to use `ModelContract{Type}Standard`\n2. \u2705 Remove manual subcontract composition\n3. \u2705 Update contract YAML with `composed_type: \"standard\"`\n4. \u2705 Test that all subcontracts work as expected\n\n**Phase 2: Add Structure**\n1. \ud83c\udd95 Add `compatibility.yaml` at group level\n2. \ud83c\udd95 Add `README.md` + `CHANGELOG.md` per node\n3. \ud83c\udd95 Add `tests/` directories (explicit structure)\n4. \ud83c\udd95 Add node-level documentation\n\n**Phase 3: Lazy Promotion (when needed)**\n1. \u23f8\ufe0f Monitor for duplicate models/protocols\n2. \u23f8\ufe0f Create `shared/models/v1/` when 2nd node needs it\n3. \u23f8\ufe0f Create `shared/models/v2/` when breaking changes needed\n4. \u23f8\ufe0f Promote protocols to `omnibase_spi` when truly framework-wide\n\n### Migration Scripts\n\n**Required tooling**:\n1. `scripts/detect_duplicate_models.py` - Find models to promote\n2. `scripts/validate_compatibility.py` - Check version matrix\n3. `scripts/generate_docs.py` - Auto-gen from contracts\n4. `scripts/migrate_to_standard.py` - Convert to Standard base classes\n\n---\n\n## \ud83d\udee0\ufe0f Tooling Support\n\n### Duplication Detection\n```bash\n# Find models/protocols that should be promoted\npython scripts/detect_duplicate_models.py --group canary\n```\n\n### Compatibility Validation\n```bash\n# Validate version compatibility matrix\npython scripts/validate_compatibility.py --all\n```\n\n### Documentation Generation\n```bash\n# Auto-generate API_REFERENCE.md from contracts\npython scripts/generate_docs.py --group canary --format markdown\n```\n\n### CLI Tools\n```bash\n# Create new node with Standard template\nonex create node --type effect --template standard --name my_tool\n\n# Validate node structure\nonex validate node --path ./my_tool/v1_0_0/\n\n# Promote model to shared\nonex promote model --model model_data --to shared/v1/\n```\n\n---\n\n## \ud83d\udcda References\n\n**Related Documentation**:\n- [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md) - Patterns and examples\n- [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md) - Versioning strategy\n- [examples/](examples/) - Real implementation examples\n\n**Framework Code**:\n- `omnibase_core/models/contracts/` - Base and composed contracts\n- `omnibase_core/models/contracts/subcontracts/` - All subcontracts\n- `omnibase_core/models/core/` - ModelOnexContainer\n- `omnibase_spi/protocols/` - Framework-wide protocols\n\n**Reference Implementations**:\n- `omnibase_3/src/omnibase/tools/canary/` - Production node group\n\n---\n\n## \ud83d\udccb Quick Checklist\n\n### Creating a New Node\n\n- [ ] Choose correct node type (Effect/Compute/Reducer/Orchestrator)\n- [ ] Use **Standard** composed base class (not minimal)\n- [ ] Follow file naming: `node_<name>_<type>.py`\n- [ ] Follow class naming: `Node<Name><Type>`\n- [ ] Use ModelOnexContainer (not ONEXContainer)\n- [ ] One class per node.py (no enums, no helpers)\n- [ ] Create contract.yaml with all required fields\n- [ ] Keep models node-local (promote when 2+ nodes need)\n- [ ] Keep protocols node-local (promote when actually shared)\n- [ ] Add comprehensive tests\n- [ ] Document in README.md and CHANGELOG.md\n\n### Before Promoting to Shared\n\n- [ ] Actually used by 2+ nodes (not \"might be\")\n- [ ] Same semantic meaning across consumers\n- [ ] Same version lifecycle requirements\n- [ ] Detected by duplication analysis\n- [ ] Use `shared/models/v1/` (major version only)\n- [ ] Update imports in all consuming nodes\n- [ ] Add tests for shared resource\n\n---\n\n**Status**: \u2705 Canonical Reference\n**Version**: 2.0.0\n**Last Updated**: 2025-10-01\n**Key Feature**: Composed base classes (Standard/Full) as recommended approach",
                            "url": null,
                            "relevance_score": 0.40979397,
                            "semantic_score": 0.40979397,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          }
                        ],
                        "query": "contract-driven development patterns"
                      },
                      "knowledge_graph": {
                        "success": true,
                        "source": "memgraph_knowledge_graph",
                        "results": [],
                        "query": "contract-driven development patterns",
                        "search_terms": [
                          "contract-driven",
                          "development",
                          "patterns"
                        ]
                      }
                    },
                    "synthesis": {
                      "key_findings": [
                        "Identified 5 semantically similar items"
                      ],
                      "patterns_identified": [
                        "Vector search found 5 semantically related items"
                      ],
                      "recommended_actions": [
                        "Check RAG results for API documentation and best practices",
                        "Review similar API implementations from vector search"
                      ],
                      "cross_source_connections": [],
                      "confidence_score": 0.5,
                      "ecosystem_insights": [
                        "Cross-referenced patterns across omninode ecosystem projects",
                        "4-node architecture compliance and implementation patterns",
                        "Integration opportunities between omniagent/omnimcp components",
                        "Architectural consistency analysis across ecosystem"
                      ],
                      "cross_project_scope": "Searched across entire omninode ecosystem including omnibase-core, omnibase-spi, omniagent, omnimcp",
                      "ecosystem_integration_opportunities": [
                        "Identify shared patterns between omnibase components",
                        "Leverage 4-node architecture across ecosystem projects",
                        "Optimize cross-component communication patterns"
                      ]
                    }
                  },
                  "implementation_patterns": {
                    "success": true,
                    "query": "API contract validation",
                    "context": "api_development",
                    "timestamp": "2025-10-06T15:13:10.905546",
                    "duration_ms": 2470,
                    "sources_queried": [
                      "RAG/Enhanced Search",
                      "Qdrant Vector DB",
                      "Memgraph Knowledge Graph"
                    ],
                    "sources_successful": [
                      "RAG",
                      "Vector Search",
                      "Knowledge Graph"
                    ],
                    "total_results": 5,
                    "results": {
                      "rag_search": {
                        "success": true,
                        "source": "rag_search",
                        "results": [],
                        "query": "API contract validation",
                        "reranked": false
                      },
                      "vector_search": {
                        "success": true,
                        "source": "qdrant_vector_search",
                        "results": [
                          {
                            "entity_id": "doc_189357934837",
                            "entity_type": "page",
                            "title": "ModelContractBase - ONEX Contract Base Class",
                            "content": "ModelContractBase - ONEX Contract Base Class\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                            "url": null,
                            "relevance_score": 0.4902236,
                            "semantic_score": 0.4902236,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_813963796165",
                            "entity_type": "page",
                            "title": "ONEX Example: model_contract_base",
                            "content": "ONEX Example: model_contract_base\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                            "url": null,
                            "relevance_score": 0.48997834,
                            "semantic_score": 0.48997834,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_813963796165",
                            "entity_type": "page",
                            "title": "ONEX Example: model_contract_base",
                            "content": "ONEX Example: model_contract_base\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                            "url": null,
                            "relevance_score": 0.48997834,
                            "semantic_score": 0.48997834,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "page_69",
                            "entity_type": "page",
                            "title": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                            "content": "### \n\u200b\nCommercial agreements\nWhether you\u2019re using Anthropic\u2019s API directly (1P) or accessing it through AWS Bedrock or Google Vertex (3P), your existing commercial agreement will apply to Claude Code usage, unless we\u2019ve mutually agreed otherwise.\n## \n\u200b\nCompliance\n### \n\u200b\nHealthcare compliance (BAA)\nIf a customer has a Business Associate Agreement (BAA) with us, and wants to use Claude Code, the BAA will automatically extend to cover Claude Code if the customer has executed a BAA and has Zero Data Retention (ZDR) activated. The BAA will be applicable to that customer\u2019s API traffic flowing through Claude Code.\n## \n\u200b\nSecurity and trust\n### \n\u200b\nTrust and safety\nYou can find more information in the [Anthropic Trust Center](https://trust.anthropic.com) and [Transparency Hub](https://www.anthropic.com/transparency).\n### \n\u200b\nSecurity vulnerability reporting\nAnthropic manages our security program through HackerOne. [Use this form to report vulnerabilities](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\u00a9 Anthropic PBC. All rights reserved. Use is subject to applicable Anthropic Terms of Service.\nWas this page helpful?\nYesNo\n[Hooks reference](https://docs.anthropic.com/en/docs/claude-code/hooks)\n[x](https://x.com/AnthropicAI)[linkedin](https://www.linkedin.com/company/anthropicresearch)\nOn this page\n  * Legal agreements\n  * License\n  * Commercial agreements\n  * Compliance\n  * Healthcare compliance (BAA)\n  * Security and trust\n  * Trust and safety\n  * Security vulnerability reporting",
                            "url": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                            "relevance_score": 0.45352313,
                            "semantic_score": 0.45352313,
                            "structural_score": null,
                            "source_id": "9a532b2b74e5d48a",
                            "project_id": null,
                            "created_at": "2025-09-01T15:47:59.622052+00:00",
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "page_69",
                            "entity_type": "page",
                            "title": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                            "content": "### \n\u200b\nCommercial agreements\nWhether you\u2019re using Anthropic\u2019s API directly (1P) or accessing it through AWS Bedrock or Google Vertex (3P), your existing commercial agreement will apply to Claude Code usage, unless we\u2019ve mutually agreed otherwise.\n## \n\u200b\nCompliance\n### \n\u200b\nHealthcare compliance (BAA)\nIf a customer has a Business Associate Agreement (BAA) with us, and wants to use Claude Code, the BAA will automatically extend to cover Claude Code if the customer has executed a BAA and has Zero Data Retention (ZDR) activated. The BAA will be applicable to that customer\u2019s API traffic flowing through Claude Code.\n## \n\u200b\nSecurity and trust\n### \n\u200b\nTrust and safety\nYou can find more information in the [Anthropic Trust Center](https://trust.anthropic.com) and [Transparency Hub](https://www.anthropic.com/transparency).\n### \n\u200b\nSecurity vulnerability reporting\nAnthropic manages our security program through HackerOne. [Use this form to report vulnerabilities](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\u00a9 Anthropic PBC. All rights reserved. Use is subject to applicable Anthropic Terms of Service.\nWas this page helpful?\nYesNo\n[Hooks reference](https://docs.anthropic.com/en/docs/claude-code/hooks)\n[x](https://x.com/AnthropicAI)[linkedin](https://www.linkedin.com/company/anthropicresearch)\nOn this page\n  * Legal agreements\n  * License\n  * Commercial agreements\n  * Compliance\n  * Healthcare compliance (BAA)\n  * Security and trust\n  * Trust and safety\n  * Security vulnerability reporting",
                            "url": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                            "relevance_score": 0.45352313,
                            "semantic_score": 0.45352313,
                            "structural_score": null,
                            "source_id": "9a532b2b74e5d48a",
                            "project_id": null,
                            "created_at": "2025-09-01T15:47:59.622052+00:00",
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          }
                        ],
                        "query": "API contract validation"
                      },
                      "knowledge_graph": {
                        "success": true,
                        "source": "memgraph_knowledge_graph",
                        "results": [],
                        "query": "API contract validation",
                        "search_terms": [
                          "contract",
                          "validation"
                        ]
                      }
                    },
                    "synthesis": {
                      "key_findings": [
                        "Identified 5 semantically similar items"
                      ],
                      "patterns_identified": [
                        "Vector search found 5 semantically related items"
                      ],
                      "recommended_actions": [
                        "Check RAG results for API documentation and best practices",
                        "Review similar API implementations from vector search"
                      ],
                      "cross_source_connections": [],
                      "confidence_score": 0.5,
                      "ecosystem_insights": [
                        "Cross-referenced patterns across omninode ecosystem projects",
                        "4-node architecture compliance and implementation patterns",
                        "Integration opportunities between omniagent/omnimcp components",
                        "Architectural consistency analysis across ecosystem"
                      ],
                      "cross_project_scope": "Searched across entire omninode ecosystem including omnibase-core, omnibase-spi, omniagent, omnimcp",
                      "ecosystem_integration_opportunities": [
                        "Identify shared patterns between omnibase components",
                        "Leverage 4-node architecture across ecosystem projects",
                        "Optimize cross-component communication patterns"
                      ]
                    }
                  }
                },
                "quality_metrics": {
                  "success": true,
                  "analysis": {
                    "source_path": "generated_compute.py",
                    "language": "python",
                    "content_length": 852,
                    "quality_score": 0.96,
                    "quality_metrics": {
                      "complexity": 1.0,
                      "maintainability": 1.0,
                      "documentation": 1.0,
                      "structure": 0.8
                    },
                    "architectural_compliance": {
                      "onex_compliance": 0.9600000000000001,
                      "pattern_compliance": 0,
                      "compliance_insights": []
                    },
                    "code_patterns": {
                      "identified_patterns": [],
                      "anti_patterns": [
                        "Unresolved TODOs/FIXMEs present"
                      ],
                      "improvement_opportunities": []
                    },
                    "maintainability": {
                      "score": 1.0,
                      "factors": {
                        "line_count": 42,
                        "avg_line_length": 19.30952380952381,
                        "max_line_length": 87,
                        "empty_lines": 15
                      }
                    },
                    "architectural_era": "modern",
                    "temporal_relevance": 0.9600000000000001
                  },
                  "orchestration_summary": {
                    "sources_queried": [
                      "RAG/Enhanced Search",
                      "Qdrant Vector DB",
                      "Memgraph Knowledge Graph"
                    ],
                    "sources_successful": [
                      "RAG",
                      "Vector Search",
                      "Knowledge Graph"
                    ],
                    "synthesis": {
                      "key_findings": [
                        "Identified 3 semantically similar items"
                      ],
                      "patterns_identified": [
                        "Vector search found 3 semantically related items"
                      ],
                      "recommended_actions": [
                        "Review RAG search results for documentation patterns",
                        "Analyze vector search results for code similarities",
                        "Explore knowledge graph connections for related concepts"
                      ],
                      "cross_source_connections": [],
                      "confidence_score": 0.5
                    },
                    "duration_ms": 2345
                  },
                  "intelligence_service_url": "orchestrated_backend_services",
                  "timestamp": "2025-10-06T15:13:13.386036"
                },
                "quality_score": 0.0,
                "lines_generated": 42,
                "validation_passed": false
              },
              "error": null,
              "execution_time_ms": 7818.723917007446,
              "trace_id": "agent_agent-contract-driven-generator_1759763587918_4436769552"
            },
            "error": null
          },
          "duration_ms": 7818.795919418335,
          "parent_trace_id": "coord_1759763587845_4436769552"
        },
        {
          "timestamp": 1759763595.7934341,
          "datetime_str": "2025-10-06T11:13:15.793435",
          "event_type": "AGENT_END",
          "level": "INFO",
          "agent_name": "agent-contract-driven-generator",
          "task_id": "task2",
          "coordinator_id": null,
          "message": "Agent completed: agent-contract-driven-generator (7874.48ms)",
          "metadata": {
            "result": {
              "task_id": "task1",
              "agent_name": "agent-contract-driven-generator",
              "success": true,
              "output_data": {
                "generated_code": "\"\"\"\nUserAuthentication - ONEX Effect Node\n\nContract for user authentication operations\n\"\"\"\n\nfrom typing import Any, Dict\nfrom pydantic import BaseModel, Field\n\n\nclass UserAuthenticationInput(BaseModel):\n    \"\"\"Input model for UserAuthentication.\"\"\"\n    username: str = Field(description=\"User's username\")\n    password: str = Field(description=\"User's password\")\n\n\nclass UserAuthenticationOutput(BaseModel):\n    \"\"\"Output model for UserAuthentication.\"\"\"\n    success: bool = Field(description=\"Authentication success status\")\n    token: str | None = Field(description=\"JWT token if successful\")\n    error_message: str | None = Field(description=\"Error message if failed\")\n\n\nclass NodeUserAuthenticationEffect:\n    \"\"\"\n    ONEX Effect node for UserAuthentication.\n    \n    Contract for user authentication operations\n    \"\"\"\n\n    async def execute(self, input_data: UserAuthenticationInput) -> UserAuthenticationOutput:\n        \"\"\"\n        Execute effect operation.\n        \n        Args:\n            input_data: Validated input model\n        \n        Returns:\n            Validated output model\n        \"\"\"\n        # TODO: Implement effect logic\n        # Intelligence gathered: 2 sources\n        \n        # Placeholder implementation\n        return UserAuthenticationOutput()",
                "node_type": "Effect",
                "contract": {
                  "name": "UserAuthentication",
                  "description": "Contract for user authentication operations",
                  "input_model": {
                    "username": {
                      "type": "str",
                      "description": "User's username"
                    },
                    "password": {
                      "type": "str",
                      "description": "User's password"
                    }
                  },
                  "output_model": {
                    "success": {
                      "type": "bool",
                      "description": "Authentication success status"
                    },
                    "token": {
                      "type": "str | None",
                      "description": "JWT token if successful"
                    },
                    "error_message": {
                      "type": "str | None",
                      "description": "Error message if failed"
                    }
                  }
                },
                "intelligence_gathered": {
                  "domain_patterns": {
                    "success": true,
                    "query": "contract-driven development patterns",
                    "context": "api_development",
                    "timestamp": "2025-10-06T15:13:08.014629",
                    "duration_ms": 2908,
                    "sources_queried": [
                      "RAG/Enhanced Search",
                      "Qdrant Vector DB",
                      "Memgraph Knowledge Graph"
                    ],
                    "sources_successful": [
                      "RAG",
                      "Vector Search",
                      "Knowledge Graph"
                    ],
                    "total_results": 5,
                    "results": {
                      "rag_search": {
                        "success": true,
                        "source": "rag_search",
                        "results": [],
                        "query": "contract-driven development patterns",
                        "reranked": false
                      },
                      "vector_search": {
                        "success": true,
                        "source": "qdrant_vector_search",
                        "results": [
                          {
                            "entity_id": "b8b1a5f4-c6bf-49e0-9a51-3b5c107ca917",
                            "entity_type": "page",
                            "title": "Two-Way Registration Pattern - Event-Driven Service Discovery",
                            "content": "Two-Way Registration Pattern - Event-Driven Service Discovery\n\nThe Two-Way Registration Pattern is an event-driven service discovery architecture that enables dynamic node registration and resilient service coordination across the ONEX ecosystem",
                            "url": null,
                            "relevance_score": 0.4368675,
                            "semantic_score": 0.4368675,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": "2025-10-03T12:34:16.872145",
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "b8b1a5f4-c6bf-49e0-9a51-3b5c107ca917",
                            "entity_type": "page",
                            "title": "Two-Way Registration Pattern - Event-Driven Service Discovery",
                            "content": "Two-Way Registration Pattern - Event-Driven Service Discovery\n\nThe Two-Way Registration Pattern is an event-driven service discovery architecture that enables dynamic node registration and resilient service coordination across the ONEX ecosystem",
                            "url": null,
                            "relevance_score": 0.4368675,
                            "semantic_score": 0.4368675,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": "2025-10-03T12:34:17.898506",
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_457990293851",
                            "entity_type": "page",
                            "title": "Composed Node Base Classes",
                            "content": "Composed Node Base Classes\n\n# ONEX Composed Node Base Classes - Design Specification\n\n**Version**: 1.0.0\n**Status**: \ud83d\udea7 Proposed Design\n**Last Updated**: 2025-10-01\n**Related**: NODE_GROUP_STRUCTURE.md, SHARED_RESOURCE_VERSIONING.md\n\n---\n\n## Problem Statement\n\nCurrently, **each node manually composes the subcontracts it needs**, leading to:\n- \u274c Boilerplate repetition across similar nodes\n- \u274c Inconsistent subcontract usage patterns\n- \u274c Difficult to enforce best practices\n- \u274c No clear templates for new nodes\n\n**Current State** (ModelContractEffect):\n```python\nclass ModelContractEffect(ModelContractBase):\n    # Only 3 subcontracts out of 14 available!\n    event_type: ModelEventTypeSubcontract | None = None\n    caching: ModelCachingSubcontract | None = None\n    routing: ModelRoutingSubcontract | None = None\n```\n\n**Missing Subcontracts** not in base contracts:\n1. ModelConfigurationSubcontract\n2. ModelWorkflowCoordinationSubcontract\n3. ModelServiceResolutionSubcontract \u2b50\n4. ModelExternalDependenciesSubcontract\n5. ModelHealthCheckSubcontract\n6. ModelIntrospectionSubcontract\n7. ModelPerformanceMonitoringSubcontract\n8. ModelRequestResponseSubcontract\n9. ModelAggregationSubcontract (Reducer only?)\n10. ModelFSMSubcontract (in base, but not mentioned)\n11. ModelStateManagementSubcontract (in base, but not mentioned)\n\n---\n\n## Solution: Composed Base Classes\n\nCreate **pre-composed base contract classes** that aggregate common subcontract patterns for typical use cases.\n\n### Design Principles\n\n1. **Layered Composition**: Multiple levels of composition for flexibility\n2. **Progressive Enhancement**: Start minimal, add features as needed\n3. **Clear Naming**: Names indicate included subcontracts\n4. **Backward Compatible**: Existing contracts still work\n5. **Zero Duplication**: DRY principle for subcontract aggregation\n\n---\n\n## Proposed Hierarchy\n\n```\nModelContractBase (foundation)\n    \u2193\nModelContract{Type} (current: minimal)\n    \u2193\nModelContract{Type}Standard (common patterns)\n    \u2193\nModelContract{Type}Full (all applicable subcontracts)\n```\n\n---\n\n## Composed Base Classes Design\n\n### 1. Effect Node Compositions\n\n#### ModelContractEffectStandard\n**Common patterns for typical Effect nodes**\n\n```python\nclass ModelContractEffectStandard(ModelContractEffect):\n    \"\"\"\n    Standard Effect node with common operational patterns.\n\n    Includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n\n    Use for: Most production Effect nodes\n    \"\"\"\n\n    # === OPERATIONAL SUBCONTRACTS ===\n    service_resolution: ModelServiceResolutionSubcontract = Field(\n        default_factory=ModelServiceResolutionSubcontract,\n        description=\"Service discovery and dependency injection\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Health monitoring and readiness checks\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Performance metrics and monitoring\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Configuration management\",\n    )\n\n    request_response: ModelRequestResponseSubcontract = Field(\n        default_factory=ModelRequestResponseSubcontract,\n        description=\"Request/response pattern support\",\n    )\n\n    # Inherit from parent: event_type, caching, routing\n```\n\n#### ModelContractEffectFull\n**All applicable Effect subcontracts**\n\n```python\nclass ModelContractEffectFull(ModelContractEffectStandard):\n    \"\"\"\n    Full-featured Effect node with all operational capabilities.\n\n    Adds to Standard:\n    - External dependencies tracking\n    - Runtime introspection\n    - Advanced state management\n    - FSM patterns\n\n    Use for: Complex infrastructure nodes, critical services\n    \"\"\"\n\n    # === ADVANCED SUBCONTRACTS ===\n    external_dependencies: ModelExternalDependenciesSubcontract = Field(\n        default_factory=ModelExternalDependenciesSubcontract,\n        description=\"External dependency management\",\n    )\n\n    introspection: ModelIntrospectionSubcontract = Field(\n        default_factory=ModelIntrospectionSubcontract,\n        description=\"Runtime introspection capabilities\",\n    )\n\n    state_management: ModelStateManagementSubcontract | None = Field(\n        default=None,\n        description=\"Advanced state management (optional)\",\n    )\n\n    fsm: ModelFSMSubcontract | None = Field(\n        default=None,\n        description=\"Finite state machine patterns (optional)\",\n    )\n```\n\n---\n\n### 2. Compute Node Compositions\n\n#### ModelContractComputeStandard\n**Common patterns for typical Compute nodes**\n\n```python\nclass ModelContractComputeStandard(ModelContractCompute):\n    \"\"\"\n    Standard Compute node with performance optimization patterns.\n\n    Includes:\n    - Caching (critical for pure functions)\n    - Performance monitoring\n    - Configuration management\n    - Health checks\n\n    Use for: Most Compute nodes with caching needs\n    \"\"\"\n\n    # === PERFORMANCE SUBCONTRACTS ===\n    caching: ModelCachingSubcontract = Field(\n        default_factory=ModelCachingSubcontract,\n        description=\"Result caching for pure computations\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Computation performance tracking\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Algorithm configuration\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Computation health monitoring\",\n    )\n```\n\n#### ModelContractComputeFull\n**All applicable Compute subcontracts**\n\n```python\nclass ModelContractComputeFull(ModelContractComputeStandard):\n    \"\"\"\n    Full-featured Compute node for complex computations.\n\n    Adds to Standard:\n    - Service resolution (for external data sources)\n    - Request/response patterns\n    - Introspection capabilities\n\n    Use for: Complex algorithmic nodes, ML inference nodes\n    \"\"\"\n\n    service_resolution: ModelServiceResolutionSubcontract | None = Field(\n        default=None,\n        description=\"External data source resolution (optional)\",\n    )\n\n    request_response: ModelRequestResponseSubcontractt | None = Field(\n        default=None,\n        description=\"Request/response patterns (optional)\",\n    )\n\n    introspection: ModelIntrospectionSubcontract | None = Field(\n        default=None,\n        description=\"Runtime introspection (optional)\",\n    )\n```\n\n---\n\n### 3. Reducer Node Compositions\n\n#### ModelContractReducerStandard\n**Common patterns for typical Reducer nodes**\n\n```python\nclass ModelContractReducerStandard(ModelContractReducer):\n    \"\"\"\n    Standard Reducer node with aggregation patterns.\n\n    Includes:\n    - Aggregation (core reducer functionality)\n    - State management\n    - Caching\n    - Performance monitoring\n\n    Use for: Most Reducer nodes\n    \"\"\"\n\n    # === AGGREGATION SUBCONTRACTS ===\n    aggregation: ModelAggregationSubcontract = Field(\n        default_factory=ModelAggregationSubcontract,\n        description=\"Data aggregation strategies\",\n    )\n\n    state_management: ModelStateManagementSubcontract = Field(\n        default_factory=ModelStateManagementSubcontract,\n        description=\"Aggregation state management\",\n    )\n\n    caching: ModelCachingSubcontract = Field(\n        default_factory=ModelCachingSubcontract,\n        description=\"Aggregation result caching\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Aggregation performance tracking\",\n    )\n```\n\n---\n\n### 4. Orchestrator Node Compositions\n\n#### ModelContractOrchestratorStandard\n**Common patterns for typical Orchestrator nodes**\n\n```python\nclass ModelContractOrchestratorStandard(ModelContractOrchestrator):\n    \"\"\"\n    Standard Orchestrator node with workflow coordination.\n\n    Includes:\n    - Workflow coordination (core orchestrator functionality)\n    - Routing\n    - Service resolution\n    - Health monitoring\n    - Event coordination\n\n    Use for: Most Orchestrator nodes\n    \"\"\"\n\n    # === ORCHESTRATION SUBCONTRACTS ===\n    workflow_coordination: ModelWorkflowCoordinationSubcontract = Field(\n        default_factory=ModelWorkflowCoordinationSubcontract,\n        description=\"Multi-node workflow coordination\",\n    )\n\n    routing: ModelRoutingSubcontract = Field(\n        default_factory=ModelRoutingSubcontract,\n        description=\"Node routing and load balancing\",\n    )\n\n    service_resolution: ModelServiceResolutionSubcontract = Field(\n        default_factory=ModelServiceResolutionSubcontract,\n        description=\"Node and service discovery\",\n    )\n\n    event_type: ModelEventTypeSubcontract = Field(\n        default_factory=ModelEventTypeSubcontract,\n        description=\"Event-driven orchestration\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Orchestration health monitoring\",\n    )\n```\n\n#### ModelContractOrchestratorFull\n**All applicable Orchestrator subcontracts**\n\n```python\nclass ModelContractOrchestratorFull(ModelContractOrchestratorStandard):\n    \"\"\"\n    Full-featured Orchestrator with advanced capabilities.\n\n    Adds to Standard:\n    - FSM patterns for complex workflows\n    - State management\n    - Performance monitoring\n    - Configuration management\n\n    Use for: Complex multi-stage workflows, critical orchestration\n    \"\"\"\n\n    fsm: ModelFSMSubcontract = Field(\n        default_factory=ModelFSMSubcontract,\n        description=\"State machine-based workflow control\",\n    )\n\n    state_management: ModelStateManagementSubcontract = Field(\n        default_factory=ModelStateManagementSubcontract,\n        description=\"Workflow state management\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Orchestration performance tracking\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Workflow configuration management\",\n    )\n```\n\n---\n\n## Subcontract-to-Node Type Matrix\n\n| Subcontract | Effect | Compute | Reducer | Orchestrator | Notes |\n|------------|--------|---------|---------|--------------|-------|\n| **ServiceResolution** | \u2705 Standard | Optional | Optional | \u2705 Standard | DI pattern |\n| **HealthCheck** | \u2705 Standard | \u2705 Standard | \u2705 Standard | \u2705 Standard | Universal |\n| **PerformanceMonitoring** | \u2705 Standard | \u2705 Standard | \u2705 Standard | Optional | Universal |\n| **Configuration** | \u2705 Standard | \u2705 Standard | Optional | Optional | Common |\n| **RequestResponse** | \u2705 Standard | Optional | \u274c | \u274c | Effect/Compute only |\n| **Caching** | Optional | \u2705 Standard | \u2705 Standard | \u274c | Performance |\n| **EventType** | Optional | \u274c | \u274c | \u2705 Standard | Event-driven |\n| **Routing** | Optional | \u274c | \u274c | \u2705 Standard | Orchestration |\n| **WorkflowCoordination** | \u274c | \u274c | \u274c | \u2705 Standard | Orchestrator only |\n| **Aggregation** | \u274c | \u274c | \u2705 Standard | \u274c | Reducer only |\n| **StateManagement** | Optional | \u274c | \u2705 Standard | Optional | Stateful nodes |\n| **FSM** | Optional | \u274c | \u274c | Optional | Complex workflows |\n| **ExternalDependencies** | Optional | Optional | \u274c | \u274c | Integration nodes |\n| **Introspection** | Optional | Optional | \u274c | \u274c | Debugging/monitoring |\n\n**Legend**:\n- \u2705 Standard: Included in `{Type}Standard` composition\n- Optional: Available in `{Type}Full` or can be added manually\n- \u274c: Not applicable to this node type\n\n---\n\n## Usage Examples\n\n### Example 1: Simple Effect Node (Minimal)\n\n```python\n# Use base contract - minimal subcontracts\nfrom omnibase_core.models.contracts import ModelContractEffect\n\nclass ToolSimpleFileWriter(NodeEffect):\n    \"\"\"Minimal Effect node - just the essentials.\"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffect with basic I/O only\n```\n\n### Example 2: Production Effect Node (Standard)\n\n```python\n# Use Standard composition - common operational patterns\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass ToolProductionAPIClient(NodeEffect):\n    \"\"\"\n    Production Effect node with standard operational patterns.\n\n    Automatically includes:\n    - Service resolution\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffectStandard\n        # All standard subcontracts available automatically\n```\n\n### Example 3: Complex Infrastructure Node (Full)\n\n```python\n# Use Full composition - all capabilities\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n\nclass ToolDatabaseConnector(NodeEffect):\n    \"\"\"\n    Complex infrastructure node with all operational capabilities.\n\n    Includes all Standard features PLUS:\n    - External dependencies tracking\n    - Runtime introspection\n    - State management\n    - FSM patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffectFull\n        # Maximum operational capabilities\n```\n\n### Example 4: Custom Composition\n\n```python\n# Start with Standard, customize as needed\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\nfrom omnibase_core.models.contracts.subcontracts import ModelFSMSubcontract\n\nclass ToolCustomProcessor(NodeEffect):\n    \"\"\"Custom composition: Standard + FSM, no caching.\"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract in YAML can specify custom subcontracts\n        # Inherits Standard patterns, adds FSM, removes caching\n```\n\n---\n\n## Contract YAML Examples\n\n### Minimal Effect (base)\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"effect\"\n# Uses: ModelContractEffect\n# Subcontracts: event_type, caching, routing (all optional)\n\nio_operations:\n  - operation_type: \"file_write\"\n    path: \"/data/output.json\"\n```\n\n### Standard Effect\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"effect\"\ncomposed_type: \"standard\"  # \ud83c\udd95 Triggers ModelContractEffectStandard\n# Automatically includes: service_resolution, health_check,\n# performance_monitoring, configuration, request_response\n\nio_operations:\n  - operation_type: \"api_call\"\n    endpoint: \"${SERVICE_URL}/api/data\"\n\nservice_resolution:\n  service_name: \"data_api\"\n  discovery_method: \"dns\"\n\nhealth_check:\n  endpoint: \"/health\"\n  interval_seconds: 30\n\nperformance_monitoring:\n  enable_metrics: true\n  sample_rate: 1.0\n```\n\n### Full Orchestrator\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"orchestrator\"\ncomposed_type: \"full\"  # \ud83c\udd95 Triggers ModelContractOrchestratorFull\n# All orchestration capabilities enabled\n\nworkflow_coordination:\n  max_concurrent_workflows: 100\n  execution_timeout_seconds: 300\n\nrouting:\n  strategy: \"round_robin\"\n  load_balancing: true\n\nfsm:\n  initial_state: \"pending\"\n  states:\n    - name: \"pending\"\n      transitions: [\"processing\"]\n    - name: \"processing\"\n      transitions: [\"completed\", \"failed\"]\n```\n\n---\n\n## Migration Strategy\n\n### Phase 1: Create Composed Base Classes (omnibase_core)\n1. \u2705 Audit all 14 subcontracts\n2. \ud83c\udd95 Create `model_contract_{type}_standard.py` for each node type\n3. \ud83c\udd95 Create `model_contract_{type}_full.py` for each node type\n4. \u2705 Update `__init__.py` exports\n\n### Phase 2: Update Documentation\n1. \ud83c\udd95 Update NODE_GROUP_STRUCTURE.md with composed classes\n2. \ud83c\udd95 Create this document (COMPOSED_NODE_BASE_CLASSES.md)\n3. \ud83c\udd95 Update ONEX examples to show all three levels\n4. \ud83c\udd95 Create migration guide for existing nodes\n\n### Phase 3: Gradual Adoption\n1. \u2705 Keep existing base contracts (backward compatible)\n2. \ud83c\udd95 New nodes use `Standard` by default\n3. \ud83c\udd95 Complex nodes use `Full` when needed\n4. \u23f8\ufe0f Migrate existing nodes gradually (optional)\n\n### Phase 4: Tooling Support\n1. \ud83c\udd95 CLI: `onex create node --template standard|full|minimal`\n2. \ud83c\udd95 Validator: Check subcontract usage against patterns\n3. \ud83c\udd95 Generator: Auto-generate composed contracts from specs\n\n---\n\n## Benefits\n\n### \u2705 Developer Experience\n- **Faster Development**: Pre-composed patterns reduce boilerplate\n- **Best Practices**: Standard patterns enforce good architecture\n- **Clear Templates**: Three levels (minimal/standard/full) guide choices\n- **Gradual Complexity**: Start minimal, add features as needed\n\n### \u2705 Consistency\n- **Uniform Patterns**: Same operational patterns across similar nodes\n- **Predictable Behavior**: Standard nodes behave consistently\n- **Easier Onboarding**: Clear examples of typical compositions\n\n### \u2705 Maintainability\n- **DRY Principle**: Subcontract aggregation in one place\n- **Centralized Updates**: Update composed class, all nodes benefit\n- **Clear Dependencies**: Explicit subcontract requirements\n\n### \u2705 Flexibility\n- **Progressive Enhancement**: Start small, grow as needed\n- **Custom Compositions**: Can still compose manually\n- **Backward Compatible**: Existing nodes unchanged\n\n---\n\n## Implementation Checklist\n\n### omnibase_core Updates\n- [ ] Create `model_contract_effect_standard.py`\n- [ ] Create `model_contract_effect_full.py`\n- [ ] Create `model_contract_compute_standard.py`\n- [ ] Create `model_contract_compute_full.py`\n- [ ] Create `model_contract_reducer_standard.py`\n- [ ] Create `model_contract_orchestrator_standard.py`\n- [ ] Create `model_contract_orchestrator_full.py`\n- [ ] Update `__init__.py` exports\n- [ ] Add validation for `composed_type` field\n- [ ] Unit tests for all composed classes\n\n### Documentation Updates\n- [ ] Update NODE_GROUP_STRUCTURE.md\n- [ ] Create examples for all 14 subcontracts\n- [ ] Update ONEX examples (docs/onex/examples/)\n- [ ] Create migration guide\n- [ ] Update CLAUDE.md\n\n### Tooling\n- [ ] CLI: Node creation with templates\n- [ ] Validator: Pattern compliance checking\n- [ ] Generator: Auto-generate from specs\n\n---\n\n## References\n\n- **Node Structure**: NODE_GROUP_STRUCTURE.md\n- **Subcontracts**: omnibase_core/models/contracts/subcontracts/\n- **Base Contracts**: omnibase_core/models/contracts/model_contract_*.py\n- **Versioning**: SHARED_RESOURCE_VERSIONING.md\n\n---\n\n**Status**: \ud83d\udea7 Proposed Design - Ready for Review\n**Version**: 1.0.0\n**Last Updated**: 2025-10-01\n**Next Steps**: Review \u2192 Implement in omnibase_core \u2192 Update documentation",
                            "url": null,
                            "relevance_score": 0.41716355,
                            "semantic_score": 0.41716355,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_111439200485",
                            "entity_type": "page",
                            "title": "Onex Architecture Patterns Complete",
                            "content": "Onex Architecture Patterns Complete\n\n# ONEX Architecture Patterns - Complete Reference\n\n**Version**: 1.0.0\n**Generated**: 2025-10-01\n**Purpose**: Comprehensive ONEX patterns for AI-assisted development with hooks integration\n\n---\n\n## Core Architecture\n\n### 4-Node Architecture Pattern\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   EFFECT    \u2502\u2500\u2500\u2500\u25b6\u2502   COMPUTE   \u2502\u2500\u2500\u2500\u25b6\u2502   REDUCER   \u2502\u2500\u2500\u2500\u25b6\u2502ORCHESTRATOR \u2502\n\u2502   (Input)   \u2502    \u2502 (Process)   \u2502    \u2502(Aggregate)  \u2502    \u2502(Coordinate) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Unidirectional Data Flow**: EFFECT \u2192 COMPUTE \u2192 REDUCER \u2192 ORCHESTRATOR\n\n---\n\n## 1. Node Types\n\n### NodeEffect\n**Purpose**: Side effect management and external interactions\n**File Pattern**: `node_*_effect.py`\n**Contract**: `ModelContractEffect`\n\n**Responsibilities**:\n- I/O operations (file, database, API)\n- Transaction management with rollback\n- Retry policies and circuit breakers\n- Event emission\n- Metrics collection\n\n**Method Signature**:\n```python\nasync def execute_effect(self, contract: ModelContractEffect) -> Any:\n    \"\"\"Execute side effect with transaction support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Database writes\n- File operations\n- API calls\n- Event publishing\n\n---\n\n### NodeCompute\n**Purpose**: Pure computational operations\n**File Pattern**: `node_*_compute.py`\n**Contract**: `ModelContractCompute`\n\n**Responsibilities**:\n- Data transformations\n- Calculations and computations\n- Caching and memoization\n- Parallel processing\n- Pure functions (no side effects)\n\n**Method Signature**:\n```python\nasync def execute_compute(self, contract: ModelContractCompute) -> Any:\n    \"\"\"Execute computation with caching support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Data transformations\n- Calculations\n- Filtering/mapping\n- Validation logic\n\n---\n\n### NodeReducer\n**Purpose**: Data aggregation and state reduction\n**File Pattern**: `node_*_reducer.py`\n**Contract**: `ModelContractReducer`\n\n**Responsibilities**:\n- Data aggregation\n- State reduction\n- Conflict resolution\n- Streaming support\n- Statistical operations\n\n**Method Signature**:\n```python\nasync def execute_reduction(self, contract: ModelContractReducer) -> Any:\n    \"\"\"Execute reduction with streaming support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Data aggregation\n- Statistics calculation\n- State merging\n- Report generation\n\n---\n\n### NodeOrchestrator\n**Purpose**: Workflow coordination\n**File Pattern**: `node_*_orchestrator.py`\n**Contract**: `ModelContractOrchestrator`\n\n**Responsibilities**:\n- Workflow coordination\n- Thunk emission\n- Dependency management\n- Pipeline orchestration\n- Error recovery\n\n**Method Signature**:\n```python\nasync def execute_orchestration(self, contract: ModelContractOrchestrator) -> Any:\n    \"\"\"Execute orchestration with dependency management.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Multi-step workflows\n- Pipeline coordination\n- Dependency resolution\n- Error recovery flows\n\n---\n\n## 2. Contract System\n\n### Base Contract\n**Class**: `ModelContractBase`\n**File Pattern**: `model_contract_base.py`\n\n**Core Fields**:\n- `name: str` - Contract identifier\n- `version: str` - Semantic version\n- `description: str` - Human-readable description\n- `node_type: EnumNodeType` - Node type (EFFECT/COMPUTE/REDUCER/ORCHESTRATOR)\n\n### Specialized Contracts\n\n1. **ModelContractEffect** - For EFFECT nodes\n2. **ModelContractCompute** - For COMPUTE nodes\n3. **ModelContractReducer** - For REDUCER nodes\n4. **ModelContractOrchestrator** - For ORCHESTRATOR nodes\n\n---\n\n## 3. Subcontract System\n\n**Pattern**: `Model<Type>Subcontract`\n**File Pattern**: `model_*_subcontract.py`\n\n### 6 Core Subcontract Types\n\n1. **ModelFSMSubcontract** - Finite State Machine functionality\n   - State transitions\n   - Event-driven state changes\n   - Guards and actions\n\n2. **ModelEventTypeSubcontract** - Event-driven architecture\n   - Event definitions\n   - Event handlers\n   - Pub/sub patterns\n\n3. **ModelAggregationSubcontract** - Data aggregation\n   - Aggregation strategies\n   - Statistical operations\n   - Group by operations\n\n4. **ModelStateManagementSubcontract** - State persistence\n   - State storage\n   - State synchronization\n   - State recovery\n\n5. **ModelRoutingSubcontract** - Request routing\n   - Load balancing\n   - Request routing\n   - Endpoint selection\n\n6. **ModelCachingSubcontract** - Performance optimization\n   - Cache strategies\n   - TTL management\n   - Cache invalidation\n\n---\n\n## 4. Naming Conventions\n\n### File Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Models | `model_<name>.py` | `model_task_data.py` |\n| Enums | `enum_<name>.py` | `enum_task_status.py` |\n| TypedDicts | `typed_dict_<name>.py` | `typed_dict_result_kwargs.py` |\n| Nodes | `node_<type>_<name>.py` | `node_effect_database.py` |\n| Contracts | `model_contract_<type>.py` | `model_contract_effect.py` |\n| Subcontracts | `model_<type>_subcontract.py` | `model_fsm_subcontract.py` |\n| Protocols | `protocol_<name>.py` | `protocol_event_bus.py` |\n\n### Class Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Pydantic Models | `Model<Name>` | `ModelTaskData` |\n| Enums | `Enum<Name>` | `EnumTaskStatus` |\n| TypedDicts | `TypedDict<Name>` | `TypedDictResultKwargs` |\n| Protocols | `Protocol<Name>` | `ProtocolEventBus` |\n| Nodes | `Node<Name><Type>` | `NodeDatabaseWriterEffect` |\n\n---\n\n## 5. Architecture Principles\n\n### Zero Tolerance for Any Types\n```python\n# \u2705 Correct - Strongly typed\ndef process_data(data: ModelTaskData) -> ModelResult:\n    pass\n\n# \u274c Incorrect - Using Any\ndef process_data(data: Any) -> Any:\n    pass\n```\n\n### Contract-Driven Development\n```python\n# \u2705 Correct - Contract defines behavior\nclass NodeDatabaseWriterEffect:\n    async def execute_effect(self, contract: ModelContractEffect) -> ModelResult:\n        # Implementation follows contract spec\n        pass\n```\n\n### Composition Over Inheritance\n```python\n# \u2705 Correct - Subcontract composition\ncontract = ModelContractEffect(\n    name=\"database_write\",\n    state_transitions=ModelFSMSubcontract(...),  # Compose FSM\n    caching=ModelCachingSubcontract(...)  # Compose caching\n)\n```\n\n### Unidirectional Data Flow\n```python\n# \u2705 Correct - Left to right flow\neffect_result = await effect_node.execute_effect(effect_contract)\ncompute_result = await compute_node.execute_compute(compute_contract)\nreducer_result = await reducer_node.execute_reduction(reducer_contract)\nfinal_result = await orchestrator.execute_orchestration(orch_contract)\n```\n\n---\n\n## 6. Quick Reference Templates\n\n### Creating an Effect Node\n```python\nfrom omnibase.core.models.contracts import ModelContractEffect\nfrom omnibase.core.nodes import NodeEffect\n\nclass NodeMyOperationEffect(NodeEffect):\n    \"\"\"My custom effect node.\"\"\"\n\n    async def execute_effect(self, contract: ModelContractEffect) -> ModelResult:\n        # Transaction management\n        async with self.transaction_manager.begin():\n            # Your side effect logic here\n            result = await self._perform_operation(contract)\n            return ModelResult(success=True, data=result)\n```\n\n### Creating a Compute Node\n```python\nfrom omnibase.core.models.contracts import ModelContractCompute\nfrom omnibase.core.nodes import NodeCompute\n\nclass NodeMyTransformCompute(NodeCompute):\n    \"\"\"My custom compute node.\"\"\"\n\n    async def execute_compute(self, contract: ModelContractCompute) -> ModelResult:\n        # Pure computation with caching\n        cached = self.cache.get(contract.cache_key)\n        if cached:\n            return cached\n\n        result = self._transform_data(contract.input_data)\n        self.cache.set(contract.cache_key, result)\n        return ModelResult(success=True, data=result)\n```\n\n### Contract YAML Template\n```yaml\nname: my_operation\nversion: 1.0.0\ndescription: \"My operation description\"\nnode_type: EFFECT  # or COMPUTE, REDUCER, ORCHESTRATOR\n\n# Optional subcontracts\nstate_transitions:\n  initial_state: PENDING\n  transitions:\n    - from: PENDING\n      to: PROCESSING\n      event: START\n    - from: PROCESSING\n      to: COMPLETED\n      event: FINISH\n\ncaching:\n  strategy: LRU\n  ttl_seconds: 3600\n  max_entries: 1000\n```\n\n---\n\n## 7. Best Practices\n\n### DO \u2705\n- Use unidirectional data flow (EFFECT \u2192 COMPUTE \u2192 REDUCER \u2192 ORCHESTRATOR)\n- Apply contract-driven development\n- Compose subcontracts for reusable functionality\n- Use strong typing (zero `Any` types)\n- Follow naming conventions consistently\n- Implement proper error handling and logging\n- Use UUID correlation IDs for tracing\n\n### DON'T \u274c\n- Skip contract validation\n- Use `Any` types in models\n- Create side effects in compute nodes\n- Break unidirectional flow\n- Mix responsibilities across node types\n- Hardcode configuration (use contracts)\n- Ignore transaction management in effects\n\n---\n\n## 8. Integration Checklist\n\nWhen creating new nodes:\n\n- [ ] Choose correct node type (Effect/Compute/Reducer/Orchestrator)\n- [ ] Follow file naming convention (`node_<type>_<name>.py`)\n- [ ] Follow class naming convention (`Node<Type><Name>`)\n- [ ] Create contract YAML with all required fields\n- [ ] Implement correct method signature (`execute_effect/compute/reduction/orchestration`)\n- [ ] Use appropriate subcontracts (FSM, caching, etc.)\n- [ ] Add proper error handling and logging\n- [ ] Include UUID correlation tracking\n- [ ] Write comprehensive tests\n- [ ] Document in contract YAML\n\n---\n\n**References**:\n- omnibase_core: Node implementations\n- omnibase_3: Contract and subcontract models\n- omnibase_infra: Production examples (PostgreSQL, Kafka adapters)",
                            "url": null,
                            "relevance_score": 0.4168243,
                            "semantic_score": 0.4168243,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_718927590691",
                            "entity_type": "page",
                            "title": "ONEX Implementation Guide",
                            "content": "ONEX Implementation Guide\n\n# ONEX Implementation Guide\n\n**Version**: 2.0.0\n**Status**: \u2705 Canonical Reference\n**Last Updated**: 2025-10-01\n**Purpose**: Comprehensive guide for implementing ONEX nodes and node groups\n\n---\n\n## \ud83d\udcd6 What to Read First\n\n**New to ONEX?** Start here:\n1. Read this guide's [Quick Start](#quick-start) section\n2. Review [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md) for patterns and examples\n3. Explore [examples/](examples/) directory for real implementations\n\n**Looking for specific info?**\n- **Directory structure** \u2192 [Structure Guide](#directory-structure)\n- **Base classes** \u2192 [Composed Base Classes](#composed-base-classes)\n- **Naming patterns** \u2192 [Naming Conventions](#naming-conventions)\n- **Shared resources** \u2192 [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md)\n- **Quick patterns** \u2192 [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md)\n\n---\n\n## \ud83d\ude80 Quick Start\n\n### 3-Tier Base Class System\n\nONEX provides **three levels** of base contracts for progressive enhancement:\n\n```python\n# Level 1: MINIMAL (advanced use cases)\nfrom omnibase_core.models.contracts import ModelContractEffect\n\n# Level 2: STANDARD (recommended for most nodes) \u2b50\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\n# Level 3: FULL (complex infrastructure nodes)\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n```\n\n**Use Standard for 90% of nodes** - includes common operational patterns like service resolution, health monitoring, performance tracking, and configuration management.\n\n### Creating Your First Node\n\n```python\n#!/usr/bin/env python3\n\"\"\"My Effect Node - Production-ready with standard patterns.\"\"\"\n\nfrom pathlib import Path\nfrom omnibase.constants.contract_constants import CONTRACT_FILENAME\nfrom omnibase.core.node_base import NodeBase\nfrom omnibase.core.node_effect import NodeEffect\nfrom omnibase_core.models.core import ModelOnexContainer\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nfrom .models.model_input_state import ModelMyNodeInputState\nfrom .models.model_output_state import ModelMyNodeOutputState\n\n\nclass ToolMyNodeProcessor(NodeEffect):\n    \"\"\"\n    My production Effect node using Standard composition.\n\n    Automatically includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Your initialization here\n\n    async def execute_effect(\n        self, contract: ModelContractEffectStandard\n    ) -> ModelMyNodeOutputState:\n        \"\"\"Main processing method.\"\"\"\n        # Your business logic here\n        pass\n\n\ndef main():\n    \"\"\"One-line main function.\"\"\"\n    return NodeBase(Path(__file__).parent / CONTRACT_FILENAME)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n## \ud83d\udcc1 Directory Structure\n\n### Minimum Viable Structure\n\n**Use this** for new nodes (production-ready):\n\n```\n<node_group>/                           # e.g., \"canary\"\n\u251c\u2500\u2500 __init__.py                         # Group package\n\u251c\u2500\u2500 README.md                           # Main documentation\n\u2502\n\u251c\u2500\u2500 deployment/                         # Deployment configs\n\u2502   \u251c\u2500\u2500 docker-compose.<group>.yml\n\u2502   \u2514\u2500\u2500 *.env files\n\u2502\n\u2514\u2500\u2500 <node_name>/                        # e.g., \"my_tool\"\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 v1_0_0/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 node.py                     # ONLY node class + main()\n        \u2502\n        \u251c\u2500\u2500 contract.yaml               # Main interface\n        \u251c\u2500\u2500 node_config.yaml            # Runtime config\n        \u251c\u2500\u2500 deployment_config.yaml      # Deployment config\n        \u2502\n        \u251c\u2500\u2500 contracts/                  # YAML subcontracts\n        \u2502   \u251c\u2500\u2500 contract_actions.yaml\n        \u2502   \u251c\u2500\u2500 contract_cli.yaml\n        \u2502   \u251c\u2500\u2500 contract_examples.yaml\n        \u2502   \u2514\u2500\u2500 contract_models.yaml\n        \u2502\n        \u2514\u2500\u2500 models/                     # Node-specific models\n            \u251c\u2500\u2500 __init__.py\n            \u251c\u2500\u2500 model_input_state.py\n            \u2514\u2500\u2500 model_output_state.py\n```\n\n### Maximum Recommended Structure\n\n**Evolve to this** as needs arise (best practices):\n\n```\n<node_group>/                           # e.g., \"canary\"\n\u2502\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 API_REFERENCE.md\n\u251c\u2500\u2500 compatibility.yaml                  # Version compatibility matrix\n\u2502\n\u251c\u2500\u2500 shared/                             # LAZY: Only when 2+ nodes share\n\u2502   \u251c\u2500\u2500 models/                         # Independent versioning\n\u2502   \u2502   \u251c\u2500\u2500 v1/                         # Major version 1 (stable)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 model_*.py\n\u2502   \u2502   \u2514\u2500\u2500 v2/                         # Major version 2 (breaking changes)\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py\n\u2502   \u2502       \u2514\u2500\u2500 model_*.py\n\u2502   \u2514\u2500\u2500 protocols/                      # Shared protocols (if needed)\n\u2502       \u251c\u2500\u2500 v1/\n\u2502       \u2514\u2500\u2500 v2/\n\u2502\n\u251c\u2500\u2500 tests/                              # Group-level integration tests\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2502   \u2514\u2500\u2500 test_node_interactions.py\n\u2502   \u2514\u2500\u2500 fixtures/\n\u2502\n\u251c\u2500\u2500 deployment/\n\u2502   \u251c\u2500\u2500 docker-compose.<group>.yml\n\u2502   \u2514\u2500\u2500 *.env files\n\u2502\n\u2514\u2500\u2500 <node_name>/                        # e.g., \"my_tool\"\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 v1_0_0/\n        \u251c\u2500\u2500 README.md                   # Node documentation\n        \u251c\u2500\u2500 CHANGELOG.md                # Version history\n        \u251c\u2500\u2500 node.py                     # ONLY node class + main()\n        \u2502\n        \u251c\u2500\u2500 contract.yaml               # Main interface\n        \u251c\u2500\u2500 node_config.yaml\n        \u251c\u2500\u2500 deployment_config.yaml\n        \u251c\u2500\u2500 state_transitions.yaml      # State machine (if needed)\n        \u251c\u2500\u2500 workflow_testing.yaml       # Testing workflows (if needed)\n        \u251c\u2500\u2500 security_config.yaml        # Security (Effect nodes)\n        \u2502\n        \u251c\u2500\u2500 contracts/                  # YAML subcontracts\n        \u2502   \u251c\u2500\u2500 contract_actions.yaml\n        \u2502   \u251c\u2500\u2500 contract_cli.yaml\n        \u2502   \u251c\u2500\u2500 contract_examples.yaml\n        \u2502   \u251c\u2500\u2500 contract_models.yaml\n        \u2502   \u2514\u2500\u2500 contract_validation.yaml\n        \u2502\n        \u251c\u2500\u2500 models/                     # Node-specific models\n        \u2502   \u251c\u2500\u2500 __init__.py\n        \u2502   \u251c\u2500\u2500 model_input_state.py\n        \u2502   \u251c\u2500\u2500 model_output_state.py\n        \u2502   \u2514\u2500\u2500 enum_*.py\n        \u2502\n        \u251c\u2500\u2500 protocols/                  # Node-specific protocols\n        \u2502   \u251c\u2500\u2500 __init__.py\n        \u2502   \u2514\u2500\u2500 protocol_<node>.py\n        \u2502\n        \u251c\u2500\u2500 tests/                      # Node unit tests\n        \u2502   \u251c\u2500\u2500 unit/\n        \u2502   \u2502   \u2514\u2500\u2500 test_node.py\n        \u2502   \u2514\u2500\u2500 fixtures/\n        \u2502\n        \u2514\u2500\u2500 mock_configurations/        # Testing mocks (optional)\n            \u251c\u2500\u2500 event_bus_mock_behaviors.yaml\n            \u251c\u2500\u2500 llm_mock_responses.yaml\n            \u2514\u2500\u2500 uuid_mock_behaviors.yaml\n```\n\n---\n\n## \ud83c\udfaf Core Principles\n\n### 1. Composed Base Classes (Recommended Approach) \u2b50\n\n**Use pre-composed base classes** that aggregate common subcontract patterns:\n\n#### Three Levels of Composition\n\n```\nModelContract{Type} (minimal)           \u2190 Advanced use cases\n    \u2193\nModelContract{Type}Standard (common)    \u2190 90% of nodes \u2b50\n    \u2193\nModelContract{Type}Full (complete)      \u2190 Complex infrastructure\n```\n\n#### When to Use Each Level\n\n| Level | Use When | Example |\n|-------|----------|---------|\n| **Minimal** | Custom subcontract composition needed | Specialized nodes |\n| **Standard** \u2b50 | Most production nodes | API clients, file processors |\n| **Full** | Complex infrastructure nodes | Database connectors, message brokers |\n\n**Recommendation**: Start with **Standard**, downgrade to Minimal only if you need custom composition.\n\n### 2. Lazy Promotion for Shared Resources\n\n**Don't create `shared/` upfront**. Follow this progression:\n\n```\nPhase 1: Model in node\nnode_1/v1_0_0/models/model_data.py\n\nPhase 2: Second node needs it \u2192 Promote to shared/v1/\nshared/models/v1/model_data.py\nnode_1/v1_0_0/  # updates imports\nnode_2/v1_0_0/  # uses shared version\n\nPhase 3: Breaking change needed \u2192 Create v2\nshared/models/v1/model_data.py  # Old version (frozen)\nshared/models/v2/model_data.py  # New version (breaking changes)\n```\n\n**Promotion Criteria** (ALL must be true):\n1. \u2705 Actually used by 2+ consumers (not \"might be\")\n2. \u2705 Same semantic meaning across consumers\n3. \u2705 Same version lifecycle requirements\n4. \u2705 Detected by duplication analysis (not speculative)\n\nSee [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md) for complete details.\n\n### 3. Protocols: Hybrid Approach\n\n**Both locations are valid** based on scope:\n\n| Protocol Scope | Location | Example |\n|----------------|----------|---------|\n| Node-specific | `node/v1_0_0/protocols/` | `protocol_my_node.py` |\n| Shared (2+ nodes) | `shared/protocols/v1/` | `protocol_common.py` |\n| Framework-wide | `omnibase_spi/protocols/` | `ProtocolOnexNode` |\n\n**Start node-local**, promote when actually shared.\n\n### 4. Container Type: ModelOnexContainer Only\n\n**Always use ModelOnexContainer** (proper Pydantic container):\n\n```python\n# \u2705 CORRECT\nfrom omnibase_core.models.core import ModelOnexContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n```\n\n```python\n# \u274c WRONG - Legacy technical debt\nfrom omnibase.core.onex_container import ONEXContainer\n```\n\n### 5. Node.py Purity\n\n**node.py contains ONLY**:\n- \u2705 One node class (Effect/Compute/Reducer/Orchestrator)\n- \u2705 main() function (one-liner)\n- \u2705 Class-level constants (if needed)\n- \u274c NO other classes\n- \u274c NO enums (use `models/enum_*.py`)\n- \u274c NO helper functions (use separate modules)\n\n### 6. Independent Node Versioning\n\n\u2705 Each node has `v1_0_0/`, `v2_0_0/`, etc.\n\u2705 Nodes evolve independently\n\u2705 Use `compatibility.yaml` to track which versions work together\n\u274c NO group-level versioning (breaks independence)\n\n---\n\n## \ud83c\udfa8 Composed Base Classes\n\n### Overview\n\nPre-composed base classes provide **zero-boilerplate** operational patterns:\n\n```python\n# Instead of manually composing subcontracts...\nclass ModelContractEffect(ModelContractBase):\n    service_resolution: ModelServiceResolutionSubcontract | None = None\n    health_check: ModelHealthCheckSubcontract | None = None\n    performance_monitoring: ModelPerformanceMonitoringSubcontract | None = None\n    configuration: ModelConfigurationSubcontract | None = None\n    # ... etc (boilerplate!)\n\n# Use pre-composed Standard for common patterns:\nclass ModelContractEffectStandard(ModelContractEffect):\n    # All common subcontracts included with sensible defaults!\n```\n\n### Effect Node Compositions\n\n#### ModelContractEffectStandard \u2b50\n**Common patterns for typical Effect nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass ToolProductionAPIClient(NodeEffect):\n    \"\"\"\n    Production Effect node with standard operational patterns.\n\n    Automatically includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `service_resolution` - Service discovery and DI\n- \u2705 `health_check` - Health monitoring\n- \u2705 `performance_monitoring` - Performance metrics\n- \u2705 `configuration` - Configuration management\n- \u2705 `request_response` - Request/response patterns\n- Plus inherited: `event_type`, `caching`, `routing`\n\n#### ModelContractEffectFull\n**All applicable Effect subcontracts**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n\nclass ToolDatabaseConnector(NodeEffect):\n    \"\"\"\n    Complex infrastructure node with all operational capabilities.\n\n    Includes Standard features PLUS:\n    - External dependencies tracking\n    - Runtime introspection\n    - State management\n    - FSM patterns\n    \"\"\"\n```\n\n**Adds to Standard**:\n- \u2705 `external_dependencies` - External dependency management\n- \u2705 `introspection` - Runtime introspection\n- \u2705 `state_management` - Advanced state management (optional)\n- \u2705 `fsm` - Finite state machine patterns (optional)\n\n### Compute Node Compositions\n\n#### ModelContractComputeStandard \u2b50\n**Common patterns for typical Compute nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractComputeStandard\n\nclass ToolDataTransformer(NodeCompute):\n    \"\"\"\n    Standard Compute node with performance optimization patterns.\n\n    Includes:\n    - Caching (critical for pure functions)\n    - Performance monitoring\n    - Configuration management\n    - Health checks\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `caching` - Result caching for pure computations\n- \u2705 `performance_monitoring` - Computation performance tracking\n- \u2705 `configuration` - Algorithm configuration\n- \u2705 `health_check` - Computation health monitoring\n\n#### ModelContractComputeFull\n**All applicable Compute subcontracts**\n\n**Adds to Standard**:\n- \u2705 `service_resolution` - External data source resolution (optional)\n- \u2705 `request_response` - Request/response patterns (optional)\n- \u2705 `introspection` - Runtime introspection (optional)\n\n### Reducer Node Compositions\n\n#### ModelContractReducerStandard \u2b50\n**Common patterns for typical Reducer nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractReducerStandard\n\nclass ToolDataAggregator(NodeReducer):\n    \"\"\"\n    Standard Reducer node with aggregation patterns.\n\n    Includes:\n    - Aggregation (core reducer functionality)\n    - State management\n    - Caching\n    - Performance monitoring\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `aggregation` - Data aggregation strategies\n- \u2705 `state_management` - Aggregation state management\n- \u2705 `caching` - Aggregation result caching\n- \u2705 `performance_monitoring` - Aggregation performance tracking\n\n### Orchestrator Node Compositions\n\n#### ModelContractOrchestratorStandard \u2b50\n**Common patterns for typical Orchestrator nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractOrchestratorStandard\n\nclass ToolWorkflowCoordinator(NodeOrchestrator):\n    \"\"\"\n    Standard Orchestrator node with workflow coordination.\n\n    Includes:\n    - Workflow coordination (core orchestrator functionality)\n    - Routing\n    - Service resolution\n    - Health monitoring\n    - Event coordination\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `workflow_coordination` - Multi-node workflow coordination\n- \u2705 `routing` - Node routing and load balancing\n- \u2705 `service_resolution` - Node and service discovery\n- \u2705 `event_type` - Event-driven orchestration\n- \u2705 `health_check` - Orchestration health monitoring\n\n#### ModelContractOrchestratorFull\n**All applicable Orchestrator subcontracts**\n\n**Adds to Standard**:\n- \u2705 `fsm` - State machine-based workflow control\n- \u2705 `state_management` - Workflow state management\n- \u2705 `performance_monitoring` - Orchestration performance tracking\n- \u2705 `configuration` - Workflow configuration management\n\n### Subcontract-to-Node Type Matrix\n\n| Subcontract | Effect | Compute | Reducer | Orchestrator |\n|------------|--------|---------|---------|--------------|\n| **ServiceResolution** | \u2705 Standard | Optional | Optional | \u2705 Standard |\n| **HealthCheck** | \u2705 Standard | \u2705 Standard | \u2705 Standard | \u2705 Standard |\n| **PerformanceMonitoring** | \u2705 Standard | \u2705 Standard | \u2705 Standard | Optional |\n| **Configuration** | \u2705 Standard | \u2705 Standard | Optional | Optional |\n| **RequestResponse** | \u2705 Standard | Optional | \u274c | \u274c |\n| **Caching** | Optional | \u2705 Standard | \u2705 Standard | \u274c |\n| **EventType** | Optional | \u274c | \u274c | \u2705 Standard |\n| **Routing** | Optional | \u274c | \u274c | \u2705 Standard |\n| **WorkflowCoordination** | \u274c | \u274c | \u274c | \u2705 Standard |\n| **Aggregation** | \u274c | \u274c | \u2705 Standard | \u274c |\n| **StateManagement** | Optional | \u274c | \u2705 Standard | Optional |\n| **FSM** | Optional | \u274c | \u274c | Optional |\n| **ExternalDependencies** | Optional | Optional | \u274c | \u274c |\n| **Introspection** | Optional | Optional | \u274c | \u274c |\n\n**Legend**:\n- \u2705 Standard: Included in `{Type}Standard` composition\n- Optional: Available in `{Type}Full` or can be added manually\n- \u274c: Not applicable to this node type\n\n---\n\n## \ud83d\udcdd Naming Conventions\n\n### File Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Nodes | `node_<name>_<type>.py` | `node_database_writer_effect.py` |\n| Models | `model_<name>.py` | `model_task_data.py` |\n| Enums | `enum_<name>.py` | `enum_task_status.py` |\n| Contracts | `model_contract_<type>.py` | `model_contract_effect.py` |\n| Subcontracts | `model_<type>_subcontract.py` | `model_fsm_subcontract.py` |\n| Protocols | `protocol_<name>.py` | `protocol_event_bus.py` |\n\n### Class Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Nodes | `Node<Name><Type>` | `NodeDatabaseWriterEffect` |\n| Models | `Model<Name>` | `ModelTaskData` |\n| Enums | `Enum<Name>` | `EnumTaskStatus` |\n| Contracts | `ModelContract<Type>` | `ModelContractEffect` |\n| Subcontracts | `Model<Type>Subcontract` | `ModelFSMSubcontract` |\n| Protocols | `Protocol<Name>` | `ProtocolEventBus` |\n\n**Key Point**: Naming is **SUFFIX-based** - the type comes LAST:\n- `NodeDatabaseWriter**Effect**` (not `NodeEffectDatabaseWriter`)\n- `node_database_writer_**effect**.py` (not `node_effect_database_writer.py`)\n\n---\n\n## \ud83d\udd27 Framework Components\n\n### DO NOT DUPLICATE\n\nThese are imported from `omnibase_core`:\n\n#### Base Contracts\n```python\nfrom omnibase_core.models.contracts import (\n    ModelContractBase,\n    ModelContractEffect,\n    ModelContractCompute,\n    ModelContractReducer,\n    ModelContractOrchestrator,\n)\n```\n\n#### Composed Base Contracts \u2b50\n```python\nfrom omnibase_core.models.contracts import (\n    ModelContractEffectStandard,\n    ModelContractEffectFull,\n    ModelContractComputeStandard,\n    ModelContractComputeFull,\n    ModelContractReducerStandard,\n    ModelContractOrchestratorStandard,\n    ModelContractOrchestratorFull,\n)\n```\n\n#### Subcontracts\n```python\nfrom omnibase_core.models.contracts.subcontracts import (\n    ModelFSMSubcontract,\n    ModelEventTypeSubcontract,\n    ModelAggregationSubcontract,\n    ModelStateManagementSubcontract,\n    ModelRoutingSubcontract,\n    ModelCachingSubcontract,\n    ModelServiceResolutionSubcontract,\n    ModelHealthCheckSubcontract,\n    ModelPerformanceMonitoringSubcontract,\n    ModelConfigurationSubcontract,\n    ModelRequestResponseSubcontract,\n    ModelExternalDependenciesSubcontract,\n    ModelIntrospectionSubcontract,\n    ModelWorkflowCoordinationSubcontract,\n)\n```\n\n#### Container\n```python\nfrom omnibase_core.models.core import ModelOnexContainer\n```\n\n---\n\n## \u274c Anti-Patterns\n\n### 1. Premature Shared Resources\n\n```\n# \u274c WRONG - Creating shared/ upfront\nnode_group/\n\u251c\u2500\u2500 shared/\n\u2502   \u2514\u2500\u2500 models/v1/      # Created \"just in case\"\n\u2502       \u2514\u2500\u2500 model_*.py  # No nodes use it yet\n\n# \u2705 CORRECT - Start with node-level models\nnode_group/\n\u2514\u2500\u2500 node_1/\n    \u2514\u2500\u2500 v1_0_0/\n        \u2514\u2500\u2500 models/\n            \u2514\u2500\u2500 model_*.py  # Only promote when 2+ nodes need it\n```\n\n### 2. Using Minimal When Standard Would Work\n\n```python\n# \u274c WRONG - Manual composition when Standard exists\nfrom omnibase_core.models.contracts import ModelContractEffect\n\nclass MyNode(NodeEffect):\n    # Manually adding all standard subcontracts...\n    # (boilerplate repetition!)\n\n# \u2705 CORRECT - Use Standard composition\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass MyNode(NodeEffect):\n    # All standard subcontracts included automatically!\n```\n\n### 3. Multiple Classes in node.py\n\n```python\n# \u274c WRONG - Multiple classes in node.py\nclass MyDataModel(BaseModel):      # Should be in models/\n    pass\n\nclass MyEnum(Enum):                 # Should be in models/\n    pass\n\nclass MyNode(NodeEffect):           # Only this should be in node.py\n    pass\n\n# \u2705 CORRECT - One class in node.py\n# node.py\nfrom .models.model_data import MyDataModel\nfrom .models.enum_status import MyEnum\n\nclass MyNode(NodeEffect):\n    pass\n```\n\n### 4. Using Legacy Container\n\n```python\n# \u274c WRONG - Legacy container (technical debt)\nfrom omnibase.core.onex_container import ONEXContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ONEXContainer) -> None:\n        pass\n\n# \u2705 CORRECT - Proper Pydantic container\nfrom omnibase_core.models.core import ModelOnexContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ModelOnexContainer) -> None:\n        pass\n```\n\n### 5. Group-Level Versioning\n\n```\n# \u274c WRONG - Version at group level\nnode_group/\n\u2514\u2500\u2500 v1_0_0/         # Breaks independent node evolution\n    \u251c\u2500\u2500 node_1/\n    \u2514\u2500\u2500 node_2/\n\n# \u2705 CORRECT - Version per node\nnode_group/\n\u251c\u2500\u2500 node_1/\n\u2502   \u2514\u2500\u2500 v1_0_0/    # Independent versioning\n\u2514\u2500\u2500 node_2/\n    \u2514\u2500\u2500 v2_0_0/    # Can be different version\n```\n\n### 6. Premature Protocol Promotion\n\n```\n# \u274c WRONG - Moving protocol to omnibase_spi prematurely\nomnibase_spi/protocols/\n\u2514\u2500\u2500 protocol_experimental.py  # Only one node uses it!\n\n# \u2705 CORRECT - Keep in node until actually shared\nnode/v1_0_0/protocols/\n\u2514\u2500\u2500 protocol_experimental.py  # Promote when 2+ nodes need it\n```\n\n---\n\n## \ud83d\udd04 Migration Strategy\n\n### From Current to Best Practices\n\n**Phase 1: Adopt Composed Base Classes**\n1. \u2705 Update imports to use `ModelContract{Type}Standard`\n2. \u2705 Remove manual subcontract composition\n3. \u2705 Update contract YAML with `composed_type: \"standard\"`\n4. \u2705 Test that all subcontracts work as expected\n\n**Phase 2: Add Structure**\n1. \ud83c\udd95 Add `compatibility.yaml` at group level\n2. \ud83c\udd95 Add `README.md` + `CHANGELOG.md` per node\n3. \ud83c\udd95 Add `tests/` directories (explicit structure)\n4. \ud83c\udd95 Add node-level documentation\n\n**Phase 3: Lazy Promotion (when needed)**\n1. \u23f8\ufe0f Monitor for duplicate models/protocols\n2. \u23f8\ufe0f Create `shared/models/v1/` when 2nd node needs it\n3. \u23f8\ufe0f Create `shared/models/v2/` when breaking changes needed\n4. \u23f8\ufe0f Promote protocols to `omnibase_spi` when truly framework-wide\n\n### Migration Scripts\n\n**Required tooling**:\n1. `scripts/detect_duplicate_models.py` - Find models to promote\n2. `scripts/validate_compatibility.py` - Check version matrix\n3. `scripts/generate_docs.py` - Auto-gen from contracts\n4. `scripts/migrate_to_standard.py` - Convert to Standard base classes\n\n---\n\n## \ud83d\udee0\ufe0f Tooling Support\n\n### Duplication Detection\n```bash\n# Find models/protocols that should be promoted\npython scripts/detect_duplicate_models.py --group canary\n```\n\n### Compatibility Validation\n```bash\n# Validate version compatibility matrix\npython scripts/validate_compatibility.py --all\n```\n\n### Documentation Generation\n```bash\n# Auto-generate API_REFERENCE.md from contracts\npython scripts/generate_docs.py --group canary --format markdown\n```\n\n### CLI Tools\n```bash\n# Create new node with Standard template\nonex create node --type effect --template standard --name my_tool\n\n# Validate node structure\nonex validate node --path ./my_tool/v1_0_0/\n\n# Promote model to shared\nonex promote model --model model_data --to shared/v1/\n```\n\n---\n\n## \ud83d\udcda References\n\n**Related Documentation**:\n- [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md) - Patterns and examples\n- [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md) - Versioning strategy\n- [examples/](examples/) - Real implementation examples\n\n**Framework Code**:\n- `omnibase_core/models/contracts/` - Base and composed contracts\n- `omnibase_core/models/contracts/subcontracts/` - All subcontracts\n- `omnibase_core/models/core/` - ModelOnexContainer\n- `omnibase_spi/protocols/` - Framework-wide protocols\n\n**Reference Implementations**:\n- `omnibase_3/src/omnibase/tools/canary/` - Production node group\n\n---\n\n## \ud83d\udccb Quick Checklist\n\n### Creating a New Node\n\n- [ ] Choose correct node type (Effect/Compute/Reducer/Orchestrator)\n- [ ] Use **Standard** composed base class (not minimal)\n- [ ] Follow file naming: `node_<name>_<type>.py`\n- [ ] Follow class naming: `Node<Name><Type>`\n- [ ] Use ModelOnexContainer (not ONEXContainer)\n- [ ] One class per node.py (no enums, no helpers)\n- [ ] Create contract.yaml with all required fields\n- [ ] Keep models node-local (promote when 2+ nodes need)\n- [ ] Keep protocols node-local (promote when actually shared)\n- [ ] Add comprehensive tests\n- [ ] Document in README.md and CHANGELOG.md\n\n### Before Promoting to Shared\n\n- [ ] Actually used by 2+ nodes (not \"might be\")\n- [ ] Same semantic meaning across consumers\n- [ ] Same version lifecycle requirements\n- [ ] Detected by duplication analysis\n- [ ] Use `shared/models/v1/` (major version only)\n- [ ] Update imports in all consuming nodes\n- [ ] Add tests for shared resource\n\n---\n\n**Status**: \u2705 Canonical Reference\n**Version**: 2.0.0\n**Last Updated**: 2025-10-01\n**Key Feature**: Composed base classes (Standard/Full) as recommended approach",
                            "url": null,
                            "relevance_score": 0.40979397,
                            "semantic_score": 0.40979397,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          }
                        ],
                        "query": "contract-driven development patterns"
                      },
                      "knowledge_graph": {
                        "success": true,
                        "source": "memgraph_knowledge_graph",
                        "results": [],
                        "query": "contract-driven development patterns",
                        "search_terms": [
                          "contract-driven",
                          "development",
                          "patterns"
                        ]
                      }
                    },
                    "synthesis": {
                      "key_findings": [
                        "Identified 5 semantically similar items"
                      ],
                      "patterns_identified": [
                        "Vector search found 5 semantically related items"
                      ],
                      "recommended_actions": [
                        "Check RAG results for API documentation and best practices",
                        "Review similar API implementations from vector search"
                      ],
                      "cross_source_connections": [],
                      "confidence_score": 0.5,
                      "ecosystem_insights": [
                        "Cross-referenced patterns across omninode ecosystem projects",
                        "4-node architecture compliance and implementation patterns",
                        "Integration opportunities between omniagent/omnimcp components",
                        "Architectural consistency analysis across ecosystem"
                      ],
                      "cross_project_scope": "Searched across entire omninode ecosystem including omnibase-core, omnibase-spi, omniagent, omnimcp",
                      "ecosystem_integration_opportunities": [
                        "Identify shared patterns between omnibase components",
                        "Leverage 4-node architecture across ecosystem projects",
                        "Optimize cross-component communication patterns"
                      ]
                    }
                  },
                  "implementation_patterns": {
                    "success": true,
                    "query": "API contract validation",
                    "context": "api_development",
                    "timestamp": "2025-10-06T15:13:10.932545",
                    "duration_ms": 2411,
                    "sources_queried": [
                      "RAG/Enhanced Search",
                      "Qdrant Vector DB",
                      "Memgraph Knowledge Graph"
                    ],
                    "sources_successful": [
                      "RAG",
                      "Vector Search",
                      "Knowledge Graph"
                    ],
                    "total_results": 5,
                    "results": {
                      "rag_search": {
                        "success": true,
                        "source": "rag_search",
                        "results": [],
                        "query": "API contract validation",
                        "reranked": false
                      },
                      "vector_search": {
                        "success": true,
                        "source": "qdrant_vector_search",
                        "results": [
                          {
                            "entity_id": "doc_189357934837",
                            "entity_type": "page",
                            "title": "ModelContractBase - ONEX Contract Base Class",
                            "content": "ModelContractBase - ONEX Contract Base Class\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                            "url": null,
                            "relevance_score": 0.4902236,
                            "semantic_score": 0.4902236,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_813963796165",
                            "entity_type": "page",
                            "title": "ONEX Example: model_contract_base",
                            "content": "ONEX Example: model_contract_base\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                            "url": null,
                            "relevance_score": 0.48997834,
                            "semantic_score": 0.48997834,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "doc_813963796165",
                            "entity_type": "page",
                            "title": "ONEX Example: model_contract_base",
                            "content": "ONEX Example: model_contract_base\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                            "url": null,
                            "relevance_score": 0.48997834,
                            "semantic_score": 0.48997834,
                            "structural_score": null,
                            "source_id": null,
                            "project_id": null,
                            "created_at": null,
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "page_69",
                            "entity_type": "page",
                            "title": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                            "content": "### \n\u200b\nCommercial agreements\nWhether you\u2019re using Anthropic\u2019s API directly (1P) or accessing it through AWS Bedrock or Google Vertex (3P), your existing commercial agreement will apply to Claude Code usage, unless we\u2019ve mutually agreed otherwise.\n## \n\u200b\nCompliance\n### \n\u200b\nHealthcare compliance (BAA)\nIf a customer has a Business Associate Agreement (BAA) with us, and wants to use Claude Code, the BAA will automatically extend to cover Claude Code if the customer has executed a BAA and has Zero Data Retention (ZDR) activated. The BAA will be applicable to that customer\u2019s API traffic flowing through Claude Code.\n## \n\u200b\nSecurity and trust\n### \n\u200b\nTrust and safety\nYou can find more information in the [Anthropic Trust Center](https://trust.anthropic.com) and [Transparency Hub](https://www.anthropic.com/transparency).\n### \n\u200b\nSecurity vulnerability reporting\nAnthropic manages our security program through HackerOne. [Use this form to report vulnerabilities](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\u00a9 Anthropic PBC. All rights reserved. Use is subject to applicable Anthropic Terms of Service.\nWas this page helpful?\nYesNo\n[Hooks reference](https://docs.anthropic.com/en/docs/claude-code/hooks)\n[x](https://x.com/AnthropicAI)[linkedin](https://www.linkedin.com/company/anthropicresearch)\nOn this page\n  * Legal agreements\n  * License\n  * Commercial agreements\n  * Compliance\n  * Healthcare compliance (BAA)\n  * Security and trust\n  * Trust and safety\n  * Security vulnerability reporting",
                            "url": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                            "relevance_score": 0.45352313,
                            "semantic_score": 0.45352313,
                            "structural_score": null,
                            "source_id": "9a532b2b74e5d48a",
                            "project_id": null,
                            "created_at": "2025-09-01T15:47:59.622052+00:00",
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          },
                          {
                            "entity_id": "page_69",
                            "entity_type": "page",
                            "title": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                            "content": "### \n\u200b\nCommercial agreements\nWhether you\u2019re using Anthropic\u2019s API directly (1P) or accessing it through AWS Bedrock or Google Vertex (3P), your existing commercial agreement will apply to Claude Code usage, unless we\u2019ve mutually agreed otherwise.\n## \n\u200b\nCompliance\n### \n\u200b\nHealthcare compliance (BAA)\nIf a customer has a Business Associate Agreement (BAA) with us, and wants to use Claude Code, the BAA will automatically extend to cover Claude Code if the customer has executed a BAA and has Zero Data Retention (ZDR) activated. The BAA will be applicable to that customer\u2019s API traffic flowing through Claude Code.\n## \n\u200b\nSecurity and trust\n### \n\u200b\nTrust and safety\nYou can find more information in the [Anthropic Trust Center](https://trust.anthropic.com) and [Transparency Hub](https://www.anthropic.com/transparency).\n### \n\u200b\nSecurity vulnerability reporting\nAnthropic manages our security program through HackerOne. [Use this form to report vulnerabilities](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\u00a9 Anthropic PBC. All rights reserved. Use is subject to applicable Anthropic Terms of Service.\nWas this page helpful?\nYesNo\n[Hooks reference](https://docs.anthropic.com/en/docs/claude-code/hooks)\n[x](https://x.com/AnthropicAI)[linkedin](https://www.linkedin.com/company/anthropicresearch)\nOn this page\n  * Legal agreements\n  * License\n  * Commercial agreements\n  * Compliance\n  * Healthcare compliance (BAA)\n  * Security and trust\n  * Trust and safety\n  * Security vulnerability reporting",
                            "url": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                            "relevance_score": 0.45352313,
                            "semantic_score": 0.45352313,
                            "structural_score": null,
                            "source_id": "9a532b2b74e5d48a",
                            "project_id": null,
                            "created_at": "2025-09-01T15:47:59.622052+00:00",
                            "updated_at": null,
                            "relationships": null,
                            "path_to_query": null
                          }
                        ],
                        "query": "API contract validation"
                      },
                      "knowledge_graph": {
                        "success": true,
                        "source": "memgraph_knowledge_graph",
                        "results": [],
                        "query": "API contract validation",
                        "search_terms": [
                          "contract",
                          "validation"
                        ]
                      }
                    },
                    "synthesis": {
                      "key_findings": [
                        "Identified 5 semantically similar items"
                      ],
                      "patterns_identified": [
                        "Vector search found 5 semantically related items"
                      ],
                      "recommended_actions": [
                        "Check RAG results for API documentation and best practices",
                        "Review similar API implementations from vector search"
                      ],
                      "cross_source_connections": [],
                      "confidence_score": 0.5,
                      "ecosystem_insights": [
                        "Cross-referenced patterns across omninode ecosystem projects",
                        "4-node architecture compliance and implementation patterns",
                        "Integration opportunities between omniagent/omnimcp components",
                        "Architectural consistency analysis across ecosystem"
                      ],
                      "cross_project_scope": "Searched across entire omninode ecosystem including omnibase-core, omnibase-spi, omniagent, omnimcp",
                      "ecosystem_integration_opportunities": [
                        "Identify shared patterns between omnibase components",
                        "Leverage 4-node architecture across ecosystem projects",
                        "Optimize cross-component communication patterns"
                      ]
                    }
                  }
                },
                "quality_metrics": {
                  "success": true,
                  "analysis": {
                    "source_path": "generated_effect.py",
                    "language": "python",
                    "content_length": 1276,
                    "quality_score": 0.96,
                    "quality_metrics": {
                      "complexity": 1.0,
                      "maintainability": 1.0,
                      "documentation": 1.0,
                      "structure": 0.8
                    },
                    "architectural_compliance": {
                      "onex_compliance": 0.9600000000000001,
                      "pattern_compliance": 0,
                      "compliance_insights": []
                    },
                    "code_patterns": {
                      "identified_patterns": [],
                      "anti_patterns": [
                        "Unresolved TODOs/FIXMEs present"
                      ],
                      "improvement_opportunities": []
                    },
                    "maintainability": {
                      "score": 1.0,
                      "factors": {
                        "line_count": 45,
                        "avg_line_length": 27.377777777777776,
                        "max_line_length": 93,
                        "empty_lines": 13
                      }
                    },
                    "architectural_era": "modern",
                    "temporal_relevance": 0.9600000000000001
                  },
                  "orchestration_summary": {
                    "sources_queried": [
                      "RAG/Enhanced Search",
                      "Qdrant Vector DB",
                      "Memgraph Knowledge Graph"
                    ],
                    "sources_successful": [
                      "RAG",
                      "Vector Search",
                      "Knowledge Graph"
                    ],
                    "synthesis": {
                      "key_findings": [
                        "Identified 3 semantically similar items"
                      ],
                      "patterns_identified": [
                        "Vector search found 3 semantically related items"
                      ],
                      "recommended_actions": [
                        "Review RAG search results for documentation patterns",
                        "Analyze vector search results for code similarities",
                        "Explore knowledge graph connections for related concepts"
                      ],
                      "cross_source_connections": [],
                      "confidence_score": 0.5
                    },
                    "duration_ms": 2429
                  },
                  "intelligence_service_url": "orchestrated_backend_services",
                  "timestamp": "2025-10-06T15:13:13.356608"
                },
                "quality_score": 0.0,
                "lines_generated": 45,
                "validation_passed": false
              },
              "error": null,
              "execution_time_ms": 7946.048974990845,
              "trace_id": "agent_agent-contract-driven-generator_1759763587918_4436769552"
            },
            "error": null
          },
          "duration_ms": 7874.4800090789795,
          "parent_trace_id": "coord_1759763587845_4436769552"
        }
      ],
      "result": {
        "task_id": "task1",
        "agent_name": "agent-contract-driven-generator",
        "success": true,
        "output_data": {
          "generated_code": "\"\"\"\nUserAuthentication - ONEX Effect Node\n\nContract for user authentication operations\n\"\"\"\n\nfrom typing import Any, Dict\nfrom pydantic import BaseModel, Field\n\n\nclass UserAuthenticationInput(BaseModel):\n    \"\"\"Input model for UserAuthentication.\"\"\"\n    username: str = Field(description=\"User's username\")\n    password: str = Field(description=\"User's password\")\n\n\nclass UserAuthenticationOutput(BaseModel):\n    \"\"\"Output model for UserAuthentication.\"\"\"\n    success: bool = Field(description=\"Authentication success status\")\n    token: str | None = Field(description=\"JWT token if successful\")\n    error_message: str | None = Field(description=\"Error message if failed\")\n\n\nclass NodeUserAuthenticationEffect:\n    \"\"\"\n    ONEX Effect node for UserAuthentication.\n    \n    Contract for user authentication operations\n    \"\"\"\n\n    async def execute(self, input_data: UserAuthenticationInput) -> UserAuthenticationOutput:\n        \"\"\"\n        Execute effect operation.\n        \n        Args:\n            input_data: Validated input model\n        \n        Returns:\n            Validated output model\n        \"\"\"\n        # TODO: Implement effect logic\n        # Intelligence gathered: 2 sources\n        \n        # Placeholder implementation\n        return UserAuthenticationOutput()",
          "node_type": "Effect",
          "contract": {
            "name": "UserAuthentication",
            "description": "Contract for user authentication operations",
            "input_model": {
              "username": {
                "type": "str",
                "description": "User's username"
              },
              "password": {
                "type": "str",
                "description": "User's password"
              }
            },
            "output_model": {
              "success": {
                "type": "bool",
                "description": "Authentication success status"
              },
              "token": {
                "type": "str | None",
                "description": "JWT token if successful"
              },
              "error_message": {
                "type": "str | None",
                "description": "Error message if failed"
              }
            }
          },
          "intelligence_gathered": {
            "domain_patterns": {
              "success": true,
              "query": "contract-driven development patterns",
              "context": "api_development",
              "timestamp": "2025-10-06T15:13:08.014629",
              "duration_ms": 2908,
              "sources_queried": [
                "RAG/Enhanced Search",
                "Qdrant Vector DB",
                "Memgraph Knowledge Graph"
              ],
              "sources_successful": [
                "RAG",
                "Vector Search",
                "Knowledge Graph"
              ],
              "total_results": 5,
              "results": {
                "rag_search": {
                  "success": true,
                  "source": "rag_search",
                  "results": [],
                  "query": "contract-driven development patterns",
                  "reranked": false
                },
                "vector_search": {
                  "success": true,
                  "source": "qdrant_vector_search",
                  "results": [
                    {
                      "entity_id": "b8b1a5f4-c6bf-49e0-9a51-3b5c107ca917",
                      "entity_type": "page",
                      "title": "Two-Way Registration Pattern - Event-Driven Service Discovery",
                      "content": "Two-Way Registration Pattern - Event-Driven Service Discovery\n\nThe Two-Way Registration Pattern is an event-driven service discovery architecture that enables dynamic node registration and resilient service coordination across the ONEX ecosystem",
                      "url": null,
                      "relevance_score": 0.4368675,
                      "semantic_score": 0.4368675,
                      "structural_score": null,
                      "source_id": null,
                      "project_id": null,
                      "created_at": "2025-10-03T12:34:16.872145",
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    },
                    {
                      "entity_id": "b8b1a5f4-c6bf-49e0-9a51-3b5c107ca917",
                      "entity_type": "page",
                      "title": "Two-Way Registration Pattern - Event-Driven Service Discovery",
                      "content": "Two-Way Registration Pattern - Event-Driven Service Discovery\n\nThe Two-Way Registration Pattern is an event-driven service discovery architecture that enables dynamic node registration and resilient service coordination across the ONEX ecosystem",
                      "url": null,
                      "relevance_score": 0.4368675,
                      "semantic_score": 0.4368675,
                      "structural_score": null,
                      "source_id": null,
                      "project_id": null,
                      "created_at": "2025-10-03T12:34:17.898506",
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    },
                    {
                      "entity_id": "doc_457990293851",
                      "entity_type": "page",
                      "title": "Composed Node Base Classes",
                      "content": "Composed Node Base Classes\n\n# ONEX Composed Node Base Classes - Design Specification\n\n**Version**: 1.0.0\n**Status**: \ud83d\udea7 Proposed Design\n**Last Updated**: 2025-10-01\n**Related**: NODE_GROUP_STRUCTURE.md, SHARED_RESOURCE_VERSIONING.md\n\n---\n\n## Problem Statement\n\nCurrently, **each node manually composes the subcontracts it needs**, leading to:\n- \u274c Boilerplate repetition across similar nodes\n- \u274c Inconsistent subcontract usage patterns\n- \u274c Difficult to enforce best practices\n- \u274c No clear templates for new nodes\n\n**Current State** (ModelContractEffect):\n```python\nclass ModelContractEffect(ModelContractBase):\n    # Only 3 subcontracts out of 14 available!\n    event_type: ModelEventTypeSubcontract | None = None\n    caching: ModelCachingSubcontract | None = None\n    routing: ModelRoutingSubcontract | None = None\n```\n\n**Missing Subcontracts** not in base contracts:\n1. ModelConfigurationSubcontract\n2. ModelWorkflowCoordinationSubcontract\n3. ModelServiceResolutionSubcontract \u2b50\n4. ModelExternalDependenciesSubcontract\n5. ModelHealthCheckSubcontract\n6. ModelIntrospectionSubcontract\n7. ModelPerformanceMonitoringSubcontract\n8. ModelRequestResponseSubcontract\n9. ModelAggregationSubcontract (Reducer only?)\n10. ModelFSMSubcontract (in base, but not mentioned)\n11. ModelStateManagementSubcontract (in base, but not mentioned)\n\n---\n\n## Solution: Composed Base Classes\n\nCreate **pre-composed base contract classes** that aggregate common subcontract patterns for typical use cases.\n\n### Design Principles\n\n1. **Layered Composition**: Multiple levels of composition for flexibility\n2. **Progressive Enhancement**: Start minimal, add features as needed\n3. **Clear Naming**: Names indicate included subcontracts\n4. **Backward Compatible**: Existing contracts still work\n5. **Zero Duplication**: DRY principle for subcontract aggregation\n\n---\n\n## Proposed Hierarchy\n\n```\nModelContractBase (foundation)\n    \u2193\nModelContract{Type} (current: minimal)\n    \u2193\nModelContract{Type}Standard (common patterns)\n    \u2193\nModelContract{Type}Full (all applicable subcontracts)\n```\n\n---\n\n## Composed Base Classes Design\n\n### 1. Effect Node Compositions\n\n#### ModelContractEffectStandard\n**Common patterns for typical Effect nodes**\n\n```python\nclass ModelContractEffectStandard(ModelContractEffect):\n    \"\"\"\n    Standard Effect node with common operational patterns.\n\n    Includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n\n    Use for: Most production Effect nodes\n    \"\"\"\n\n    # === OPERATIONAL SUBCONTRACTS ===\n    service_resolution: ModelServiceResolutionSubcontract = Field(\n        default_factory=ModelServiceResolutionSubcontract,\n        description=\"Service discovery and dependency injection\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Health monitoring and readiness checks\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Performance metrics and monitoring\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Configuration management\",\n    )\n\n    request_response: ModelRequestResponseSubcontract = Field(\n        default_factory=ModelRequestResponseSubcontract,\n        description=\"Request/response pattern support\",\n    )\n\n    # Inherit from parent: event_type, caching, routing\n```\n\n#### ModelContractEffectFull\n**All applicable Effect subcontracts**\n\n```python\nclass ModelContractEffectFull(ModelContractEffectStandard):\n    \"\"\"\n    Full-featured Effect node with all operational capabilities.\n\n    Adds to Standard:\n    - External dependencies tracking\n    - Runtime introspection\n    - Advanced state management\n    - FSM patterns\n\n    Use for: Complex infrastructure nodes, critical services\n    \"\"\"\n\n    # === ADVANCED SUBCONTRACTS ===\n    external_dependencies: ModelExternalDependenciesSubcontract = Field(\n        default_factory=ModelExternalDependenciesSubcontract,\n        description=\"External dependency management\",\n    )\n\n    introspection: ModelIntrospectionSubcontract = Field(\n        default_factory=ModelIntrospectionSubcontract,\n        description=\"Runtime introspection capabilities\",\n    )\n\n    state_management: ModelStateManagementSubcontract | None = Field(\n        default=None,\n        description=\"Advanced state management (optional)\",\n    )\n\n    fsm: ModelFSMSubcontract | None = Field(\n        default=None,\n        description=\"Finite state machine patterns (optional)\",\n    )\n```\n\n---\n\n### 2. Compute Node Compositions\n\n#### ModelContractComputeStandard\n**Common patterns for typical Compute nodes**\n\n```python\nclass ModelContractComputeStandard(ModelContractCompute):\n    \"\"\"\n    Standard Compute node with performance optimization patterns.\n\n    Includes:\n    - Caching (critical for pure functions)\n    - Performance monitoring\n    - Configuration management\n    - Health checks\n\n    Use for: Most Compute nodes with caching needs\n    \"\"\"\n\n    # === PERFORMANCE SUBCONTRACTS ===\n    caching: ModelCachingSubcontract = Field(\n        default_factory=ModelCachingSubcontract,\n        description=\"Result caching for pure computations\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Computation performance tracking\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Algorithm configuration\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Computation health monitoring\",\n    )\n```\n\n#### ModelContractComputeFull\n**All applicable Compute subcontracts**\n\n```python\nclass ModelContractComputeFull(ModelContractComputeStandard):\n    \"\"\"\n    Full-featured Compute node for complex computations.\n\n    Adds to Standard:\n    - Service resolution (for external data sources)\n    - Request/response patterns\n    - Introspection capabilities\n\n    Use for: Complex algorithmic nodes, ML inference nodes\n    \"\"\"\n\n    service_resolution: ModelServiceResolutionSubcontract | None = Field(\n        default=None,\n        description=\"External data source resolution (optional)\",\n    )\n\n    request_response: ModelRequestResponseSubcontractt | None = Field(\n        default=None,\n        description=\"Request/response patterns (optional)\",\n    )\n\n    introspection: ModelIntrospectionSubcontract | None = Field(\n        default=None,\n        description=\"Runtime introspection (optional)\",\n    )\n```\n\n---\n\n### 3. Reducer Node Compositions\n\n#### ModelContractReducerStandard\n**Common patterns for typical Reducer nodes**\n\n```python\nclass ModelContractReducerStandard(ModelContractReducer):\n    \"\"\"\n    Standard Reducer node with aggregation patterns.\n\n    Includes:\n    - Aggregation (core reducer functionality)\n    - State management\n    - Caching\n    - Performance monitoring\n\n    Use for: Most Reducer nodes\n    \"\"\"\n\n    # === AGGREGATION SUBCONTRACTS ===\n    aggregation: ModelAggregationSubcontract = Field(\n        default_factory=ModelAggregationSubcontract,\n        description=\"Data aggregation strategies\",\n    )\n\n    state_management: ModelStateManagementSubcontract = Field(\n        default_factory=ModelStateManagementSubcontract,\n        description=\"Aggregation state management\",\n    )\n\n    caching: ModelCachingSubcontract = Field(\n        default_factory=ModelCachingSubcontract,\n        description=\"Aggregation result caching\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Aggregation performance tracking\",\n    )\n```\n\n---\n\n### 4. Orchestrator Node Compositions\n\n#### ModelContractOrchestratorStandard\n**Common patterns for typical Orchestrator nodes**\n\n```python\nclass ModelContractOrchestratorStandard(ModelContractOrchestrator):\n    \"\"\"\n    Standard Orchestrator node with workflow coordination.\n\n    Includes:\n    - Workflow coordination (core orchestrator functionality)\n    - Routing\n    - Service resolution\n    - Health monitoring\n    - Event coordination\n\n    Use for: Most Orchestrator nodes\n    \"\"\"\n\n    # === ORCHESTRATION SUBCONTRACTS ===\n    workflow_coordination: ModelWorkflowCoordinationSubcontract = Field(\n        default_factory=ModelWorkflowCoordinationSubcontract,\n        description=\"Multi-node workflow coordination\",\n    )\n\n    routing: ModelRoutingSubcontract = Field(\n        default_factory=ModelRoutingSubcontract,\n        description=\"Node routing and load balancing\",\n    )\n\n    service_resolution: ModelServiceResolutionSubcontract = Field(\n        default_factory=ModelServiceResolutionSubcontract,\n        description=\"Node and service discovery\",\n    )\n\n    event_type: ModelEventTypeSubcontract = Field(\n        default_factory=ModelEventTypeSubcontract,\n        description=\"Event-driven orchestration\",\n    )\n\n    health_check: ModelHealthCheckSubcontract = Field(\n        default_factory=ModelHealthCheckSubcontract,\n        description=\"Orchestration health monitoring\",\n    )\n```\n\n#### ModelContractOrchestratorFull\n**All applicable Orchestrator subcontracts**\n\n```python\nclass ModelContractOrchestratorFull(ModelContractOrchestratorStandard):\n    \"\"\"\n    Full-featured Orchestrator with advanced capabilities.\n\n    Adds to Standard:\n    - FSM patterns for complex workflows\n    - State management\n    - Performance monitoring\n    - Configuration management\n\n    Use for: Complex multi-stage workflows, critical orchestration\n    \"\"\"\n\n    fsm: ModelFSMSubcontract = Field(\n        default_factory=ModelFSMSubcontract,\n        description=\"State machine-based workflow control\",\n    )\n\n    state_management: ModelStateManagementSubcontract = Field(\n        default_factory=ModelStateManagementSubcontract,\n        description=\"Workflow state management\",\n    )\n\n    performance_monitoring: ModelPerformanceMonitoringSubcontract = Field(\n        default_factory=ModelPerformanceMonitoringSubcontract,\n        description=\"Orchestration performance tracking\",\n    )\n\n    configuration: ModelConfigurationSubcontract = Field(\n        default_factory=ModelConfigurationSubcontract,\n        description=\"Workflow configuration management\",\n    )\n```\n\n---\n\n## Subcontract-to-Node Type Matrix\n\n| Subcontract | Effect | Compute | Reducer | Orchestrator | Notes |\n|------------|--------|---------|---------|--------------|-------|\n| **ServiceResolution** | \u2705 Standard | Optional | Optional | \u2705 Standard | DI pattern |\n| **HealthCheck** | \u2705 Standard | \u2705 Standard | \u2705 Standard | \u2705 Standard | Universal |\n| **PerformanceMonitoring** | \u2705 Standard | \u2705 Standard | \u2705 Standard | Optional | Universal |\n| **Configuration** | \u2705 Standard | \u2705 Standard | Optional | Optional | Common |\n| **RequestResponse** | \u2705 Standard | Optional | \u274c | \u274c | Effect/Compute only |\n| **Caching** | Optional | \u2705 Standard | \u2705 Standard | \u274c | Performance |\n| **EventType** | Optional | \u274c | \u274c | \u2705 Standard | Event-driven |\n| **Routing** | Optional | \u274c | \u274c | \u2705 Standard | Orchestration |\n| **WorkflowCoordination** | \u274c | \u274c | \u274c | \u2705 Standard | Orchestrator only |\n| **Aggregation** | \u274c | \u274c | \u2705 Standard | \u274c | Reducer only |\n| **StateManagement** | Optional | \u274c | \u2705 Standard | Optional | Stateful nodes |\n| **FSM** | Optional | \u274c | \u274c | Optional | Complex workflows |\n| **ExternalDependencies** | Optional | Optional | \u274c | \u274c | Integration nodes |\n| **Introspection** | Optional | Optional | \u274c | \u274c | Debugging/monitoring |\n\n**Legend**:\n- \u2705 Standard: Included in `{Type}Standard` composition\n- Optional: Available in `{Type}Full` or can be added manually\n- \u274c: Not applicable to this node type\n\n---\n\n## Usage Examples\n\n### Example 1: Simple Effect Node (Minimal)\n\n```python\n# Use base contract - minimal subcontracts\nfrom omnibase_core.models.contracts import ModelContractEffect\n\nclass ToolSimpleFileWriter(NodeEffect):\n    \"\"\"Minimal Effect node - just the essentials.\"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffect with basic I/O only\n```\n\n### Example 2: Production Effect Node (Standard)\n\n```python\n# Use Standard composition - common operational patterns\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass ToolProductionAPIClient(NodeEffect):\n    \"\"\"\n    Production Effect node with standard operational patterns.\n\n    Automatically includes:\n    - Service resolution\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffectStandard\n        # All standard subcontracts available automatically\n```\n\n### Example 3: Complex Infrastructure Node (Full)\n\n```python\n# Use Full composition - all capabilities\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n\nclass ToolDatabaseConnector(NodeEffect):\n    \"\"\"\n    Complex infrastructure node with all operational capabilities.\n\n    Includes all Standard features PLUS:\n    - External dependencies tracking\n    - Runtime introspection\n    - State management\n    - FSM patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract: ModelContractEffectFull\n        # Maximum operational capabilities\n```\n\n### Example 4: Custom Composition\n\n```python\n# Start with Standard, customize as needed\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\nfrom omnibase_core.models.contracts.subcontracts import ModelFSMSubcontract\n\nclass ToolCustomProcessor(NodeEffect):\n    \"\"\"Custom composition: Standard + FSM, no caching.\"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Contract in YAML can specify custom subcontracts\n        # Inherits Standard patterns, adds FSM, removes caching\n```\n\n---\n\n## Contract YAML Examples\n\n### Minimal Effect (base)\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"effect\"\n# Uses: ModelContractEffect\n# Subcontracts: event_type, caching, routing (all optional)\n\nio_operations:\n  - operation_type: \"file_write\"\n    path: \"/data/output.json\"\n```\n\n### Standard Effect\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"effect\"\ncomposed_type: \"standard\"  # \ud83c\udd95 Triggers ModelContractEffectStandard\n# Automatically includes: service_resolution, health_check,\n# performance_monitoring, configuration, request_response\n\nio_operations:\n  - operation_type: \"api_call\"\n    endpoint: \"${SERVICE_URL}/api/data\"\n\nservice_resolution:\n  service_name: \"data_api\"\n  discovery_method: \"dns\"\n\nhealth_check:\n  endpoint: \"/health\"\n  interval_seconds: 30\n\nperformance_monitoring:\n  enable_metrics: true\n  sample_rate: 1.0\n```\n\n### Full Orchestrator\n```yaml\ncontract_version: \"2.0.0\"\nnode_type: \"orchestrator\"\ncomposed_type: \"full\"  # \ud83c\udd95 Triggers ModelContractOrchestratorFull\n# All orchestration capabilities enabled\n\nworkflow_coordination:\n  max_concurrent_workflows: 100\n  execution_timeout_seconds: 300\n\nrouting:\n  strategy: \"round_robin\"\n  load_balancing: true\n\nfsm:\n  initial_state: \"pending\"\n  states:\n    - name: \"pending\"\n      transitions: [\"processing\"]\n    - name: \"processing\"\n      transitions: [\"completed\", \"failed\"]\n```\n\n---\n\n## Migration Strategy\n\n### Phase 1: Create Composed Base Classes (omnibase_core)\n1. \u2705 Audit all 14 subcontracts\n2. \ud83c\udd95 Create `model_contract_{type}_standard.py` for each node type\n3. \ud83c\udd95 Create `model_contract_{type}_full.py` for each node type\n4. \u2705 Update `__init__.py` exports\n\n### Phase 2: Update Documentation\n1. \ud83c\udd95 Update NODE_GROUP_STRUCTURE.md with composed classes\n2. \ud83c\udd95 Create this document (COMPOSED_NODE_BASE_CLASSES.md)\n3. \ud83c\udd95 Update ONEX examples to show all three levels\n4. \ud83c\udd95 Create migration guide for existing nodes\n\n### Phase 3: Gradual Adoption\n1. \u2705 Keep existing base contracts (backward compatible)\n2. \ud83c\udd95 New nodes use `Standard` by default\n3. \ud83c\udd95 Complex nodes use `Full` when needed\n4. \u23f8\ufe0f Migrate existing nodes gradually (optional)\n\n### Phase 4: Tooling Support\n1. \ud83c\udd95 CLI: `onex create node --template standard|full|minimal`\n2. \ud83c\udd95 Validator: Check subcontract usage against patterns\n3. \ud83c\udd95 Generator: Auto-generate composed contracts from specs\n\n---\n\n## Benefits\n\n### \u2705 Developer Experience\n- **Faster Development**: Pre-composed patterns reduce boilerplate\n- **Best Practices**: Standard patterns enforce good architecture\n- **Clear Templates**: Three levels (minimal/standard/full) guide choices\n- **Gradual Complexity**: Start minimal, add features as needed\n\n### \u2705 Consistency\n- **Uniform Patterns**: Same operational patterns across similar nodes\n- **Predictable Behavior**: Standard nodes behave consistently\n- **Easier Onboarding**: Clear examples of typical compositions\n\n### \u2705 Maintainability\n- **DRY Principle**: Subcontract aggregation in one place\n- **Centralized Updates**: Update composed class, all nodes benefit\n- **Clear Dependencies**: Explicit subcontract requirements\n\n### \u2705 Flexibility\n- **Progressive Enhancement**: Start small, grow as needed\n- **Custom Compositions**: Can still compose manually\n- **Backward Compatible**: Existing nodes unchanged\n\n---\n\n## Implementation Checklist\n\n### omnibase_core Updates\n- [ ] Create `model_contract_effect_standard.py`\n- [ ] Create `model_contract_effect_full.py`\n- [ ] Create `model_contract_compute_standard.py`\n- [ ] Create `model_contract_compute_full.py`\n- [ ] Create `model_contract_reducer_standard.py`\n- [ ] Create `model_contract_orchestrator_standard.py`\n- [ ] Create `model_contract_orchestrator_full.py`\n- [ ] Update `__init__.py` exports\n- [ ] Add validation for `composed_type` field\n- [ ] Unit tests for all composed classes\n\n### Documentation Updates\n- [ ] Update NODE_GROUP_STRUCTURE.md\n- [ ] Create examples for all 14 subcontracts\n- [ ] Update ONEX examples (docs/onex/examples/)\n- [ ] Create migration guide\n- [ ] Update CLAUDE.md\n\n### Tooling\n- [ ] CLI: Node creation with templates\n- [ ] Validator: Pattern compliance checking\n- [ ] Generator: Auto-generate from specs\n\n---\n\n## References\n\n- **Node Structure**: NODE_GROUP_STRUCTURE.md\n- **Subcontracts**: omnibase_core/models/contracts/subcontracts/\n- **Base Contracts**: omnibase_core/models/contracts/model_contract_*.py\n- **Versioning**: SHARED_RESOURCE_VERSIONING.md\n\n---\n\n**Status**: \ud83d\udea7 Proposed Design - Ready for Review\n**Version**: 1.0.0\n**Last Updated**: 2025-10-01\n**Next Steps**: Review \u2192 Implement in omnibase_core \u2192 Update documentation",
                      "url": null,
                      "relevance_score": 0.41716355,
                      "semantic_score": 0.41716355,
                      "structural_score": null,
                      "source_id": null,
                      "project_id": null,
                      "created_at": null,
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    },
                    {
                      "entity_id": "doc_111439200485",
                      "entity_type": "page",
                      "title": "Onex Architecture Patterns Complete",
                      "content": "Onex Architecture Patterns Complete\n\n# ONEX Architecture Patterns - Complete Reference\n\n**Version**: 1.0.0\n**Generated**: 2025-10-01\n**Purpose**: Comprehensive ONEX patterns for AI-assisted development with hooks integration\n\n---\n\n## Core Architecture\n\n### 4-Node Architecture Pattern\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   EFFECT    \u2502\u2500\u2500\u2500\u25b6\u2502   COMPUTE   \u2502\u2500\u2500\u2500\u25b6\u2502   REDUCER   \u2502\u2500\u2500\u2500\u25b6\u2502ORCHESTRATOR \u2502\n\u2502   (Input)   \u2502    \u2502 (Process)   \u2502    \u2502(Aggregate)  \u2502    \u2502(Coordinate) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Unidirectional Data Flow**: EFFECT \u2192 COMPUTE \u2192 REDUCER \u2192 ORCHESTRATOR\n\n---\n\n## 1. Node Types\n\n### NodeEffect\n**Purpose**: Side effect management and external interactions\n**File Pattern**: `node_*_effect.py`\n**Contract**: `ModelContractEffect`\n\n**Responsibilities**:\n- I/O operations (file, database, API)\n- Transaction management with rollback\n- Retry policies and circuit breakers\n- Event emission\n- Metrics collection\n\n**Method Signature**:\n```python\nasync def execute_effect(self, contract: ModelContractEffect) -> Any:\n    \"\"\"Execute side effect with transaction support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Database writes\n- File operations\n- API calls\n- Event publishing\n\n---\n\n### NodeCompute\n**Purpose**: Pure computational operations\n**File Pattern**: `node_*_compute.py`\n**Contract**: `ModelContractCompute`\n\n**Responsibilities**:\n- Data transformations\n- Calculations and computations\n- Caching and memoization\n- Parallel processing\n- Pure functions (no side effects)\n\n**Method Signature**:\n```python\nasync def execute_compute(self, contract: ModelContractCompute) -> Any:\n    \"\"\"Execute computation with caching support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Data transformations\n- Calculations\n- Filtering/mapping\n- Validation logic\n\n---\n\n### NodeReducer\n**Purpose**: Data aggregation and state reduction\n**File Pattern**: `node_*_reducer.py`\n**Contract**: `ModelContractReducer`\n\n**Responsibilities**:\n- Data aggregation\n- State reduction\n- Conflict resolution\n- Streaming support\n- Statistical operations\n\n**Method Signature**:\n```python\nasync def execute_reduction(self, contract: ModelContractReducer) -> Any:\n    \"\"\"Execute reduction with streaming support.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Data aggregation\n- Statistics calculation\n- State merging\n- Report generation\n\n---\n\n### NodeOrchestrator\n**Purpose**: Workflow coordination\n**File Pattern**: `node_*_orchestrator.py`\n**Contract**: `ModelContractOrchestrator`\n\n**Responsibilities**:\n- Workflow coordination\n- Thunk emission\n- Dependency management\n- Pipeline orchestration\n- Error recovery\n\n**Method Signature**:\n```python\nasync def execute_orchestration(self, contract: ModelContractOrchestrator) -> Any:\n    \"\"\"Execute orchestration with dependency management.\"\"\"\n    pass\n```\n\n**Example Use Cases**:\n- Multi-step workflows\n- Pipeline coordination\n- Dependency resolution\n- Error recovery flows\n\n---\n\n## 2. Contract System\n\n### Base Contract\n**Class**: `ModelContractBase`\n**File Pattern**: `model_contract_base.py`\n\n**Core Fields**:\n- `name: str` - Contract identifier\n- `version: str` - Semantic version\n- `description: str` - Human-readable description\n- `node_type: EnumNodeType` - Node type (EFFECT/COMPUTE/REDUCER/ORCHESTRATOR)\n\n### Specialized Contracts\n\n1. **ModelContractEffect** - For EFFECT nodes\n2. **ModelContractCompute** - For COMPUTE nodes\n3. **ModelContractReducer** - For REDUCER nodes\n4. **ModelContractOrchestrator** - For ORCHESTRATOR nodes\n\n---\n\n## 3. Subcontract System\n\n**Pattern**: `Model<Type>Subcontract`\n**File Pattern**: `model_*_subcontract.py`\n\n### 6 Core Subcontract Types\n\n1. **ModelFSMSubcontract** - Finite State Machine functionality\n   - State transitions\n   - Event-driven state changes\n   - Guards and actions\n\n2. **ModelEventTypeSubcontract** - Event-driven architecture\n   - Event definitions\n   - Event handlers\n   - Pub/sub patterns\n\n3. **ModelAggregationSubcontract** - Data aggregation\n   - Aggregation strategies\n   - Statistical operations\n   - Group by operations\n\n4. **ModelStateManagementSubcontract** - State persistence\n   - State storage\n   - State synchronization\n   - State recovery\n\n5. **ModelRoutingSubcontract** - Request routing\n   - Load balancing\n   - Request routing\n   - Endpoint selection\n\n6. **ModelCachingSubcontract** - Performance optimization\n   - Cache strategies\n   - TTL management\n   - Cache invalidation\n\n---\n\n## 4. Naming Conventions\n\n### File Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Models | `model_<name>.py` | `model_task_data.py` |\n| Enums | `enum_<name>.py` | `enum_task_status.py` |\n| TypedDicts | `typed_dict_<name>.py` | `typed_dict_result_kwargs.py` |\n| Nodes | `node_<type>_<name>.py` | `node_effect_database.py` |\n| Contracts | `model_contract_<type>.py` | `model_contract_effect.py` |\n| Subcontracts | `model_<type>_subcontract.py` | `model_fsm_subcontract.py` |\n| Protocols | `protocol_<name>.py` | `protocol_event_bus.py` |\n\n### Class Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Pydantic Models | `Model<Name>` | `ModelTaskData` |\n| Enums | `Enum<Name>` | `EnumTaskStatus` |\n| TypedDicts | `TypedDict<Name>` | `TypedDictResultKwargs` |\n| Protocols | `Protocol<Name>` | `ProtocolEventBus` |\n| Nodes | `Node<Name><Type>` | `NodeDatabaseWriterEffect` |\n\n---\n\n## 5. Architecture Principles\n\n### Zero Tolerance for Any Types\n```python\n# \u2705 Correct - Strongly typed\ndef process_data(data: ModelTaskData) -> ModelResult:\n    pass\n\n# \u274c Incorrect - Using Any\ndef process_data(data: Any) -> Any:\n    pass\n```\n\n### Contract-Driven Development\n```python\n# \u2705 Correct - Contract defines behavior\nclass NodeDatabaseWriterEffect:\n    async def execute_effect(self, contract: ModelContractEffect) -> ModelResult:\n        # Implementation follows contract spec\n        pass\n```\n\n### Composition Over Inheritance\n```python\n# \u2705 Correct - Subcontract composition\ncontract = ModelContractEffect(\n    name=\"database_write\",\n    state_transitions=ModelFSMSubcontract(...),  # Compose FSM\n    caching=ModelCachingSubcontract(...)  # Compose caching\n)\n```\n\n### Unidirectional Data Flow\n```python\n# \u2705 Correct - Left to right flow\neffect_result = await effect_node.execute_effect(effect_contract)\ncompute_result = await compute_node.execute_compute(compute_contract)\nreducer_result = await reducer_node.execute_reduction(reducer_contract)\nfinal_result = await orchestrator.execute_orchestration(orch_contract)\n```\n\n---\n\n## 6. Quick Reference Templates\n\n### Creating an Effect Node\n```python\nfrom omnibase.core.models.contracts import ModelContractEffect\nfrom omnibase.core.nodes import NodeEffect\n\nclass NodeMyOperationEffect(NodeEffect):\n    \"\"\"My custom effect node.\"\"\"\n\n    async def execute_effect(self, contract: ModelContractEffect) -> ModelResult:\n        # Transaction management\n        async with self.transaction_manager.begin():\n            # Your side effect logic here\n            result = await self._perform_operation(contract)\n            return ModelResult(success=True, data=result)\n```\n\n### Creating a Compute Node\n```python\nfrom omnibase.core.models.contracts import ModelContractCompute\nfrom omnibase.core.nodes import NodeCompute\n\nclass NodeMyTransformCompute(NodeCompute):\n    \"\"\"My custom compute node.\"\"\"\n\n    async def execute_compute(self, contract: ModelContractCompute) -> ModelResult:\n        # Pure computation with caching\n        cached = self.cache.get(contract.cache_key)\n        if cached:\n            return cached\n\n        result = self._transform_data(contract.input_data)\n        self.cache.set(contract.cache_key, result)\n        return ModelResult(success=True, data=result)\n```\n\n### Contract YAML Template\n```yaml\nname: my_operation\nversion: 1.0.0\ndescription: \"My operation description\"\nnode_type: EFFECT  # or COMPUTE, REDUCER, ORCHESTRATOR\n\n# Optional subcontracts\nstate_transitions:\n  initial_state: PENDING\n  transitions:\n    - from: PENDING\n      to: PROCESSING\n      event: START\n    - from: PROCESSING\n      to: COMPLETED\n      event: FINISH\n\ncaching:\n  strategy: LRU\n  ttl_seconds: 3600\n  max_entries: 1000\n```\n\n---\n\n## 7. Best Practices\n\n### DO \u2705\n- Use unidirectional data flow (EFFECT \u2192 COMPUTE \u2192 REDUCER \u2192 ORCHESTRATOR)\n- Apply contract-driven development\n- Compose subcontracts for reusable functionality\n- Use strong typing (zero `Any` types)\n- Follow naming conventions consistently\n- Implement proper error handling and logging\n- Use UUID correlation IDs for tracing\n\n### DON'T \u274c\n- Skip contract validation\n- Use `Any` types in models\n- Create side effects in compute nodes\n- Break unidirectional flow\n- Mix responsibilities across node types\n- Hardcode configuration (use contracts)\n- Ignore transaction management in effects\n\n---\n\n## 8. Integration Checklist\n\nWhen creating new nodes:\n\n- [ ] Choose correct node type (Effect/Compute/Reducer/Orchestrator)\n- [ ] Follow file naming convention (`node_<type>_<name>.py`)\n- [ ] Follow class naming convention (`Node<Type><Name>`)\n- [ ] Create contract YAML with all required fields\n- [ ] Implement correct method signature (`execute_effect/compute/reduction/orchestration`)\n- [ ] Use appropriate subcontracts (FSM, caching, etc.)\n- [ ] Add proper error handling and logging\n- [ ] Include UUID correlation tracking\n- [ ] Write comprehensive tests\n- [ ] Document in contract YAML\n\n---\n\n**References**:\n- omnibase_core: Node implementations\n- omnibase_3: Contract and subcontract models\n- omnibase_infra: Production examples (PostgreSQL, Kafka adapters)",
                      "url": null,
                      "relevance_score": 0.4168243,
                      "semantic_score": 0.4168243,
                      "structural_score": null,
                      "source_id": null,
                      "project_id": null,
                      "created_at": null,
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    },
                    {
                      "entity_id": "doc_718927590691",
                      "entity_type": "page",
                      "title": "ONEX Implementation Guide",
                      "content": "ONEX Implementation Guide\n\n# ONEX Implementation Guide\n\n**Version**: 2.0.0\n**Status**: \u2705 Canonical Reference\n**Last Updated**: 2025-10-01\n**Purpose**: Comprehensive guide for implementing ONEX nodes and node groups\n\n---\n\n## \ud83d\udcd6 What to Read First\n\n**New to ONEX?** Start here:\n1. Read this guide's [Quick Start](#quick-start) section\n2. Review [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md) for patterns and examples\n3. Explore [examples/](examples/) directory for real implementations\n\n**Looking for specific info?**\n- **Directory structure** \u2192 [Structure Guide](#directory-structure)\n- **Base classes** \u2192 [Composed Base Classes](#composed-base-classes)\n- **Naming patterns** \u2192 [Naming Conventions](#naming-conventions)\n- **Shared resources** \u2192 [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md)\n- **Quick patterns** \u2192 [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md)\n\n---\n\n## \ud83d\ude80 Quick Start\n\n### 3-Tier Base Class System\n\nONEX provides **three levels** of base contracts for progressive enhancement:\n\n```python\n# Level 1: MINIMAL (advanced use cases)\nfrom omnibase_core.models.contracts import ModelContractEffect\n\n# Level 2: STANDARD (recommended for most nodes) \u2b50\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\n# Level 3: FULL (complex infrastructure nodes)\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n```\n\n**Use Standard for 90% of nodes** - includes common operational patterns like service resolution, health monitoring, performance tracking, and configuration management.\n\n### Creating Your First Node\n\n```python\n#!/usr/bin/env python3\n\"\"\"My Effect Node - Production-ready with standard patterns.\"\"\"\n\nfrom pathlib import Path\nfrom omnibase.constants.contract_constants import CONTRACT_FILENAME\nfrom omnibase.core.node_base import NodeBase\nfrom omnibase.core.node_effect import NodeEffect\nfrom omnibase_core.models.core import ModelOnexContainer\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nfrom .models.model_input_state import ModelMyNodeInputState\nfrom .models.model_output_state import ModelMyNodeOutputState\n\n\nclass ToolMyNodeProcessor(NodeEffect):\n    \"\"\"\n    My production Effect node using Standard composition.\n\n    Automatically includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n        # Your initialization here\n\n    async def execute_effect(\n        self, contract: ModelContractEffectStandard\n    ) -> ModelMyNodeOutputState:\n        \"\"\"Main processing method.\"\"\"\n        # Your business logic here\n        pass\n\n\ndef main():\n    \"\"\"One-line main function.\"\"\"\n    return NodeBase(Path(__file__).parent / CONTRACT_FILENAME)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n## \ud83d\udcc1 Directory Structure\n\n### Minimum Viable Structure\n\n**Use this** for new nodes (production-ready):\n\n```\n<node_group>/                           # e.g., \"canary\"\n\u251c\u2500\u2500 __init__.py                         # Group package\n\u251c\u2500\u2500 README.md                           # Main documentation\n\u2502\n\u251c\u2500\u2500 deployment/                         # Deployment configs\n\u2502   \u251c\u2500\u2500 docker-compose.<group>.yml\n\u2502   \u2514\u2500\u2500 *.env files\n\u2502\n\u2514\u2500\u2500 <node_name>/                        # e.g., \"my_tool\"\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 v1_0_0/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 node.py                     # ONLY node class + main()\n        \u2502\n        \u251c\u2500\u2500 contract.yaml               # Main interface\n        \u251c\u2500\u2500 node_config.yaml            # Runtime config\n        \u251c\u2500\u2500 deployment_config.yaml      # Deployment config\n        \u2502\n        \u251c\u2500\u2500 contracts/                  # YAML subcontracts\n        \u2502   \u251c\u2500\u2500 contract_actions.yaml\n        \u2502   \u251c\u2500\u2500 contract_cli.yaml\n        \u2502   \u251c\u2500\u2500 contract_examples.yaml\n        \u2502   \u2514\u2500\u2500 contract_models.yaml\n        \u2502\n        \u2514\u2500\u2500 models/                     # Node-specific models\n            \u251c\u2500\u2500 __init__.py\n            \u251c\u2500\u2500 model_input_state.py\n            \u2514\u2500\u2500 model_output_state.py\n```\n\n### Maximum Recommended Structure\n\n**Evolve to this** as needs arise (best practices):\n\n```\n<node_group>/                           # e.g., \"canary\"\n\u2502\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 API_REFERENCE.md\n\u251c\u2500\u2500 compatibility.yaml                  # Version compatibility matrix\n\u2502\n\u251c\u2500\u2500 shared/                             # LAZY: Only when 2+ nodes share\n\u2502   \u251c\u2500\u2500 models/                         # Independent versioning\n\u2502   \u2502   \u251c\u2500\u2500 v1/                         # Major version 1 (stable)\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 model_*.py\n\u2502   \u2502   \u2514\u2500\u2500 v2/                         # Major version 2 (breaking changes)\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py\n\u2502   \u2502       \u2514\u2500\u2500 model_*.py\n\u2502   \u2514\u2500\u2500 protocols/                      # Shared protocols (if needed)\n\u2502       \u251c\u2500\u2500 v1/\n\u2502       \u2514\u2500\u2500 v2/\n\u2502\n\u251c\u2500\u2500 tests/                              # Group-level integration tests\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2502   \u2514\u2500\u2500 test_node_interactions.py\n\u2502   \u2514\u2500\u2500 fixtures/\n\u2502\n\u251c\u2500\u2500 deployment/\n\u2502   \u251c\u2500\u2500 docker-compose.<group>.yml\n\u2502   \u2514\u2500\u2500 *.env files\n\u2502\n\u2514\u2500\u2500 <node_name>/                        # e.g., \"my_tool\"\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 v1_0_0/\n        \u251c\u2500\u2500 README.md                   # Node documentation\n        \u251c\u2500\u2500 CHANGELOG.md                # Version history\n        \u251c\u2500\u2500 node.py                     # ONLY node class + main()\n        \u2502\n        \u251c\u2500\u2500 contract.yaml               # Main interface\n        \u251c\u2500\u2500 node_config.yaml\n        \u251c\u2500\u2500 deployment_config.yaml\n        \u251c\u2500\u2500 state_transitions.yaml      # State machine (if needed)\n        \u251c\u2500\u2500 workflow_testing.yaml       # Testing workflows (if needed)\n        \u251c\u2500\u2500 security_config.yaml        # Security (Effect nodes)\n        \u2502\n        \u251c\u2500\u2500 contracts/                  # YAML subcontracts\n        \u2502   \u251c\u2500\u2500 contract_actions.yaml\n        \u2502   \u251c\u2500\u2500 contract_cli.yaml\n        \u2502   \u251c\u2500\u2500 contract_examples.yaml\n        \u2502   \u251c\u2500\u2500 contract_models.yaml\n        \u2502   \u2514\u2500\u2500 contract_validation.yaml\n        \u2502\n        \u251c\u2500\u2500 models/                     # Node-specific models\n        \u2502   \u251c\u2500\u2500 __init__.py\n        \u2502   \u251c\u2500\u2500 model_input_state.py\n        \u2502   \u251c\u2500\u2500 model_output_state.py\n        \u2502   \u2514\u2500\u2500 enum_*.py\n        \u2502\n        \u251c\u2500\u2500 protocols/                  # Node-specific protocols\n        \u2502   \u251c\u2500\u2500 __init__.py\n        \u2502   \u2514\u2500\u2500 protocol_<node>.py\n        \u2502\n        \u251c\u2500\u2500 tests/                      # Node unit tests\n        \u2502   \u251c\u2500\u2500 unit/\n        \u2502   \u2502   \u2514\u2500\u2500 test_node.py\n        \u2502   \u2514\u2500\u2500 fixtures/\n        \u2502\n        \u2514\u2500\u2500 mock_configurations/        # Testing mocks (optional)\n            \u251c\u2500\u2500 event_bus_mock_behaviors.yaml\n            \u251c\u2500\u2500 llm_mock_responses.yaml\n            \u2514\u2500\u2500 uuid_mock_behaviors.yaml\n```\n\n---\n\n## \ud83c\udfaf Core Principles\n\n### 1. Composed Base Classes (Recommended Approach) \u2b50\n\n**Use pre-composed base classes** that aggregate common subcontract patterns:\n\n#### Three Levels of Composition\n\n```\nModelContract{Type} (minimal)           \u2190 Advanced use cases\n    \u2193\nModelContract{Type}Standard (common)    \u2190 90% of nodes \u2b50\n    \u2193\nModelContract{Type}Full (complete)      \u2190 Complex infrastructure\n```\n\n#### When to Use Each Level\n\n| Level | Use When | Example |\n|-------|----------|---------|\n| **Minimal** | Custom subcontract composition needed | Specialized nodes |\n| **Standard** \u2b50 | Most production nodes | API clients, file processors |\n| **Full** | Complex infrastructure nodes | Database connectors, message brokers |\n\n**Recommendation**: Start with **Standard**, downgrade to Minimal only if you need custom composition.\n\n### 2. Lazy Promotion for Shared Resources\n\n**Don't create `shared/` upfront**. Follow this progression:\n\n```\nPhase 1: Model in node\nnode_1/v1_0_0/models/model_data.py\n\nPhase 2: Second node needs it \u2192 Promote to shared/v1/\nshared/models/v1/model_data.py\nnode_1/v1_0_0/  # updates imports\nnode_2/v1_0_0/  # uses shared version\n\nPhase 3: Breaking change needed \u2192 Create v2\nshared/models/v1/model_data.py  # Old version (frozen)\nshared/models/v2/model_data.py  # New version (breaking changes)\n```\n\n**Promotion Criteria** (ALL must be true):\n1. \u2705 Actually used by 2+ consumers (not \"might be\")\n2. \u2705 Same semantic meaning across consumers\n3. \u2705 Same version lifecycle requirements\n4. \u2705 Detected by duplication analysis (not speculative)\n\nSee [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md) for complete details.\n\n### 3. Protocols: Hybrid Approach\n\n**Both locations are valid** based on scope:\n\n| Protocol Scope | Location | Example |\n|----------------|----------|---------|\n| Node-specific | `node/v1_0_0/protocols/` | `protocol_my_node.py` |\n| Shared (2+ nodes) | `shared/protocols/v1/` | `protocol_common.py` |\n| Framework-wide | `omnibase_spi/protocols/` | `ProtocolOnexNode` |\n\n**Start node-local**, promote when actually shared.\n\n### 4. Container Type: ModelOnexContainer Only\n\n**Always use ModelOnexContainer** (proper Pydantic container):\n\n```python\n# \u2705 CORRECT\nfrom omnibase_core.models.core import ModelOnexContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ModelOnexContainer) -> None:\n        super().__init__(container)\n```\n\n```python\n# \u274c WRONG - Legacy technical debt\nfrom omnibase.core.onex_container import ONEXContainer\n```\n\n### 5. Node.py Purity\n\n**node.py contains ONLY**:\n- \u2705 One node class (Effect/Compute/Reducer/Orchestrator)\n- \u2705 main() function (one-liner)\n- \u2705 Class-level constants (if needed)\n- \u274c NO other classes\n- \u274c NO enums (use `models/enum_*.py`)\n- \u274c NO helper functions (use separate modules)\n\n### 6. Independent Node Versioning\n\n\u2705 Each node has `v1_0_0/`, `v2_0_0/`, etc.\n\u2705 Nodes evolve independently\n\u2705 Use `compatibility.yaml` to track which versions work together\n\u274c NO group-level versioning (breaks independence)\n\n---\n\n## \ud83c\udfa8 Composed Base Classes\n\n### Overview\n\nPre-composed base classes provide **zero-boilerplate** operational patterns:\n\n```python\n# Instead of manually composing subcontracts...\nclass ModelContractEffect(ModelContractBase):\n    service_resolution: ModelServiceResolutionSubcontract | None = None\n    health_check: ModelHealthCheckSubcontract | None = None\n    performance_monitoring: ModelPerformanceMonitoringSubcontract | None = None\n    configuration: ModelConfigurationSubcontract | None = None\n    # ... etc (boilerplate!)\n\n# Use pre-composed Standard for common patterns:\nclass ModelContractEffectStandard(ModelContractEffect):\n    # All common subcontracts included with sensible defaults!\n```\n\n### Effect Node Compositions\n\n#### ModelContractEffectStandard \u2b50\n**Common patterns for typical Effect nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass ToolProductionAPIClient(NodeEffect):\n    \"\"\"\n    Production Effect node with standard operational patterns.\n\n    Automatically includes:\n    - Service resolution (dependency injection)\n    - Health monitoring\n    - Performance tracking\n    - Configuration management\n    - Request/response patterns\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `service_resolution` - Service discovery and DI\n- \u2705 `health_check` - Health monitoring\n- \u2705 `performance_monitoring` - Performance metrics\n- \u2705 `configuration` - Configuration management\n- \u2705 `request_response` - Request/response patterns\n- Plus inherited: `event_type`, `caching`, `routing`\n\n#### ModelContractEffectFull\n**All applicable Effect subcontracts**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractEffectFull\n\nclass ToolDatabaseConnector(NodeEffect):\n    \"\"\"\n    Complex infrastructure node with all operational capabilities.\n\n    Includes Standard features PLUS:\n    - External dependencies tracking\n    - Runtime introspection\n    - State management\n    - FSM patterns\n    \"\"\"\n```\n\n**Adds to Standard**:\n- \u2705 `external_dependencies` - External dependency management\n- \u2705 `introspection` - Runtime introspection\n- \u2705 `state_management` - Advanced state management (optional)\n- \u2705 `fsm` - Finite state machine patterns (optional)\n\n### Compute Node Compositions\n\n#### ModelContractComputeStandard \u2b50\n**Common patterns for typical Compute nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractComputeStandard\n\nclass ToolDataTransformer(NodeCompute):\n    \"\"\"\n    Standard Compute node with performance optimization patterns.\n\n    Includes:\n    - Caching (critical for pure functions)\n    - Performance monitoring\n    - Configuration management\n    - Health checks\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `caching` - Result caching for pure computations\n- \u2705 `performance_monitoring` - Computation performance tracking\n- \u2705 `configuration` - Algorithm configuration\n- \u2705 `health_check` - Computation health monitoring\n\n#### ModelContractComputeFull\n**All applicable Compute subcontracts**\n\n**Adds to Standard**:\n- \u2705 `service_resolution` - External data source resolution (optional)\n- \u2705 `request_response` - Request/response patterns (optional)\n- \u2705 `introspection` - Runtime introspection (optional)\n\n### Reducer Node Compositions\n\n#### ModelContractReducerStandard \u2b50\n**Common patterns for typical Reducer nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractReducerStandard\n\nclass ToolDataAggregator(NodeReducer):\n    \"\"\"\n    Standard Reducer node with aggregation patterns.\n\n    Includes:\n    - Aggregation (core reducer functionality)\n    - State management\n    - Caching\n    - Performance monitoring\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `aggregation` - Data aggregation strategies\n- \u2705 `state_management` - Aggregation state management\n- \u2705 `caching` - Aggregation result caching\n- \u2705 `performance_monitoring` - Aggregation performance tracking\n\n### Orchestrator Node Compositions\n\n#### ModelContractOrchestratorStandard \u2b50\n**Common patterns for typical Orchestrator nodes**\n\n```python\nfrom omnibase_core.models.contracts import ModelContractOrchestratorStandard\n\nclass ToolWorkflowCoordinator(NodeOrchestrator):\n    \"\"\"\n    Standard Orchestrator node with workflow coordination.\n\n    Includes:\n    - Workflow coordination (core orchestrator functionality)\n    - Routing\n    - Service resolution\n    - Health monitoring\n    - Event coordination\n    \"\"\"\n```\n\n**Included Subcontracts**:\n- \u2705 `workflow_coordination` - Multi-node workflow coordination\n- \u2705 `routing` - Node routing and load balancing\n- \u2705 `service_resolution` - Node and service discovery\n- \u2705 `event_type` - Event-driven orchestration\n- \u2705 `health_check` - Orchestration health monitoring\n\n#### ModelContractOrchestratorFull\n**All applicable Orchestrator subcontracts**\n\n**Adds to Standard**:\n- \u2705 `fsm` - State machine-based workflow control\n- \u2705 `state_management` - Workflow state management\n- \u2705 `performance_monitoring` - Orchestration performance tracking\n- \u2705 `configuration` - Workflow configuration management\n\n### Subcontract-to-Node Type Matrix\n\n| Subcontract | Effect | Compute | Reducer | Orchestrator |\n|------------|--------|---------|---------|--------------|\n| **ServiceResolution** | \u2705 Standard | Optional | Optional | \u2705 Standard |\n| **HealthCheck** | \u2705 Standard | \u2705 Standard | \u2705 Standard | \u2705 Standard |\n| **PerformanceMonitoring** | \u2705 Standard | \u2705 Standard | \u2705 Standard | Optional |\n| **Configuration** | \u2705 Standard | \u2705 Standard | Optional | Optional |\n| **RequestResponse** | \u2705 Standard | Optional | \u274c | \u274c |\n| **Caching** | Optional | \u2705 Standard | \u2705 Standard | \u274c |\n| **EventType** | Optional | \u274c | \u274c | \u2705 Standard |\n| **Routing** | Optional | \u274c | \u274c | \u2705 Standard |\n| **WorkflowCoordination** | \u274c | \u274c | \u274c | \u2705 Standard |\n| **Aggregation** | \u274c | \u274c | \u2705 Standard | \u274c |\n| **StateManagement** | Optional | \u274c | \u2705 Standard | Optional |\n| **FSM** | Optional | \u274c | \u274c | Optional |\n| **ExternalDependencies** | Optional | Optional | \u274c | \u274c |\n| **Introspection** | Optional | Optional | \u274c | \u274c |\n\n**Legend**:\n- \u2705 Standard: Included in `{Type}Standard` composition\n- Optional: Available in `{Type}Full` or can be added manually\n- \u274c: Not applicable to this node type\n\n---\n\n## \ud83d\udcdd Naming Conventions\n\n### File Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Nodes | `node_<name>_<type>.py` | `node_database_writer_effect.py` |\n| Models | `model_<name>.py` | `model_task_data.py` |\n| Enums | `enum_<name>.py` | `enum_task_status.py` |\n| Contracts | `model_contract_<type>.py` | `model_contract_effect.py` |\n| Subcontracts | `model_<type>_subcontract.py` | `model_fsm_subcontract.py` |\n| Protocols | `protocol_<name>.py` | `protocol_event_bus.py` |\n\n### Class Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Nodes | `Node<Name><Type>` | `NodeDatabaseWriterEffect` |\n| Models | `Model<Name>` | `ModelTaskData` |\n| Enums | `Enum<Name>` | `EnumTaskStatus` |\n| Contracts | `ModelContract<Type>` | `ModelContractEffect` |\n| Subcontracts | `Model<Type>Subcontract` | `ModelFSMSubcontract` |\n| Protocols | `Protocol<Name>` | `ProtocolEventBus` |\n\n**Key Point**: Naming is **SUFFIX-based** - the type comes LAST:\n- `NodeDatabaseWriter**Effect**` (not `NodeEffectDatabaseWriter`)\n- `node_database_writer_**effect**.py` (not `node_effect_database_writer.py`)\n\n---\n\n## \ud83d\udd27 Framework Components\n\n### DO NOT DUPLICATE\n\nThese are imported from `omnibase_core`:\n\n#### Base Contracts\n```python\nfrom omnibase_core.models.contracts import (\n    ModelContractBase,\n    ModelContractEffect,\n    ModelContractCompute,\n    ModelContractReducer,\n    ModelContractOrchestrator,\n)\n```\n\n#### Composed Base Contracts \u2b50\n```python\nfrom omnibase_core.models.contracts import (\n    ModelContractEffectStandard,\n    ModelContractEffectFull,\n    ModelContractComputeStandard,\n    ModelContractComputeFull,\n    ModelContractReducerStandard,\n    ModelContractOrchestratorStandard,\n    ModelContractOrchestratorFull,\n)\n```\n\n#### Subcontracts\n```python\nfrom omnibase_core.models.contracts.subcontracts import (\n    ModelFSMSubcontract,\n    ModelEventTypeSubcontract,\n    ModelAggregationSubcontract,\n    ModelStateManagementSubcontract,\n    ModelRoutingSubcontract,\n    ModelCachingSubcontract,\n    ModelServiceResolutionSubcontract,\n    ModelHealthCheckSubcontract,\n    ModelPerformanceMonitoringSubcontract,\n    ModelConfigurationSubcontract,\n    ModelRequestResponseSubcontract,\n    ModelExternalDependenciesSubcontract,\n    ModelIntrospectionSubcontract,\n    ModelWorkflowCoordinationSubcontract,\n)\n```\n\n#### Container\n```python\nfrom omnibase_core.models.core import ModelOnexContainer\n```\n\n---\n\n## \u274c Anti-Patterns\n\n### 1. Premature Shared Resources\n\n```\n# \u274c WRONG - Creating shared/ upfront\nnode_group/\n\u251c\u2500\u2500 shared/\n\u2502   \u2514\u2500\u2500 models/v1/      # Created \"just in case\"\n\u2502       \u2514\u2500\u2500 model_*.py  # No nodes use it yet\n\n# \u2705 CORRECT - Start with node-level models\nnode_group/\n\u2514\u2500\u2500 node_1/\n    \u2514\u2500\u2500 v1_0_0/\n        \u2514\u2500\u2500 models/\n            \u2514\u2500\u2500 model_*.py  # Only promote when 2+ nodes need it\n```\n\n### 2. Using Minimal When Standard Would Work\n\n```python\n# \u274c WRONG - Manual composition when Standard exists\nfrom omnibase_core.models.contracts import ModelContractEffect\n\nclass MyNode(NodeEffect):\n    # Manually adding all standard subcontracts...\n    # (boilerplate repetition!)\n\n# \u2705 CORRECT - Use Standard composition\nfrom omnibase_core.models.contracts import ModelContractEffectStandard\n\nclass MyNode(NodeEffect):\n    # All standard subcontracts included automatically!\n```\n\n### 3. Multiple Classes in node.py\n\n```python\n# \u274c WRONG - Multiple classes in node.py\nclass MyDataModel(BaseModel):      # Should be in models/\n    pass\n\nclass MyEnum(Enum):                 # Should be in models/\n    pass\n\nclass MyNode(NodeEffect):           # Only this should be in node.py\n    pass\n\n# \u2705 CORRECT - One class in node.py\n# node.py\nfrom .models.model_data import MyDataModel\nfrom .models.enum_status import MyEnum\n\nclass MyNode(NodeEffect):\n    pass\n```\n\n### 4. Using Legacy Container\n\n```python\n# \u274c WRONG - Legacy container (technical debt)\nfrom omnibase.core.onex_container import ONEXContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ONEXContainer) -> None:\n        pass\n\n# \u2705 CORRECT - Proper Pydantic container\nfrom omnibase_core.models.core import ModelOnexContainer\n\nclass MyNode(NodeEffect):\n    def __init__(self, container: ModelOnexContainer) -> None:\n        pass\n```\n\n### 5. Group-Level Versioning\n\n```\n# \u274c WRONG - Version at group level\nnode_group/\n\u2514\u2500\u2500 v1_0_0/         # Breaks independent node evolution\n    \u251c\u2500\u2500 node_1/\n    \u2514\u2500\u2500 node_2/\n\n# \u2705 CORRECT - Version per node\nnode_group/\n\u251c\u2500\u2500 node_1/\n\u2502   \u2514\u2500\u2500 v1_0_0/    # Independent versioning\n\u2514\u2500\u2500 node_2/\n    \u2514\u2500\u2500 v2_0_0/    # Can be different version\n```\n\n### 6. Premature Protocol Promotion\n\n```\n# \u274c WRONG - Moving protocol to omnibase_spi prematurely\nomnibase_spi/protocols/\n\u2514\u2500\u2500 protocol_experimental.py  # Only one node uses it!\n\n# \u2705 CORRECT - Keep in node until actually shared\nnode/v1_0_0/protocols/\n\u2514\u2500\u2500 protocol_experimental.py  # Promote when 2+ nodes need it\n```\n\n---\n\n## \ud83d\udd04 Migration Strategy\n\n### From Current to Best Practices\n\n**Phase 1: Adopt Composed Base Classes**\n1. \u2705 Update imports to use `ModelContract{Type}Standard`\n2. \u2705 Remove manual subcontract composition\n3. \u2705 Update contract YAML with `composed_type: \"standard\"`\n4. \u2705 Test that all subcontracts work as expected\n\n**Phase 2: Add Structure**\n1. \ud83c\udd95 Add `compatibility.yaml` at group level\n2. \ud83c\udd95 Add `README.md` + `CHANGELOG.md` per node\n3. \ud83c\udd95 Add `tests/` directories (explicit structure)\n4. \ud83c\udd95 Add node-level documentation\n\n**Phase 3: Lazy Promotion (when needed)**\n1. \u23f8\ufe0f Monitor for duplicate models/protocols\n2. \u23f8\ufe0f Create `shared/models/v1/` when 2nd node needs it\n3. \u23f8\ufe0f Create `shared/models/v2/` when breaking changes needed\n4. \u23f8\ufe0f Promote protocols to `omnibase_spi` when truly framework-wide\n\n### Migration Scripts\n\n**Required tooling**:\n1. `scripts/detect_duplicate_models.py` - Find models to promote\n2. `scripts/validate_compatibility.py` - Check version matrix\n3. `scripts/generate_docs.py` - Auto-gen from contracts\n4. `scripts/migrate_to_standard.py` - Convert to Standard base classes\n\n---\n\n## \ud83d\udee0\ufe0f Tooling Support\n\n### Duplication Detection\n```bash\n# Find models/protocols that should be promoted\npython scripts/detect_duplicate_models.py --group canary\n```\n\n### Compatibility Validation\n```bash\n# Validate version compatibility matrix\npython scripts/validate_compatibility.py --all\n```\n\n### Documentation Generation\n```bash\n# Auto-generate API_REFERENCE.md from contracts\npython scripts/generate_docs.py --group canary --format markdown\n```\n\n### CLI Tools\n```bash\n# Create new node with Standard template\nonex create node --type effect --template standard --name my_tool\n\n# Validate node structure\nonex validate node --path ./my_tool/v1_0_0/\n\n# Promote model to shared\nonex promote model --model model_data --to shared/v1/\n```\n\n---\n\n## \ud83d\udcda References\n\n**Related Documentation**:\n- [ONEX_QUICK_REFERENCE.md](ONEX_QUICK_REFERENCE.md) - Patterns and examples\n- [SHARED_RESOURCE_VERSIONING.md](SHARED_RESOURCE_VERSIONING.md) - Versioning strategy\n- [examples/](examples/) - Real implementation examples\n\n**Framework Code**:\n- `omnibase_core/models/contracts/` - Base and composed contracts\n- `omnibase_core/models/contracts/subcontracts/` - All subcontracts\n- `omnibase_core/models/core/` - ModelOnexContainer\n- `omnibase_spi/protocols/` - Framework-wide protocols\n\n**Reference Implementations**:\n- `omnibase_3/src/omnibase/tools/canary/` - Production node group\n\n---\n\n## \ud83d\udccb Quick Checklist\n\n### Creating a New Node\n\n- [ ] Choose correct node type (Effect/Compute/Reducer/Orchestrator)\n- [ ] Use **Standard** composed base class (not minimal)\n- [ ] Follow file naming: `node_<name>_<type>.py`\n- [ ] Follow class naming: `Node<Name><Type>`\n- [ ] Use ModelOnexContainer (not ONEXContainer)\n- [ ] One class per node.py (no enums, no helpers)\n- [ ] Create contract.yaml with all required fields\n- [ ] Keep models node-local (promote when 2+ nodes need)\n- [ ] Keep protocols node-local (promote when actually shared)\n- [ ] Add comprehensive tests\n- [ ] Document in README.md and CHANGELOG.md\n\n### Before Promoting to Shared\n\n- [ ] Actually used by 2+ nodes (not \"might be\")\n- [ ] Same semantic meaning across consumers\n- [ ] Same version lifecycle requirements\n- [ ] Detected by duplication analysis\n- [ ] Use `shared/models/v1/` (major version only)\n- [ ] Update imports in all consuming nodes\n- [ ] Add tests for shared resource\n\n---\n\n**Status**: \u2705 Canonical Reference\n**Version**: 2.0.0\n**Last Updated**: 2025-10-01\n**Key Feature**: Composed base classes (Standard/Full) as recommended approach",
                      "url": null,
                      "relevance_score": 0.40979397,
                      "semantic_score": 0.40979397,
                      "structural_score": null,
                      "source_id": null,
                      "project_id": null,
                      "created_at": null,
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    }
                  ],
                  "query": "contract-driven development patterns"
                },
                "knowledge_graph": {
                  "success": true,
                  "source": "memgraph_knowledge_graph",
                  "results": [],
                  "query": "contract-driven development patterns",
                  "search_terms": [
                    "contract-driven",
                    "development",
                    "patterns"
                  ]
                }
              },
              "synthesis": {
                "key_findings": [
                  "Identified 5 semantically similar items"
                ],
                "patterns_identified": [
                  "Vector search found 5 semantically related items"
                ],
                "recommended_actions": [
                  "Check RAG results for API documentation and best practices",
                  "Review similar API implementations from vector search"
                ],
                "cross_source_connections": [],
                "confidence_score": 0.5,
                "ecosystem_insights": [
                  "Cross-referenced patterns across omninode ecosystem projects",
                  "4-node architecture compliance and implementation patterns",
                  "Integration opportunities between omniagent/omnimcp components",
                  "Architectural consistency analysis across ecosystem"
                ],
                "cross_project_scope": "Searched across entire omninode ecosystem including omnibase-core, omnibase-spi, omniagent, omnimcp",
                "ecosystem_integration_opportunities": [
                  "Identify shared patterns between omnibase components",
                  "Leverage 4-node architecture across ecosystem projects",
                  "Optimize cross-component communication patterns"
                ]
              }
            },
            "implementation_patterns": {
              "success": true,
              "query": "API contract validation",
              "context": "api_development",
              "timestamp": "2025-10-06T15:13:10.932545",
              "duration_ms": 2411,
              "sources_queried": [
                "RAG/Enhanced Search",
                "Qdrant Vector DB",
                "Memgraph Knowledge Graph"
              ],
              "sources_successful": [
                "RAG",
                "Vector Search",
                "Knowledge Graph"
              ],
              "total_results": 5,
              "results": {
                "rag_search": {
                  "success": true,
                  "source": "rag_search",
                  "results": [],
                  "query": "API contract validation",
                  "reranked": false
                },
                "vector_search": {
                  "success": true,
                  "source": "qdrant_vector_search",
                  "results": [
                    {
                      "entity_id": "doc_189357934837",
                      "entity_type": "page",
                      "title": "ModelContractBase - ONEX Contract Base Class",
                      "content": "ModelContractBase - ONEX Contract Base Class\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                      "url": null,
                      "relevance_score": 0.4902236,
                      "semantic_score": 0.4902236,
                      "structural_score": null,
                      "source_id": null,
                      "project_id": null,
                      "created_at": null,
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    },
                    {
                      "entity_id": "doc_813963796165",
                      "entity_type": "page",
                      "title": "ONEX Example: model_contract_base",
                      "content": "ONEX Example: model_contract_base\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                      "url": null,
                      "relevance_score": 0.48997834,
                      "semantic_score": 0.48997834,
                      "structural_score": null,
                      "source_id": null,
                      "project_id": null,
                      "created_at": null,
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    },
                    {
                      "entity_id": "doc_813963796165",
                      "entity_type": "page",
                      "title": "ONEX Example: model_contract_base",
                      "content": "ONEX Example: model_contract_base\n\n\"\"\"\nContract Model Base - ONEX Standards Compliant.\n\nAbstract foundation for 4-node architecture contract models providing:\n- Core contract identification and versioning\n- Node type classification with EnumNodeType\n- Input/output model specifications with generic typing\n- Performance requirements and lifecycle management\n- Validation rules and constraint definitions\n\nZERO TOLERANCE: No Any types allowed in implementation.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import cast\n\nfrom pydantic import BaseModel, ConfigDict, Field, field_validator\n\nfrom omnibase_core.enums import EnumNodeType\nfrom omnibase_core.enums.enum_core_error_code import EnumCoreErrorCode\nfrom omnibase_core.enums.enum_dependency_type import EnumDependencyType\nfrom omnibase_core.exceptions.onex_error import OnexError\nfrom omnibase_core.models.common.model_error_context import ModelErrorContext\nfrom omnibase_core.models.common.model_schema_value import ModelSchemaValue\nfrom omnibase_core.models.contracts.model_dependency import ModelDependency\nfrom omnibase_core.models.contracts.model_lifecycle_config import ModelLifecycleConfig\nfrom omnibase_core.models.contracts.model_performance_requirements import (\n    ModelPerformanceRequirements,\n)\nfrom omnibase_core.models.contracts.model_validation_rules import ModelValidationRules\nfrom omnibase_core.models.metadata.model_semver import ModelSemVer\n\n\nclass ModelContractBase(BaseModel, ABC):\n    \"\"\"\n    Abstract base for 4-node architecture contract models.\n\n    Provides common contract fields, node type classification,\n    and foundational configuration for all specialized contract models.\n\n    ZERO TOLERANCE: No Any types allowed in implementation.\n    \"\"\"\n\n    # Core contract identification\n    name: str = Field(\n        ...,\n        description=\"Unique contract name for identification\",\n        min_length=1,\n    )\n\n    version: ModelSemVer = Field(\n        ...,\n        description=\"Semantic version following SemVer specification\",\n    )\n\n    description: str = Field(\n        ...,\n        description=\"Human-readable contract description\",\n        min_length=1,\n    )\n\n    node_type: EnumNodeType = Field(\n        ...,\n        description=\"Node type classification for 4-node architecture\",\n    )\n\n    # Model specifications with strong typing\n    input_model: str = Field(\n        ...,\n        description=\"Fully qualified input model class name\",\n        min_length=1,\n    )\n\n    output_model: str = Field(\n        ...,\n        description=\"Fully qualified output model class name\",\n        min_length=1,\n    )\n\n    # Performance requirements\n    performance: ModelPerformanceRequirements = Field(\n        default_factory=ModelPerformanceRequirements,\n        description=\"Performance SLA specifications\",\n    )\n\n    # Lifecycle management\n    lifecycle: ModelLifecycleConfig = Field(\n        default_factory=ModelLifecycleConfig,\n        description=\"Lifecycle management configuration\",\n    )\n\n    # Dependencies and protocols\n    dependencies: list[ModelDependency] = Field(\n        default_factory=list,\n        description=\"Required protocol dependencies with structured specification\",\n        max_length=100,  # Prevent memory issues with extensive dependency lists\n    )\n\n    protocol_interfaces: list[str] = Field(\n        default_factory=list,\n        description=\"Protocol interfaces implemented by this contract\",\n    )\n\n    # Validation and constraints\n    validation_rules: ModelValidationRules = Field(\n        default_factory=ModelValidationRules,\n        description=\"Contract validation rules and constraints\",\n    )\n\n    # Metadata and documentation\n    author: str | None = Field(\n        default=None,\n        description=\"Contract author information\",\n    )\n\n    documentation_url: str | None = Field(\n        default=None,\n        description=\"URL to detailed contract documentation\",\n    )\n\n    tags: list[str] = Field(\n        default_factory=list,\n        description=\"Contract classification tags\",\n    )\n\n    @staticmethod\n    def _create_error_context(context_dict: dict[str, object]) -> ModelErrorContext:\n        \"\"\"\n        Helper method to create ModelErrorContext from context dictionary.\n\n        Args:\n            context_dict: Dictionary with error context information\n\n        Returns:\n            ModelErrorContext instance with converted values\n        \"\"\"\n        schema_values = {\n            key: ModelSchemaValue.from_value(value)\n            for key, value in context_dict.items()\n        }\n        return ModelErrorContext.with_context(schema_values)\n\n    @abstractmethod\n    def validate_node_specific_config(self) -> None:\n        \"\"\"\n        Validate node-specific configuration requirements.\n\n        Each specialized contract model must implement this method\n        to validate their specific configuration requirements.\n\n        Raises:\n            ValidationError: If node-specific validation fails\n        \"\"\"\n\n    def model_post_init(self, __context: object) -> None:\n        \"\"\"\n        Post-initialization validation for contract compliance.\n\n        Performs base validation and delegates to node-specific validation.\n        \"\"\"\n        # Validate that node type matches contract specialization\n        self._validate_node_type_compliance()\n\n        # Validate protocol dependencies exist\n        self._validate_protocol_dependencies()\n\n        # Validate dependency graph for circular dependencies\n        self._validate_dependency_graph()\n\n        # Delegate to node-specific validation\n        self.validate_node_specific_config()\n\n    @field_validator(\"dependencies\", mode=\"before\")\n    @classmethod\n    def validate_dependencies_model_dependency_only(\n        cls,\n        v: object,\n    ) -> list[ModelDependency]:\n        \"\"\"Validate dependencies with optimized batch processing.\n\n        ZERO TOLERANCE for runtime: Only ModelDependency objects.\n        YAML EXCEPTION: Allow dict conversion only during YAML contract loading.\n        MEMORY SAFETY: Enforce maximum dependencies limit to prevent resource exhaustion.\n        SECURITY: Reject string dependencies with clear actionable error messages.\n        PERFORMANCE: Batch validation for large dependency lists.\n        \"\"\"\n        if not v:\n            return []\n\n        # Perform basic validation checks\n        cls._validate_dependencies_basic_checks(v)\n\n        # Cast to list after validation - we know it's a list after basic checks\n        validated_list = cast(list[object], v)\n\n        # Delegate to batch processing\n        return cls._validate_dependencies_batch_processing(validated_list)\n\n    @classmethod\n    def _validate_dependencies_basic_checks(cls, v: object) -> None:\n        \"\"\"Perform basic validation checks on dependencies input.\n\n        Validates type requirements and memory safety constraints.\n\n        Args:\n            v: Dependencies input to validate\n\n        Raises:\n            OnexError: If basic validation fails\n        \"\"\"\n        if not isinstance(v, list):\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract dependencies must be a list, got {type(v).__name__}\",\n                details=cls._create_error_context(\n                    {\n                        \"input_type\": type(v).__name__,\n                        \"expected_type\": \"list\",\n                        \"example\": '[{\"name\": \"ProtocolEventBus\", \"module\": \"omnibase_core.protocol\"}]',\n                    },\n                ),\n            )\n\n        # Memory safety check: prevent unbounded list growth\n        max_dependencies = 100  # Same as Field max_length constraint\n        if len(v) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Too many dependencies: {len(v)}. Maximum allowed: {max_dependencies}\",\n                details=cls._create_error_context(\n                    {\n                        \"dependency_count\": len(v),\n                        \"max_allowed\": max_dependencies,\n                        \"memory_safety\": \"Prevents memory exhaustion with large dependency lists\",\n                        \"suggestion\": \"Consider using pagination or breaking into smaller contracts\",\n                    },\n                ),\n            )\n\n    @classmethod\n    def _validate_dependencies_batch_processing(\n        cls,\n        v: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"Process dependencies list with batch validation.\n\n        Args:\n            v: List of dependencies to process\n\n        Returns:\n            list[ModelDependency]: Validated and converted dependencies\n        \"\"\"\n        # Batch validation approach for better performance\n        return cls._validate_dependency_batch(v)\n\n    @classmethod\n    def _validate_dependency_batch(\n        cls,\n        dependencies: list[object],\n    ) -> list[ModelDependency]:\n        \"\"\"\n        Optimized batch validation for dependency lists.\n\n        Groups validation by type for better performance and provides\n        comprehensive error reporting for multiple issues.\n        \"\"\"\n        if not dependencies:\n            return []\n\n        # Categorize dependencies by type for batch processing\n        categorized = cls._categorize_dependencies_by_type(dependencies)\n\n        # Process categorized dependencies\n        return cls._process_categorized_dependencies(categorized)\n\n    @classmethod\n    def _categorize_dependencies_by_type(\n        cls,\n        dependencies: list[object],\n    ) -> dict[str, list[tuple[int, object]]]:\n        \"\"\"Categorize dependencies by type for efficient batch processing.\n\n        Args:\n            dependencies: List of dependency objects to categorize\n\n        Returns:\n            dict: Categorized dependencies by type\n        \"\"\"\n        categorized: dict[str, list[tuple[int, object]]] = {\n            \"model_deps\": [],\n            \"dict_deps\": [],\n            \"string_deps\": [],\n            \"invalid_deps\": [],\n        }\n\n        # Single pass categorization\n        for i, item in enumerate(dependencies):\n            if isinstance(item, ModelDependency):\n                categorized[\"model_deps\"].append((i, item))\n            elif isinstance(item, dict):\n                categorized[\"dict_deps\"].append((i, item))\n            elif isinstance(item, str):\n                categorized[\"string_deps\"].append((i, item))\n            else:\n                categorized[\"invalid_deps\"].append((i, item))\n\n        return categorized\n\n    @classmethod\n    def _process_categorized_dependencies(\n        cls,\n        categorized: dict[str, list[tuple[int, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Process categorized dependencies and return validated list.\n\n        Args:\n            categorized: Dependencies categorized by type\n\n        Returns:\n            list[ModelDependency]: Validated dependencies\n        \"\"\"\n        # Immediate rejection of invalid types with batch error messages\n        if categorized[\"string_deps\"] or categorized[\"invalid_deps\"]:\n            # Cast to expected types - we know string_deps contains strings\n            string_deps = cast(list[tuple[int, str]], categorized[\"string_deps\"])\n            cls._raise_batch_validation_errors(string_deps, categorized[\"invalid_deps\"])\n\n        # Batch process valid ModelDependency instances\n        result_deps: list[ModelDependency] = [\n            cast(ModelDependency, item) for _, item in categorized[\"model_deps\"]\n        ]\n\n        # Batch convert dict dependencies to ModelDependency\n        if categorized[\"dict_deps\"]:\n            # Cast to expected type - we know dict_deps contains dicts\n            dict_deps = cast(\n                list[tuple[int, dict[str, object]]],\n                categorized[\"dict_deps\"],\n            )\n            result_deps.extend(cls._batch_convert_dict_dependencies(dict_deps))\n\n        return result_deps\n\n    @classmethod\n    def _raise_batch_validation_errors(\n        cls,\n        string_deps: list[tuple[int, str]],\n        invalid_deps: list[tuple[int, object]],\n    ) -> None:\n        \"\"\"Raise comprehensive batch validation errors.\"\"\"\n        error_details = []\n\n        # Collect all string dependency errors\n        for i, item in string_deps:\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"string_dependency\",\n                    \"value\": str(item)[:50] + (\"...\" if len(str(item)) > 50 else \"\"),\n                    \"error\": \"String dependencies not allowed - security risk\",\n                },\n            )\n\n        # Collect all invalid type errors\n        for i, item_obj in invalid_deps:\n            # Explicitly convert object to string for MyPy type safety\n            item_str = str(item_obj)\n            error_details.append(\n                {\n                    \"index\": i,\n                    \"type\": \"invalid_type\",\n                    \"value\": item_str[:50] + (\"...\" if len(item_str) > 50 else \"\"),\n                    \"error\": f\"Invalid type {type(item_obj).__name__} not allowed\",\n                },\n            )\n\n        # Single comprehensive error with all validation issues\n        raise OnexError(\n            code=EnumCoreErrorCode.VALIDATION_ERROR,\n            message=f\"Batch validation failed: {len(error_details)} invalid dependencies found\",\n            details=cls._create_error_context(\n                {\n                    \"validation_errors\": error_details,\n                    \"total_dependencies\": len(string_deps) + len(invalid_deps),\n                    \"security_policy\": \"String dependencies rejected to prevent injection attacks\",\n                    \"allowed_types\": [\"ModelDependency\", \"dict (YAML only)\"],\n                    \"example_format\": {\n                        \"name\": \"ProtocolEventBus\",\n                        \"module\": \"omnibase_core.protocol\",\n                    },\n                },\n            ),\n        )\n\n    @classmethod\n    def _batch_convert_dict_dependencies(\n        cls,\n        dict_deps: list[tuple[int, dict[str, object]]],\n    ) -> list[ModelDependency]:\n        \"\"\"Batch convert dict dependencies to ModelDependency instances.\"\"\"\n        result_deps = []\n        conversion_errors = []\n\n        for i, item in dict_deps:\n            try:\n                # Convert to proper dict[str, object] and extract typed values\n                item_dict: dict[str, object] = dict(item)\n\n                # Extract and convert values to proper types for ModelDependency\n                name = str(item_dict.get(\"name\", \"\"))\n                module = (\n                    str(item_dict[\"module\"])\n                    if item_dict.get(\"module\") is not None\n                    else None\n                )\n                dependency_type = item_dict.get(\n                    \"dependency_type\",\n                    EnumDependencyType.PROTOCOL,\n                )\n                if isinstance(dependency_type, str):\n                    dependency_type = EnumDependencyType(dependency_type)\n                elif not isinstance(dependency_type, EnumDependencyType):\n                    dependency_type = EnumDependencyType.PROTOCOL\n\n                version = item_dict.get(\"version\")\n                if version is not None and not isinstance(version, ModelSemVer):\n                    # Convert to ModelSemVer if needed, otherwise set to None\n                    version = None\n\n                required = bool(item_dict.get(\"required\", True))\n                description = (\n                    str(item_dict[\"description\"])\n                    if item_dict.get(\"description\") is not None\n                    else None\n                )\n\n                result_deps.append(\n                    ModelDependency(\n                        name=name,\n                        module=module,\n                        dependency_type=dependency_type,\n                        version=version,\n                        required=required,\n                        description=description,\n                    ),\n                )\n            except Exception as e:\n                conversion_errors.append(\n                    {\n                        \"index\": i,\n                        \"data\": str(item)[:100]\n                        + (\"...\" if len(str(item)) > 100 else \"\"),\n                        \"error\": str(e)[:100] + (\"...\" if len(str(e)) > 100 else \"\"),\n                    },\n                )\n\n        # Report all conversion errors at once if any occurred\n        if conversion_errors:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Batch YAML dependency conversion failed: {len(conversion_errors)} errors\",\n                details=cls._create_error_context(\n                    {\n                        \"conversion_errors\": conversion_errors,\n                        \"total_failed\": len(conversion_errors),\n                        \"yaml_deserialization\": \"Dict conversion allowed only for YAML loading\",\n                        \"example_format\": {\n                            \"name\": \"ProtocolEventBus\",\n                            \"module\": \"omnibase_core.protocol\",\n                        },\n                    },\n                ),\n            )\n\n        return result_deps\n\n    @field_validator(\"node_type\", mode=\"before\")\n    @classmethod\n    def validate_node_type_enum_only(cls, v: object) -> EnumNodeType:\n        \"\"\"Validate node_type with YAML deserialization support.\n\n        ZERO TOLERANCE for runtime usage: Only EnumNodeType enum instances.\n        YAML EXCEPTION: Allow string conversion only during YAML contract loading.\n        \"\"\"\n        if isinstance(v, EnumNodeType):\n            return v\n        if isinstance(v, str):\n            # YAML DESERIALIZATION EXCEPTION: Allow string-to-enum conversion for contract loading\n            # This maintains zero tolerance for runtime while enabling YAML contract deserialization\n            try:\n                return EnumNodeType(v)\n            except ValueError:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Invalid node_type string '{v}'. Must be valid EnumNodeType value.\",\n                    details=cls._create_error_context(\n                        {\n                            \"invalid_value\": v,\n                            \"valid_enum_values\": [e.value for e in EnumNodeType],\n                            \"yaml_deserialization\": \"String conversion allowed only for YAML loading\",\n                        },\n                    ),\n                )\n        else:\n            # ZERO TOLERANCE: Reject all other types\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"node_type must be EnumNodeType enum or valid string for YAML, not {type(v).__name__}.\",\n                details=cls._create_error_context(\n                    {\n                        \"received_type\": str(type(v)),\n                        \"expected_types\": [\"EnumNodeType\", \"str (YAML only)\"],\n                        \"valid_enum_values\": [e.value for e in EnumNodeType],\n                    },\n                ),\n            )\n\n    def _validate_node_type_compliance(self) -> None:\n        \"\"\"\n        Validate that node_type matches the specialized contract class.\n\n        This is enforced in specialized contract models using Literal types.\n        \"\"\"\n        # After Pydantic validation, node_type is guaranteed to be EnumNodeType\n        # (string-to-enum conversion happens in field validator)\n        # Type validation is handled by Pydantic, so no runtime check needed\n        # Base validation passed - specialized contracts add additional constraints\n\n    def _validate_protocol_dependencies(self) -> None:\n        \"\"\"\n        Validate that all protocol dependencies follow ONEX naming conventions.\n\n        Uses ModelDependency objects to provide consistent validation\n        through unified format handling.\n        \"\"\"\n        for dependency in self.dependencies:\n            # All dependencies are guaranteed to be ModelDependency instances via Pydantic validation\n            # Validate dependency follows ONEX patterns\n            if not dependency.matches_onex_patterns():\n                msg = f\"Dependency does not follow ONEX patterns: {dependency.name}\"\n                raise ValueError(msg)\n\n        for interface in self.protocol_interfaces:\n            # Only accept fully qualified protocol paths - no legacy patterns\n            if \"protocol\" in interface.lower():\n                continue\n            msg = f\"Protocol interface must contain 'protocol' in the name, got: {interface}\"\n            raise ValueError(\n                msg,\n            )\n\n    def _validate_dependency_graph(self) -> None:\n        \"\"\"\n        Validate dependency graph to prevent circular dependencies and ensure consistency.\n\n        This validation prevents complex circular dependency scenarios where multiple\n        dependencies might create loops in the contract dependency graph.\n        \"\"\"\n        if not self.dependencies:\n            return\n\n        # Build dependency graph for cycle detection\n        dependency_names = set()\n        contract_name = self.name.lower()\n\n        for dependency in self.dependencies:\n            dep_name = dependency.name.lower()\n\n            # Check for direct self-dependency\n            if dep_name == contract_name:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Direct circular dependency: Contract '{self.name}' cannot depend on itself via dependency '{dependency.name}'.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"direct_circular_dependency\",\n                            \"suggested_fix\": \"Remove self-referencing dependency or use a different dependency name\",\n                        },\n                    ),\n                )\n\n            # Check for duplicate dependencies (same name)\n            if dep_name in dependency_names:\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Duplicate dependency detected: '{dependency.name}' is already defined in this contract.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"duplicate_dependency\": dependency.name,\n                            \"dependency_type\": dependency.dependency_type.value,\n                            \"validation_type\": \"duplicate_dependency\",\n                            \"suggested_fix\": \"Remove duplicate dependency or use different names for different versions\",\n                        },\n                    ),\n                )\n\n            dependency_names.add(dep_name)\n\n            # Additional validation for module-based circular dependencies\n            if dependency.module and self.name.lower() in dependency.module.lower():\n                # This could indicate a potential circular dependency through module references\n                raise OnexError(\n                    code=EnumCoreErrorCode.VALIDATION_ERROR,\n                    message=f\"Potential circular dependency: Contract '{self.name}' depends on module '{dependency.module}' which contains the contract name.\",\n                    details=self._create_error_context(\n                        {\n                            \"contract_name\": self.name,\n                            \"dependency_name\": dependency.name,\n                            \"dependency_module\": dependency.module,\n                            \"validation_type\": \"module_circular_dependency\",\n                            \"warning\": \"This may indicate a circular dependency through module references\",\n                            \"suggested_fix\": \"Verify that the module does not depend back on this contract\",\n                        },\n                    ),\n                )\n\n        # Validate maximum dependency complexity to prevent over-complex contracts\n        max_dependencies = 50  # Reasonable limit for contract complexity\n        if len(self.dependencies) > max_dependencies:\n            raise OnexError(\n                code=EnumCoreErrorCode.VALIDATION_ERROR,\n                message=f\"Contract has too many dependencies: {len(self.dependencies)}. Maximum recommended: {max_dependencies}.\",\n                details=self._create_error_context(\n                    {\n                        \"contract_name\": self.name,\n                        \"dependency_count\": len(self.dependencies),\n                        \"max_recommended\": max_dependencies,\n                        \"validation_type\": \"complexity_limit\",\n                        \"architectural_guidance\": \"Consider breaking complex contracts into smaller, more focused contracts\",\n                    },\n                ),\n            )\n\n    model_config = ConfigDict(\n        extra=\"ignore\",  # Allow extra fields from YAML contracts\n        use_enum_values=False,  # Keep enum objects, don't convert to strings\n        validate_assignment=True,\n        str_strip_whitespace=True,\n        validate_default=True,  # Enable model validation caching for performance\n    )",
                      "url": null,
                      "relevance_score": 0.48997834,
                      "semantic_score": 0.48997834,
                      "structural_score": null,
                      "source_id": null,
                      "project_id": null,
                      "created_at": null,
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    },
                    {
                      "entity_id": "page_69",
                      "entity_type": "page",
                      "title": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                      "content": "### \n\u200b\nCommercial agreements\nWhether you\u2019re using Anthropic\u2019s API directly (1P) or accessing it through AWS Bedrock or Google Vertex (3P), your existing commercial agreement will apply to Claude Code usage, unless we\u2019ve mutually agreed otherwise.\n## \n\u200b\nCompliance\n### \n\u200b\nHealthcare compliance (BAA)\nIf a customer has a Business Associate Agreement (BAA) with us, and wants to use Claude Code, the BAA will automatically extend to cover Claude Code if the customer has executed a BAA and has Zero Data Retention (ZDR) activated. The BAA will be applicable to that customer\u2019s API traffic flowing through Claude Code.\n## \n\u200b\nSecurity and trust\n### \n\u200b\nTrust and safety\nYou can find more information in the [Anthropic Trust Center](https://trust.anthropic.com) and [Transparency Hub](https://www.anthropic.com/transparency).\n### \n\u200b\nSecurity vulnerability reporting\nAnthropic manages our security program through HackerOne. [Use this form to report vulnerabilities](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\u00a9 Anthropic PBC. All rights reserved. Use is subject to applicable Anthropic Terms of Service.\nWas this page helpful?\nYesNo\n[Hooks reference](https://docs.anthropic.com/en/docs/claude-code/hooks)\n[x](https://x.com/AnthropicAI)[linkedin](https://www.linkedin.com/company/anthropicresearch)\nOn this page\n  * Legal agreements\n  * License\n  * Commercial agreements\n  * Compliance\n  * Healthcare compliance (BAA)\n  * Security and trust\n  * Trust and safety\n  * Security vulnerability reporting",
                      "url": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                      "relevance_score": 0.45352313,
                      "semantic_score": 0.45352313,
                      "structural_score": null,
                      "source_id": "9a532b2b74e5d48a",
                      "project_id": null,
                      "created_at": "2025-09-01T15:47:59.622052+00:00",
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    },
                    {
                      "entity_id": "page_69",
                      "entity_type": "page",
                      "title": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                      "content": "### \n\u200b\nCommercial agreements\nWhether you\u2019re using Anthropic\u2019s API directly (1P) or accessing it through AWS Bedrock or Google Vertex (3P), your existing commercial agreement will apply to Claude Code usage, unless we\u2019ve mutually agreed otherwise.\n## \n\u200b\nCompliance\n### \n\u200b\nHealthcare compliance (BAA)\nIf a customer has a Business Associate Agreement (BAA) with us, and wants to use Claude Code, the BAA will automatically extend to cover Claude Code if the customer has executed a BAA and has Zero Data Retention (ZDR) activated. The BAA will be applicable to that customer\u2019s API traffic flowing through Claude Code.\n## \n\u200b\nSecurity and trust\n### \n\u200b\nTrust and safety\nYou can find more information in the [Anthropic Trust Center](https://trust.anthropic.com) and [Transparency Hub](https://www.anthropic.com/transparency).\n### \n\u200b\nSecurity vulnerability reporting\nAnthropic manages our security program through HackerOne. [Use this form to report vulnerabilities](https://hackerone.com/anthropic-vdp/reports/new?type=team&report_type=vulnerability).\n\u00a9 Anthropic PBC. All rights reserved. Use is subject to applicable Anthropic Terms of Service.\nWas this page helpful?\nYesNo\n[Hooks reference](https://docs.anthropic.com/en/docs/claude-code/hooks)\n[x](https://x.com/AnthropicAI)[linkedin](https://www.linkedin.com/company/anthropicresearch)\nOn this page\n  * Legal agreements\n  * License\n  * Commercial agreements\n  * Compliance\n  * Healthcare compliance (BAA)\n  * Security and trust\n  * Trust and safety\n  * Security vulnerability reporting",
                      "url": "https://docs.anthropic.com/en/docs/claude-code/legal-and-compliance",
                      "relevance_score": 0.45352313,
                      "semantic_score": 0.45352313,
                      "structural_score": null,
                      "source_id": "9a532b2b74e5d48a",
                      "project_id": null,
                      "created_at": "2025-09-01T15:47:59.622052+00:00",
                      "updated_at": null,
                      "relationships": null,
                      "path_to_query": null
                    }
                  ],
                  "query": "API contract validation"
                },
                "knowledge_graph": {
                  "success": true,
                  "source": "memgraph_knowledge_graph",
                  "results": [],
                  "query": "API contract validation",
                  "search_terms": [
                    "contract",
                    "validation"
                  ]
                }
              },
              "synthesis": {
                "key_findings": [
                  "Identified 5 semantically similar items"
                ],
                "patterns_identified": [
                  "Vector search found 5 semantically related items"
                ],
                "recommended_actions": [
                  "Check RAG results for API documentation and best practices",
                  "Review similar API implementations from vector search"
                ],
                "cross_source_connections": [],
                "confidence_score": 0.5,
                "ecosystem_insights": [
                  "Cross-referenced patterns across omninode ecosystem projects",
                  "4-node architecture compliance and implementation patterns",
                  "Integration opportunities between omniagent/omnimcp components",
                  "Architectural consistency analysis across ecosystem"
                ],
                "cross_project_scope": "Searched across entire omninode ecosystem including omnibase-core, omnibase-spi, omniagent, omnimcp",
                "ecosystem_integration_opportunities": [
                  "Identify shared patterns between omnibase components",
                  "Leverage 4-node architecture across ecosystem projects",
                  "Optimize cross-component communication patterns"
                ]
              }
            }
          },
          "quality_metrics": {
            "success": true,
            "analysis": {
              "source_path": "generated_effect.py",
              "language": "python",
              "content_length": 1276,
              "quality_score": 0.96,
              "quality_metrics": {
                "complexity": 1.0,
                "maintainability": 1.0,
                "documentation": 1.0,
                "structure": 0.8
              },
              "architectural_compliance": {
                "onex_compliance": 0.9600000000000001,
                "pattern_compliance": 0,
                "compliance_insights": []
              },
              "code_patterns": {
                "identified_patterns": [],
                "anti_patterns": [
                  "Unresolved TODOs/FIXMEs present"
                ],
                "improvement_opportunities": []
              },
              "maintainability": {
                "score": 1.0,
                "factors": {
                  "line_count": 45,
                  "avg_line_length": 27.377777777777776,
                  "max_line_length": 93,
                  "empty_lines": 13
                }
              },
              "architectural_era": "modern",
              "temporal_relevance": 0.9600000000000001
            },
            "orchestration_summary": {
              "sources_queried": [
                "RAG/Enhanced Search",
                "Qdrant Vector DB",
                "Memgraph Knowledge Graph"
              ],
              "sources_successful": [
                "RAG",
                "Vector Search",
                "Knowledge Graph"
              ],
              "synthesis": {
                "key_findings": [
                  "Identified 3 semantically similar items"
                ],
                "patterns_identified": [
                  "Vector search found 3 semantically related items"
                ],
                "recommended_actions": [
                  "Review RAG search results for documentation patterns",
                  "Analyze vector search results for code similarities",
                  "Explore knowledge graph connections for related concepts"
                ],
                "cross_source_connections": [],
                "confidence_score": 0.5
              },
              "duration_ms": 2429
            },
            "intelligence_service_url": "orchestrated_backend_services",
            "timestamp": "2025-10-06T15:13:13.356608"
          },
          "quality_score": 0.0,
          "lines_generated": 45,
          "validation_passed": false
        },
        "error": null,
        "execution_time_ms": 7946.048974990845,
        "trace_id": "agent_agent-contract-driven-generator_1759763587918_4436769552"
      },
      "error": null
    }
  ],
  "events": [
    {
      "timestamp": 1759763587.84534,
      "datetime_str": "2025-10-06T11:13:07.845343",
      "event_type": "COORDINATOR_START",
      "level": "INFO",
      "agent_name": null,
      "task_id": null,
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Coordinator started: parallel with 2 agents",
      "metadata": {
        "tasks": [
          {
            "task_id": "task1",
            "description": "Generate code from contract"
          },
          {
            "task_id": "task2",
            "description": "Debug code with intelligence"
          }
        ]
      },
      "duration_ms": null,
      "parent_trace_id": null
    },
    {
      "timestamp": 1759763587.846029,
      "datetime_str": "2025-10-06T11:13:07.846029",
      "event_type": "COORDINATOR_START",
      "level": "INFO",
      "agent_name": null,
      "task_id": null,
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Starting parallel execution of 2 tasks",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763587.846338,
      "datetime_str": "2025-10-06T11:13:07.846338",
      "event_type": "PARALLEL_BATCH_START",
      "level": "INFO",
      "agent_name": null,
      "task_id": null,
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Executing batch of 2 tasks in parallel",
      "metadata": {
        "task_ids": [
          "task1",
          "task2"
        ]
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763587.846591,
      "datetime_str": "2025-10-06T11:13:07.846591",
      "event_type": "TASK_ASSIGNED",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Task task1 assigned to agent-contract-driven-generator",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763587.846838,
      "datetime_str": "2025-10-06T11:13:07.846838",
      "event_type": "TASK_ASSIGNED",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Task task2 assigned to agent-contract-driven-generator",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763587.847338,
      "datetime_str": "2025-10-06T11:13:07.847338",
      "event_type": "TASK_ASSIGNED",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Starting contract-driven code generation: Generate code from contract",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763587.8478038,
      "datetime_str": "2025-10-06T11:13:07.847805",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Phase 1: Gathering intelligence for contract-driven generation",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763587.918978,
      "datetime_str": "2025-10-06T11:13:07.918979",
      "event_type": "TASK_ASSIGNED",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Starting contract-driven code generation: Debug code with intelligence",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763587.919652,
      "datetime_str": "2025-10-06T11:13:07.919653",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Phase 1: Gathering intelligence for contract-driven generation",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763593.351873,
      "datetime_str": "2025-10-06T11:13:13.351875",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Gathered intelligence: 2 sources",
      "metadata": {
        "intelligence_count": 2
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763593.35266,
      "datetime_str": "2025-10-06T11:13:13.352661",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Phase 2: Generating ONEX-compliant code",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763593.35326,
      "datetime_str": "2025-10-06T11:13:13.353261",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Phase 3: Validating generated code quality",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763593.3822641,
      "datetime_str": "2025-10-06T11:13:13.382266",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Gathered intelligence: 2 sources",
      "metadata": {
        "intelligence_count": 2
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763593.383111,
      "datetime_str": "2025-10-06T11:13:13.383112",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Phase 2: Generating ONEX-compliant code",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763593.383672,
      "datetime_str": "2025-10-06T11:13:13.383672",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Phase 3: Validating generated code quality",
      "metadata": {},
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763595.7367392,
      "datetime_str": "2025-10-06T11:13:15.736741",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Quality validation complete: score=0.00",
      "metadata": {
        "success": true,
        "analysis": {
          "source_path": "generated_compute.py",
          "language": "python",
          "content_length": 852,
          "quality_score": 0.96,
          "quality_metrics": {
            "complexity": 1.0,
            "maintainability": 1.0,
            "documentation": 1.0,
            "structure": 0.8
          },
          "architectural_compliance": {
            "onex_compliance": 0.9600000000000001,
            "pattern_compliance": 0,
            "compliance_insights": []
          },
          "code_patterns": {
            "identified_patterns": [],
            "anti_patterns": [
              "Unresolved TODOs/FIXMEs present"
            ],
            "improvement_opportunities": []
          },
          "maintainability": {
            "score": 1.0,
            "factors": {
              "line_count": 42,
              "avg_line_length": 19.30952380952381,
              "max_line_length": 87,
              "empty_lines": 15
            }
          },
          "architectural_era": "modern",
          "temporal_relevance": 0.9600000000000001
        },
        "orchestration_summary": {
          "sources_queried": [
            "RAG/Enhanced Search",
            "Qdrant Vector DB",
            "Memgraph Knowledge Graph"
          ],
          "sources_successful": [
            "RAG",
            "Vector Search",
            "Knowledge Graph"
          ],
          "synthesis": {
            "key_findings": [
              "Identified 3 semantically similar items"
            ],
            "patterns_identified": [
              "Vector search found 3 semantically related items"
            ],
            "recommended_actions": [
              "Review RAG search results for documentation patterns",
              "Analyze vector search results for code similarities",
              "Explore knowledge graph connections for related concepts"
            ],
            "cross_source_connections": [],
            "confidence_score": 0.5
          },
          "duration_ms": 2345
        },
        "intelligence_service_url": "orchestrated_backend_services",
        "timestamp": "2025-10-06T15:13:13.386036"
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763595.740612,
      "datetime_str": "2025-10-06T11:13:15.740613",
      "event_type": "TASK_COMPLETED",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Code generation complete: 852 chars, quality=0.00",
      "metadata": {
        "execution_time_ms": 7818.723917007446
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763595.743284,
      "datetime_str": "2025-10-06T11:13:15.743286",
      "event_type": "TASK_COMPLETED",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task2",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Task task2 succeeded in 7818.72ms",
      "metadata": {
        "execution_time_ms": 7818.723917007446
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763595.789983,
      "datetime_str": "2025-10-06T11:13:15.789985",
      "event_type": "AGENT_START",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Quality validation complete: score=0.00",
      "metadata": {
        "success": true,
        "analysis": {
          "source_path": "generated_effect.py",
          "language": "python",
          "content_length": 1276,
          "quality_score": 0.96,
          "quality_metrics": {
            "complexity": 1.0,
            "maintainability": 1.0,
            "documentation": 1.0,
            "structure": 0.8
          },
          "architectural_compliance": {
            "onex_compliance": 0.9600000000000001,
            "pattern_compliance": 0,
            "compliance_insights": []
          },
          "code_patterns": {
            "identified_patterns": [],
            "anti_patterns": [
              "Unresolved TODOs/FIXMEs present"
            ],
            "improvement_opportunities": []
          },
          "maintainability": {
            "score": 1.0,
            "factors": {
              "line_count": 45,
              "avg_line_length": 27.377777777777776,
              "max_line_length": 93,
              "empty_lines": 13
            }
          },
          "architectural_era": "modern",
          "temporal_relevance": 0.9600000000000001
        },
        "orchestration_summary": {
          "sources_queried": [
            "RAG/Enhanced Search",
            "Qdrant Vector DB",
            "Memgraph Knowledge Graph"
          ],
          "sources_successful": [
            "RAG",
            "Vector Search",
            "Knowledge Graph"
          ],
          "synthesis": {
            "key_findings": [
              "Identified 3 semantically similar items"
            ],
            "patterns_identified": [
              "Vector search found 3 semantically related items"
            ],
            "recommended_actions": [
              "Review RAG search results for documentation patterns",
              "Analyze vector search results for code similarities",
              "Explore knowledge graph connections for related concepts"
            ],
            "cross_source_connections": [],
            "confidence_score": 0.5
          },
          "duration_ms": 2429
        },
        "intelligence_service_url": "orchestrated_backend_services",
        "timestamp": "2025-10-06T15:13:13.356608"
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763595.7972732,
      "datetime_str": "2025-10-06T11:13:15.797274",
      "event_type": "TASK_COMPLETED",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Code generation complete: 1276 chars, quality=0.00",
      "metadata": {
        "execution_time_ms": 7946.048974990845
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763595.8005419,
      "datetime_str": "2025-10-06T11:13:15.800544",
      "event_type": "TASK_COMPLETED",
      "level": "INFO",
      "agent_name": "agent-contract-driven-generator",
      "task_id": "task1",
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Task task1 succeeded in 7946.05ms",
      "metadata": {
        "execution_time_ms": 7946.048974990845
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763595.804189,
      "datetime_str": "2025-10-06T11:13:15.804190",
      "event_type": "PARALLEL_BATCH_END",
      "level": "INFO",
      "agent_name": null,
      "task_id": null,
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Batch complete: 2 tasks finished",
      "metadata": {
        "completed": [
          "task1",
          "task2"
        ],
        "success_count": 2
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    },
    {
      "timestamp": 1759763595.8077838,
      "datetime_str": "2025-10-06T11:13:15.807785",
      "event_type": "COORDINATOR_END",
      "level": "INFO",
      "agent_name": null,
      "task_id": null,
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Coordinator completed: 2/2 succeeded, 0 failed",
      "metadata": {
        "total_time_ms": 7962.423086166382,
        "tasks_completed": 2,
        "success_count": 2
      },
      "duration_ms": 7962.423086166382,
      "parent_trace_id": null
    },
    {
      "timestamp": 1759763595.813003,
      "datetime_str": "2025-10-06T11:13:15.813005",
      "event_type": "COORDINATOR_END",
      "level": "INFO",
      "agent_name": null,
      "task_id": null,
      "coordinator_id": "coord_1759763587845_4436769552",
      "message": "Parallel execution complete: 2 tasks in 7962.42ms",
      "metadata": {
        "total_time_ms": 7962.423086166382,
        "results": {
          "task1": true,
          "task2": true
        }
      },
      "duration_ms": null,
      "parent_trace_id": "coord_1759763587845_4436769552"
    }
  ],
  "metadata": {
    "tasks": [
      {
        "task_id": "task1",
        "description": "Generate code from contract"
      },
      {
        "task_id": "task2",
        "description": "Debug code with intelligence"
      }
    ]
  }
}