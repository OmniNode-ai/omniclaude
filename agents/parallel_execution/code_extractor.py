"""
Code Extractor - Extract Python code from agent results

Responsible for:
- Extracting Python code from agent results
- Generating ONEX-compliant file structures
- Template-based code generation
- Handling different code generation patterns
"""

import os
import json
from typing import Dict, Any, List
from dataclasses import dataclass


@dataclass
class CodeFile:
    """Represents a generated code file."""

    filename: str
    content: str
    file_type: str  # 'node', 'contract', 'interface', 'config'
    description: str


class ExtractCode:
    """Extracts Python code from agent results using templates."""

    def __init__(self, output_dir: str = "generated_code"):
        self.output_dir = output_dir
        self.templates_dir = os.path.join(os.path.dirname(__file__), "templates")

    def extract_from_results(self, results: Dict[str, Any]) -> List[CodeFile]:
        """Extract code files from agent results."""
        code_files = []

        for result in results.get("results", []):
            if not result.get("success"):
                continue

            task_id = result.get("task_id", "")
            agent_name = result.get("agent_name", "")
            output_data = result.get("output_data", {})

            # Determine what to generate based on task type
            if "consul-adapter-architecture" in task_id:
                code_files.extend(self._extract_consul_adapter_code(task_id, agent_name, output_data))
            elif "subcontracts-design" in task_id:
                code_files.extend(self._extract_consul_contracts_code(task_id, agent_name, output_data))
            elif "validation-schema" in task_id or "validation-engine" in task_id:
                code_files.extend(self._extract_validation_code(task_id, agent_name, output_data))

        return code_files

    def _extract_consul_adapter_code(
        self, task_id: str, agent_name: str, output_data: Dict[str, Any]
    ) -> List[CodeFile]:
        """Extract Consul adapter node code."""
        code_files = []
        recommendations = output_data.get("recommendations", [])

        # Generate NodeConsulAdapterEffect
        node_content = self._generate_consul_node_code(agent_name, task_id, recommendations)
        code_files.append(
            CodeFile(
                filename="NodeConsulAdapterEffect.py",
                content=node_content,
                file_type="node",
                description="ONEX Effect node for Consul API integration",
            )
        )

        # Generate Consul client adapter interface
        interface_content = self._generate_consul_interface_code(agent_name, task_id, recommendations)
        code_files.append(
            CodeFile(
                filename="consul_client_adapter.py",
                content=interface_content,
                file_type="interface",
                description="Consul client adapter interface and implementation",
            )
        )

        return code_files

    def _extract_consul_contracts_code(
        self, task_id: str, agent_name: str, output_data: Dict[str, Any]
    ) -> List[CodeFile]:
        """Extract Consul model contracts code."""
        code_files = []
        recommendations = output_data.get("recommendations", [])

        # Generate model contracts
        contracts_content = self._generate_consul_contracts_code(agent_name, task_id, recommendations)
        code_files.append(
            CodeFile(
                filename="model_contract_consul.py",
                content=contracts_content,
                file_type="contract",
                description="Model contracts for Consul API operations",
            )
        )

        return code_files

    def _extract_validation_code(self, task_id: str, agent_name: str, output_data: Dict[str, Any]) -> List[CodeFile]:
        """Extract validation system code."""
        code_files = []
        recommendations = output_data.get("recommendations", [])

        # Generate validation node if it's an Effect node task
        if "effect" in task_id.lower():
            validation_node_content = self._generate_validation_node_code(agent_name, task_id, recommendations)
            code_files.append(
                CodeFile(
                    filename=self._get_validation_node_filename(task_id),
                    content=validation_node_content,
                    file_type="node",
                    description="Validation node implementation",
                )
            )

        return code_files

    def _generate_consul_node_code(self, agent_name: str, task_id: str, recommendations: List[Dict]) -> str:
        """Generate NodeConsulAdapterEffect code."""

        # Extract implementation details from recommendations
        patterns = self._extract_design_patterns(recommendations)

        return f'''"""
NodeConsulAdapterEffect - ONEX Effect Node for Consul API Integration
Generated by {agent_name} from task: {task_id}

Design Patterns Applied:
{patterns}
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from dataclasses import dataclass
from enum import Enum
import asyncio
import logging

# ONEX Framework imports
from onex.base import NodeEffect


class ConsulOperation(str, Enum):
    """Supported Consul operations."""
    REGISTER = "register"
    DEREGISTER = "deregister"
    HEALTH_CHECK = "health_check"
    KV_GET = "kv_get"
    KV_SET = "kv_set"
    SERVICE_DISCOVER = "discover"


@dataclass
class ConsulServiceConfig:
    """Configuration for Consul service registration."""
    service_id: str
    service_name: str
    address: str
    port: int
    health_check_url: Optional[str] = None
    tags: List[str] = None
    check_interval: str = "10s"
    timeout: str = "3s"


@dataclass
class ConsulHealthCheck:
    """Health check configuration."""
    http: Optional[str] = None
    tcp: Optional[str] = None
    interval: str = "10s"
    timeout: str = "3s"
    deregister_critical_service_after: str = "30s"


class IConsulClientAdapter(ABC):
    """Interface for Consul client operations."""

    @abstractmethod
    async def register_service(self, config: ConsulServiceConfig) -> bool:
        """Register service with Consul."""
        pass

    @abstractmethod
    async def deregister_service(self, service_id: str) -> bool:
        """Deregister service from Consul."""
        pass

    @abstractmethod
    async def health_check(self, service_id: str) -> Dict[str, Any]:
        """Perform health check on service."""
        pass

    @abstractmethod
    async def discover_service(self, service_name: str) -> List[Dict[str, Any]]:
        """Discover service instances."""
        pass

    @abstractmethod
    async def get_kv(self, key: str) -> Optional[str]:
        """Get value from Consul KV store."""
        pass

    @abstractmethod
    async def set_kv(self, key: str, value: str) -> bool:
        """Set value in Consul KV store."""
        pass

    @abstractmethod
    async def delete_kv(self, key: str) -> bool:
        """Delete key from Consul KV store."""
        pass


class NodeConsulAdapterEffect(NodeEffect):
    """ONEX Effect node for Consul API integration.

    Provides service discovery, configuration management, and health checks
    through Consul API integration. Follows ONEX Effect node pattern for
    external I/O operations.
    """

    def __init__(self, consul_adapter: IConsulClientAdapter, logger: Optional[logging.Logger] = None):
        """Initialize Consul adapter effect."""
        self.consul_adapter = consul_adapter
        self.services: Dict[str, ConsulServiceConfig] = {{}}
        self.logger = logger or logging.getLogger(__name__)

    async def execute_effect(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """Execute Consul adapter effect operations.

        Args:
            input_data: Dictionary containing operation and parameters

        Returns:
            Dictionary with operation results
        """
        operation = input_data.get('operation', 'register')

        try:
            self.logger.info(f"Executing Consul operation: {{operation}}")

            if operation == ConsulOperation.REGISTER:
                return await self._register_service(input_data)
            elif operation == ConsulOperation.DEREGISTER:
                return await self._deregister_service(input_data)
            elif operation == ConsulOperation.HEALTH_CHECK:
                return await self._health_check(input_data)
            elif operation == ConsulOperation.SERVICE_DISCOVER:
                return await self._discover_service(input_data)
            elif operation == ConsulOperation.KV_GET:
                return await self._kv_get(input_data)
            elif operation == ConsulOperation.KV_SET:
                return await self._kv_set(input_data)
            else:
                raise ValueError(f"Unsupported operation: {{operation}}")

        except Exception as e:
            self.logger.error(f"Consul operation failed: {{operation}}", exc_info=True)
            return {{
                "success": False,
                "error": str(e),
                "operation": operation
            }}

    async def _register_service(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Register service with Consul."""
        config = ConsulServiceConfig(
            service_id=data['service_id'],
            service_name=data['service_name'],
            address=data['address'],
            port=data['port'],
            health_check_url=data.get('health_check_url'),
            tags=data.get('tags', [])
        )

        success = await self.consul_adapter.register_service(config)

        if success:
            self.services[config.service_id] = config
            self.logger.info(f"Service registered: {{config.service_id}}")

        return {{
            "success": success,
            "service_id": config.service_id,
            "service_name": config.service_name,
            "operation": ConsulOperation.REGISTER
        }}

    async def _deregister_service(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Deregister service from Consul."""
        service_id = data.get('service_id')

        if not service_id or service_id not in self.services:
            return {{"success": False, "error": "Service not found"}}

        success = await self.consul_adapter.deregister_service(service_id)

        if success:
            del self.services[service_id]
            self.logger.info(f"Service deregistered: {{service_id}}")

        return {{
            "success": success,
            "service_id": service_id,
            "operation": ConsulOperation.DEREGISTER
        }}

    async def _health_check(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Perform health check on service."""
        service_id = data.get('service_id')

        if not service_id:
            return {{"success": False, "error": "Service ID required"}}

        health_data = await self.consul_adapter.health_check(service_id)

        return {{
            "success": True,
            "service_id": service_id,
            "health_data": health_data,
            "operation": ConsulOperation.HEALTH_CHECK
        }}

    async def _discover_service(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Discover service instances."""
        service_name = data.get('service_name')

        if not service_name:
            return {{"success": False, "error": "Service name required"}}

        instances = await self.consul_adapter.discover_service(service_name)

        return {{
            "success": True,
            "service_name": service_name,
            "instances": instances,
            "count": len(instances),
            "operation": ConsulOperation.SERVICE_DISCOVER
        }}

    async def _kv_get(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Get value from Consul KV store."""
        key = data.get('key')

        if not key:
            return {{"success": False, "error": "Key required"}}

        value = await self.consul_adapter.get_kv(key)

        return {{
            "success": True,
            "key": key,
            "value": value,
            "operation": ConsulOperation.KV_GET
        }}

    async def _kv_set(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Set value in Consul KV store."""
        key = data.get('key')
        value = data.get('value')

        if not key or value is None:
            return {{"success": False, "error": "Key and value required"}}

        success = await self.consul_adapter.set_kv(key, value)

        return {{
            "success": success,
            "key": key,
            "value": value,
            "operation": ConsulOperation.KV_SET
        }}

    def get_registered_services(self) -> List[str]:
        """Get list of registered service IDs."""
        return list(self.services.keys())

    def get_service_config(self, service_id: str) -> Optional[ConsulServiceConfig]:
        """Get configuration for a registered service."""
        return self.services.get(service_id)
'''

    def _generate_consul_interface_code(self, agent_name: str, task_id: str, recommendations: List[Dict]) -> str:
        """Generate Consul client adapter interface and implementation."""

        return f'''"""
Consul Client Adapter - Implementation for Consul API Integration
Generated by {agent_name} from task: {task_id}
"""

import aiohttp
import json
from typing import Dict, Any, Optional, List
from datetime import datetime
import logging

from code_extractor import IConsulClientAdapter, ConsulServiceConfig, ConsulHealthCheck


class ConsulClientAdapter(IConsulClientAdapter):
    """Concrete implementation of IConsulClientAdapter using Consul HTTP API."""

    def __init__(self, consul_url: str = "http://localhost:8500", token: Optional[str] = None):
        """Initialize Consul client adapter."""
        self.consul_url = consul_url.rstrip('/')
        self.token = token
        self.session = None
        self.logger = logging.getLogger(__name__)

    async def __aenter__(self):
        """Async context manager entry."""
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        if self.session:
            await self.session.close()

    def _get_headers(self) -> Dict[str, str]:
        """Get HTTP headers for Consul requests."""
        headers = {{"Content-Type": "application/json"}}
        if self.token:
            headers["X-Consul-Token"] = self.token
        return headers

    async def register_service(self, config: ConsulServiceConfig) -> bool:
        """Register service with Consul."""
        try:
            service_data = {{
                "ID": config.service_id,
                "Name": config.service_name,
                "Address": config.address,
                "Port": config.port,
                "Tags": config.tags or [],
                "Check": {{
                    "HTTP": config.health_check_url,
                    "Interval": config.check_interval,
                    "Timeout": config.timeout
                }} if config.health_check_url else None
            }}

            # Remove None check field
            if not service_data["Check"]:
                del service_data["Check"]

            url = f"{{self.consul_url}}/v1/agent/service/register"

            async with self.session.put(url, json=service_data, headers=self._get_headers()) as response:
                success = response.status == 200
                if success:
                    self.logger.info(f"Service registered successfully: {{config.service_id}}")
                else:
                    self.logger.error(f"Failed to register service: {{config.service_id}}, status: {{response.status}}")

                return success

        except Exception as e:
            self.logger.error(f"Error registering service {{config.service_id}}: {{e}}", exc_info=True)
            return False

    async def deregister_service(self, service_id: str) -> bool:
        """Deregister service from Consul."""
        try:
            url = f"{{self.consul_url}}/v1/agent/service/deregister/{{service_id}}"

            async with self.session.put(url, headers=self._get_headers()) as response:
                success = response.status == 200
                if success:
                    self.logger.info(f"Service deregistered successfully: {{service_id}}")
                else:
                    self.logger.error(f"Failed to deregister service: {{service_id}}, status: {{response.status}}")

                return success

        except Exception as e:
            self.logger.error(f"Error deregistering service {{service_id}}: {{e}}", exc_info=True)
            return False

    async def health_check(self, service_id: str) -> Dict[str, Any]:
        """Perform health check on service."""
        try:
            url = f"{{self.consul_url}}/v1/health/service/{{service_id}}"

            async with self.session.get(url, headers=self._get_headers()) as response:
                if response.status == 200:
                    checks = await response.json()
                    # Aggregate health status
                    passing = sum(1 for check in checks if check["Status"] == "passing")
                    critical = sum(1 for check in checks if check["Status"] == "critical")
                    warning = sum(1 for check in checks if check["Status"] == "warning")

                    return {{
                        "service_id": service_id,
                        "status": "passing" if passing > 0 and critical == 0 else "critical",
                        "checks": checks,
                        "summary": {{
                            "passing": passing,
                            "critical": critical,
                            "warning": warning,
                            "total": len(checks)
                        }}
                    }}
                else:
                    return {{
                        "service_id": service_id,
                        "status": "unknown",
                        "error": f"HTTP {{response.status}}",
                        "checks": []
                    }}

        except Exception as e:
            self.logger.error(f"Error checking health for {{service_id}}: {{e}}", exc_info=True)
            return {{
                "service_id": service_id,
                "status": "error",
                "error": str(e),
                "checks": []
            }}

    async def discover_service(self, service_name: str) -> List[Dict[str, Any]]:
        """Discover service instances."""
        try:
            url = f"{{self.consul_url}}/v1/health/service/{{service_name}}?passing"

            async with self.session.get(url, headers=self._get_headers()) as response:
                if response.status == 200:
                    services = await response.json()
                    return [
                        {{
                            "service_id": service["Service"]["ID"],
                            "service_name": service["Service"]["Service"],
                            "address": service["Service"]["Address"],
                            "port": service["Service"]["Port"],
                            "tags": service["Service"]["Tags"],
                            "node": service["Node"]["Node"]
                        }}
                        for service in services
                    ]
                else:
                    self.logger.error(f"Failed to discover service {{service_name}}: {{response.status}}")
                    return []

        except Exception as e:
            self.logger.error(f"Error discovering service {{service_name}}: {{e}}", exc_info=True)
            return []

    async def get_kv(self, key: str) -> Optional[str]:
        """Get value from Consul KV store."""
        try:
            url = f"{{self.consul_url}}/v1/kv/{{key}}"

            async with self.session.get(url, headers=self._get_headers()) as response:
                if response.status == 200:
                    data = await response.json()
                    if data and len(data) > 0:
                        # Consul returns base64 encoded values
                        import base64
                        return base64.b64decode(data[0]["Value"]).decode('utf-8')
                    return None
                else:
                    self.logger.error(f"Failed to get KV key {{key}}: {{response.status}}")
                    return None

        except Exception as e:
            self.logger.error(f"Error getting KV key {{key}}: {{e}}", exc_info=True)
            return None

    async def set_kv(self, key: str, value: str) -> bool:
        """Set value in Consul KV store."""
        try:
            import base64
            encoded_value = base64.b64encode(value.encode('utf-8')).decode('utf-8')

            kv_data = {{"Value": encoded_value}}
            url = f"{{self.consul_url}}/v1/kv/{{key}}"

            async with self.session.put(url, json=kv_data, headers=self._get_headers()) as response:
                success = response.status == 200
                if success:
                    self.logger.debug(f"KV key set successfully: {{key}}")
                else:
                    self.logger.error(f"Failed to set KV key {{key}}: {{response.status}}")

                return success

        except Exception as e:
            self.logger.error(f"Error setting KV key {{key}}: {{e}}", exc_info=True)
            return False

    async def delete_kv(self, key: str) -> bool:
        """Delete key from Consul KV store."""
        try:
            url = f"{{self.consul_url}}/v1/kv/{{key}}"

            async with self.session.delete(url, headers=self._get_headers()) as response:
                success = response.status == 200
                if success:
                    self.logger.debug(f"KV key deleted successfully: {{key}}")
                else:
                    self.logger.error(f"Failed to delete KV key {{key}}: {{response.status}}")

                return success

        except Exception as e:
            self.logger.error(f"Error deleting KV key {{key}}: {{e}}", exc_info=True)
            return False
'''

    def _generate_consul_contracts_code(self, agent_name: str, task_id: str, recommendations: List[Dict]) -> str:
        """Generate Consul model contracts code."""

        return f'''"""
Model Contracts for Consul API Integration
Generated by {agent_name} from task: {task_id}

Validation contracts ensuring proper data structure and type safety
for Consul API operations within the ONEX framework.
"""

from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass, field
from enum import Enum
import re
from ipaddress import ip_address


class ConsulOperationType(str, Enum):
    """Supported Consul operations."""
    REGISTER = "register"
    DEREGISTER = "deregister"
    HEALTH_CHECK = "health_check"
    KV_GET = "kv_get"
    KV_SET = "kv_set"
    KV_DELETE = "kv_delete"
    SERVICE_DISCOVER = "discover"


class ConsulSeverity(str, Enum):
    """Consul operation severity levels."""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class ValidationResult:
    """Result of validation operation."""

    def __init__(self, is_valid: bool, errors: List[str] = None, warnings: List[str] = None):
        self.is_valid = is_valid
        self.errors = errors or []
        self.warnings = warnings or []

    @property
    def severity(self) -> ConsulSeverity:
        """Get validation severity."""
        if self.errors:
            return ConsulSeverity.ERROR
        elif self.warnings:
            return ConsulSeverity.WARNING
        return ConsulSeverity.INFO


@dataclass
class ModelContractConsulServiceInput:
    """Input contract for Consul service operations."""
    operation: ConsulOperationType
    service_id: str
    service_name: Optional[str] = None
    address: Optional[str] = None
    port: Optional[int] = None
    health_check_url: Optional[str] = None
    tags: Optional[List[str]] = field(default_factory=list)
    check_interval: str = "10s"
    timeout: str = "3s"

    def validate(self) -> ValidationResult:
        """Validate service input contract."""
        errors = []
        warnings = []

        # Required field validation
        if not self.service_id or not self.service_id.strip():
            errors.append("service_id is required and cannot be empty")

        if not re.match(r'^[a-zA-Z0-9_-]+$', self.service_id):
            errors.append("service_id must contain only alphanumeric characters, hyphens, and underscores")

        # Operation-specific validation
        if self.operation == ConsulOperationType.REGISTER:
            if not self.service_name or not self.service_name.strip():
                errors.append("service_name is required for registration")

            if not self.address or not self.address.strip():
                errors.append("address is required for registration")
            else:
                # Validate IP address format
                try:
                    ip_address(self.address)
                except ValueError:
                    warnings.append("address does not appear to be a valid IP address")

            if self.port is None:
                errors.append("port is required for registration")
            elif not (1 <= self.port <= 65535):
                errors.append("port must be between 1 and 65535")

            if self.health_check_url:
                if not self.health_check_url.startswith(('http://', 'https://')):
                    errors.append("health_check_url must start with http:// or https://")

        # Validate interval format
        if not re.match(r'^\d+[smh]$', self.check_interval):
            errors.append("check_interval must be in format like '10s', '5m', '1h'")

        if not re.match(r'^\d+[smh]$', self.timeout):
            errors.append("timeout must be in format like '10s', '5m', '1h'")

        return ValidationResult(len(errors) == 0, errors, warnings)


@dataclass
class ModelContractConsulKVInput:
    """Input contract for Consul KV operations."""
    operation: ConsulOperationType
    key: str
    value: Optional[str] = None

    def validate(self) -> ValidationResult:
        """Validate KV input contract."""
        errors = []
        warnings = []

        # Key validation
        if not self.key or not self.key.strip():
            errors.append("key is required and cannot be empty")

        if len(self.key) > 512:
            errors.append("key length cannot exceed 512 characters")

        if not re.match(r'^[a-zA-Z0-9_/.-]+$', self.key):
            warnings.append("key contains special characters that may cause issues")

        # Operation-specific validation
        if self.operation == ConsulOperationType.KV_SET and self.value is None:
            errors.append("value is required for KV set operation")

        if self.operation == ConsulOperationType.KV_SET and self.value is not None:
            if len(self.value) > 512000:  # 512KB limit
                errors.append("value size cannot exceed 512KB")

        return ValidationResult(len(errors) == 0, errors, warnings)


@dataclass
class ModelContractConsulOutput:
    """Output contract for Consul operations."""
    success: bool
    operation: ConsulOperationType
    data: Dict[str, Any] = field(default_factory=dict)
    error: Optional[str] = None
    timestamp: Optional[str] = None

    def validate(self) -> ValidationResult:
        """Validate output contract."""
        errors = []
        warnings = []

        if not isinstance(self.success, bool):
            errors.append("success must be boolean")

        if not self.operation:
            errors.append("operation is required")

        if not isinstance(self.data, dict):
            errors.append("data must be a dictionary")

        if self.success and self.error:
            warnings.append("error should not be set when success is true")

        if not self.success and not self.error:
            warnings.append("error should be provided when success is false")

        return ValidationResult(len(errors) == 0, errors, warnings)


@dataclass
class ModelContractConsulHealthOutput:
    """Output contract for Consul health check operations."""
    service_id: str
    status: str
    checks: List[Dict[str, Any]] = field(default_factory=list)
    summary: Optional[Dict[str, int]] = None
    last_checked: Optional[str] = None

    def validate(self) -> ValidationResult:
        """Validate health check output contract."""
        errors = []
        warnings = []

        if not self.service_id:
            errors.append("service_id is required")

        if self.status not in ["passing", "warning", "critical", "unknown"]:
            errors.append("status must be one of: passing, warning, critical, unknown")

        if not isinstance(self.checks, list):
            errors.append("checks must be a list")

        if self.summary and not isinstance(self.summary, dict):
            errors.append("summary must be a dictionary")

        return ValidationResult(len(errors) == 0, errors, warnings)

    def get_overall_status(self) -> str:
        """Get overall service health status."""
        if not self.checks:
            return "unknown"

        critical_count = sum(1 for check in self.checks if check.get("Status") == "critical")
        warning_count = sum(1 for check in self.checks if check.get("Status") == "warning")
        passing_count = sum(1 for check in self.checks if check.get("Status") == "passing")

        if critical_count > 0:
            return "critical"
        elif warning_count > 0:
            return "warning"
        elif passing_count > 0:
            return "passing"
        else:
            return "unknown"


class ConsulContractValidator:
    """Validator for Consul model contracts."""

    @staticmethod
    def validate_service_input(input_data: Dict[str, Any]) -> ValidationResult:
        """Validate service input contract."""
        try:
            contract = ModelContractConsulServiceInput(**input_data)
            return contract.validate()
        except Exception as e:
            return ValidationResult(False, [f"Invalid contract structure: {{str(e)}}"])

    @staticmethod
    def validate_kv_input(input_data: Dict[str, Any]) -> ValidationResult:
        """Validate KV input contract."""
        try:
            contract = ModelContractConsulKVInput(**input_data)
            return contract.validate()
        except Exception as e:
            return ValidationResult(False, [f"Invalid contract structure: {{str(e)}}"])

    @staticmethod
    def validate_output(output_data: Dict[str, Any]) -> ValidationResult:
        """Validate output contract."""
        try:
            contract = ModelContractConsulOutput(**output_data)
            return contract.validate()
        except Exception as e:
            return ValidationResult(False, [f"Invalid contract structure: {{str(e)}}"])

    @staticmethod
    def validate_health_output(output_data: Dict[str, Any]) -> ValidationResult:
        """Validate health check output contract."""
        try:
            contract = ModelContractConsulHealthOutput(**output_data)
            return contract.validate()
        except Exception as e:
            return ValidationResult(False, [f"Invalid contract structure: {{str(e)}}"])
'''

    def _generate_validation_node_code(self, agent_name: str, task_id: str, recommendations: List[Dict]) -> str:
        """Generate validation node code based on task type."""

        # Determine node type from task
        if "schema" in task_id.lower():
            node_type = "ValidationSchema"
            node_class = "NodeValidationSchemaEffect"
        elif "engine" in task_id.lower():
            node_type = "ValidationEngine"
            node_class = "NodeValidationEngineCompute"
        else:
            node_type = "Validation"
            node_class = "NodeValidationEffect"

        return f'''"""
{node_class} - ONEX Validation Node
Generated by {agent_name} from task: {task_id}
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum
import re
import json
import logging

# ONEX Framework imports
from onex.base import NodeEffect


class ValidationRuleType(str, Enum):
    """Types of validation rules."""
    REQUIRED_FIELD = "required_field"
    FORMAT_PATTERN = "format_pattern"
    LENGTH_CHECK = "length_check"
    RANGE_CHECK = "range_check"
    CUSTOM_VALIDATOR = "custom_validator"


@dataclass
class ValidationRule:
    """Represents a validation rule."""
    rule_id: str
    rule_type: ValidationRuleType
    field_path: str  # Dot notation for nested fields
    parameters: Dict[str, Any]
    error_message: str
    severity: str = "error"


@dataclass
class ValidationResult:
    """Result of validation operation."""
    is_valid: bool
    violations: List[Dict[str, Any]]
    summary: str


class IValidationEngine(ABC):
    """Interface for validation engines."""

    @abstractmethod
    async def validate(self, data: Dict[str, Any], rules: List[ValidationRule]) -> ValidationResult:
        """Validate data against rules."""
        pass

    @abstractmethod
    def add_rule(self, rule: ValidationRule) -> None:
        """Add validation rule."""
        pass

    @abstractmethod
    def remove_rule(self, rule_id: str) -> None:
        """Remove validation rule."""
        pass


class {node_class}(NodeEffect):
    """ONEX {node_type} node for data validation.

    Provides comprehensive validation capabilities with configurable rules
    and detailed violation reporting.
    """

    def __init__(self, validation_engine: IValidationEngine, logger: Optional[logging.Logger] = None):
        """Initialize validation node."""
        self.validation_engine = validation_engine
        self.logger = logger or logging.getLogger(__name__)
        self.rules: List[ValidationRule] = []

    async def execute_effect(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """Execute validation operation.

        Args:
            input_data: Dictionary containing data to validate and validation rules

        Returns:
            Dictionary with validation results
        """
        try:
            # Extract data and rules from input
            data_to_validate = input_data.get('data', {{}})
            rules = self._parse_rules(input_data.get('rules', []))

            self.logger.info(f"Validating data with {{len(rules)}} rules")

            # Perform validation
            result = await self.validation_engine.validate(data_to_validate, rules)

            return {{
                "success": True,
                "validation_result": {{
                    "is_valid": result.is_valid,
                    "violations_count": len(result.violations),
                    "violations": result.violations,
                    "summary": result.summary
                }},
                "rules_evaluated": len(rules),
                "data_size": len(str(data_to_validate))
            }}

        except Exception as e:
            self.logger.error(f"Validation operation failed", exc_info=True)
            return {{
                "success": False,
                "error": str(e),
                "validation_result": {{
                    "is_valid": False,
                    "violations": [],
                    "summary": f"Validation failed: {{str(e)}}"
                }}
            }}

    def _parse_rules(self, rules_data: List[Dict[str, Any]]) -> List[ValidationRule]:
        """Parse rules from input data."""
        rules = []

        for rule_data in rules_data:
            try:
                rule = ValidationRule(
                    rule_id=rule_data['rule_id'],
                    rule_type=ValidationRuleType(rule_data['rule_type']),
                    field_path=rule_data['field_path'],
                    parameters=rule_data.get('parameters', {{}}),
                    error_message=rule_data.get('error_message', 'Validation failed'),
                    severity=rule_data.get('severity', 'error')
                )
                rules.append(rule)
            except Exception as e:
                self.logger.warning(f"Failed to parse rule: {{rule_data}}, error: {{e}}")

        return rules


class DefaultValidationEngine(IValidationEngine):
    """Default implementation of validation engine."""

    def __init__(self):
        self.rules: Dict[str, ValidationRule] = {{}}
        self.logger = logging.getLogger(__name__)

    async def validate(self, data: Dict[str, Any], rules: List[ValidationRule]) -> ValidationResult:
        """Validate data against rules."""
        violations = []

        for rule in rules:
            violation = await self._apply_rule(data, rule)
            if violation:
                violations.append(violation)

        is_valid = len(violations) == 0
        summary = f"{{'PASS' if is_valid else 'FAIL'}}: {{len(violations)}} violation(s) found"

        return ValidationResult(is_valid, violations, summary)

    def add_rule(self, rule: ValidationRule) -> None:
        """Add validation rule."""
        self.rules[rule.rule_id] = rule

    def remove_rule(self, rule_id: str) -> None:
        """Remove validation rule."""
        if rule_id in self.rules:
            del self.rules[rule_id]

    async def _apply_rule(self, data: Dict[str, Any], rule: ValidationRule) -> Optional[Dict[str, Any]]:
        """Apply a single validation rule."""
        try:
            # Get field value using dot notation
            field_value = self._get_nested_value(data, rule.field_path)

            if rule.rule_type == ValidationRuleType.REQUIRED_FIELD:
                if field_value is None or field_value == "":
                    return {{
                        "rule_id": rule.rule_id,
                        "field_path": rule.field_path,
                        "message": rule.error_message,
                        "severity": rule.severity
                    }}

            elif rule.rule_type == ValidationRuleType.FORMAT_PATTERN:
                pattern = rule.parameters.get('pattern')
                if pattern and field_value is not None:
                    if not re.match(pattern, str(field_value)):
                        return {{
                            "rule_id": rule.rule_id,
                            "field_path": rule.field_path,
                            "message": rule.error_message,
                            "severity": rule.severity,
                            "expected_pattern": pattern
                        }}

            elif rule.rule_type == ValidationRuleType.LENGTH_CHECK:
                min_length = rule.parameters.get('min_length')
                max_length = rule.parameters.get('max_length')

                if field_value is not None:
                    field_len = len(str(field_value))

                    if min_length and field_len < min_length:
                        return {{
                            "rule_id": rule.rule_id,
                            "field_path": rule.field_path,
                            "message": rule.error_message,
                            "severity": rule.severity,
                            "actual_length": field_len,
                            "min_length": min_length
                        }}

                    if max_length and field_len > max_length:
                        return {{
                            "rule_id": rule.rule_id,
                            "field_path": rule.field_path,
                            "message": rule.error_message,
                            "severity": rule.severity,
                            "actual_length": field_len,
                            "max_length": max_length
                        }}

            elif rule.rule_type == ValidationRuleType.RANGE_CHECK:
                min_value = rule.parameters.get('min_value')
                max_value = rule.parameters.get('max_value')

                if field_value is not None:
                    try:
                        numeric_value = float(field_value)

                        if min_value is not None and numeric_value < min_value:
                            return {{
                                "rule_id": rule.rule_id,
                                "field_path": rule.field_path,
                                "message": rule.error_message,
                                "severity": rule.severity,
                                "actual_value": numeric_value,
                                "min_value": min_value
                            }}

                        if max_value is not None and numeric_value > max_value:
                            return {{
                                "rule_id": rule.rule_id,
                                "field_path": rule.field_path,
                                "message": rule.error_message,
                                "severity": rule.severity,
                                "actual_value": numeric_value,
                                "max_value": max_value
                            }}
                    except (ValueError, TypeError):
                        return {{
                            "rule_id": rule.rule_id,
                            "field_path": rule.field_path,
                            "message": f"Field '{{rule.field_path}}' must be numeric",
                            "severity": rule.severity
                        }}

        except Exception as e:
            self.logger.error(f"Error applying rule {{rule.rule_id}}: {{e}}", exc_info=True)
            return {{
                "rule_id": rule.rule_id,
                "field_path": rule.field_path,
                "message": f"Validation error: {{str(e)}}",
                "severity": "error"
            }}

        return None

    def _get_nested_value(self, data: Dict[str, Any], field_path: str) -> Any:
        """Get nested value using dot notation."""
        keys = field_path.split('.')
        current = data

        for key in keys:
            if isinstance(current, dict) and key in current:
                current = current[key]
            else:
                return None

        return current
'''

    def _get_validation_node_filename(self, task_id: str) -> str:
        """Generate appropriate filename for validation node."""
        if "schema" in task_id.lower():
            return "NodeValidationSchemaEffect.py"
        elif "engine" in task_id.lower():
            return "NodeValidationEngineCompute.py"
        else:
            return "NodeValidationEffect.py"

    def _extract_design_patterns(self, recommendations: List[Dict]) -> str:
        """Extract design patterns mentioned in recommendations."""
        patterns = []

        for rec in recommendations:
            title = rec.get("title", "").lower()
            desc = rec.get("description", "").lower()
            rationale = rec.get("rationale", "").lower()

            text = f"{title} {desc} {rationale}"

            # Common patterns to look for
            common_patterns = [
                "adapter pattern",
                "strategy pattern",
                "singleton",
                "factory",
                "observer",
                "decorator",
                "facade",
                "command",
                "state",
                "template",
                "dependency injection",
                "interface segregation",
                "repository",
            ]

            for pattern in common_patterns:
                if pattern in text and pattern not in patterns:
                    patterns.append(pattern)

        return "\n".join(f"- {pattern.title()}" for pattern in patterns) if patterns else "- Standard ONEX Patterns"

    def write_code_files(self, code_files: List[CodeFile]) -> None:
        """Write code files to disk."""
        import os

        os.makedirs(self.output_dir, exist_ok=True)

        for code_file in code_files:
            file_path = os.path.join(self.output_dir, code_file.filename)

            with open(file_path, "w", encoding="utf-8") as f:
                f.write(code_file.content)

            print(f"[CodeExtractor] Generated: {code_file.filename} ({code_file.file_type})")

    def write_manifest(self, code_files: List[CodeFile]) -> None:
        """Write a manifest file with code generation details."""
        manifest_path = os.path.join(self.output_dir, "code_manifest.json")

        manifest = {
            "generated_at": self._get_timestamp(),
            "total_files": len(code_files),
            "files": [
                {
                    "filename": cf.filename,
                    "type": cf.file_type,
                    "description": cf.description,
                    "size_lines": len(cf.content.split("\n")),
                }
                for cf in code_files
            ],
        }

        with open(manifest_path, "w", encoding="utf-8") as f:
            json.dump(manifest, f, indent=2)

        print("[CodeExtractor] Generated: code_manifest.json")

    def _get_timestamp(self) -> str:
        """Get current timestamp."""
        from datetime import datetime

        return datetime.now().isoformat()
