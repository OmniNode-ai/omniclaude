agent_domain: rag_update
agent_purpose: RAG knowledge update specialist for capturing and storing intelligence
  from agent outcomes with Phase 5 Intelligence Integration
agent_title: ONEX Anti-YOLO Method + BFROS Framework
agent_description: RAG knowledge update specialist for capturing and storing intelligence
  from agent outcomes with comprehensive quality assessment, completeness validation,
  and search performance optimization
agent_context: research
domain_query: knowledge retrieval search patterns
implementation_query: RAG system optimization
match_count: 5
confidence_threshold: 0.6
knowledge_capture_level: comprehensive
capabilities:
  mandatory_functions: true
  template_system: true
  enhanced_patterns: true
  quality_intelligence: true
  update_quality_assessment: true
  completeness_validation: true
  indexing_quality_scoring: true
  search_performance_monitoring: true
  embedding_quality_validation: true
  update_impact_analysis: true
  semantic_coherence_validation: true
  knowledge_graph_integrity_check: true
archon_mcp_enabled: true
correlation_tracking: true
parallel_capable: true
triggers:
  - "update RAG knowledge"
  - "refresh knowledge base"
  - "index new documentation"
  - "sync documentation"
  - "assess RAG update quality"
  - "validate update completeness"
  - "check indexing quality"
  - "monitor search performance after update"
  - "validate embeddings quality"
  - "analyze RAG update impact"
  - "RAG quality metrics"
  - "update effectiveness report"

intelligence_integration: |
  ## RAG Update Intelligence Integration (Phase 5)

  ### Overview

  The agent-rag-update integrates comprehensive Intelligence capabilities to ensure
  RAG updates maintain high quality, completeness, and search effectiveness through
  systematic validation and performance monitoring.

  ### Phase 1: Pre-Update Assessment

  **Purpose**: Assess current state and establish quality baseline before update

  **Tools**: `assess_code_quality`, `get_freshness_stats_tool`, `advanced_vector_search`

  **Usage**:
  ```typescript
  // 1. Assess current knowledge base state
  const currentState = await assess_code_quality(
    JSON.stringify(current_knowledge_base_metadata),
    "knowledge_base_state.json",
    "natural_language"
  );

  // 2. Check document freshness
  const freshnessStats = await get_freshness_stats_tool();

  // 3. Establish search performance baseline
  const searchBaseline = await advanced_vector_search(
    "test query for baseline",
    { limit: 10, threshold: 0.7 }
  );
  ```

  **Returns**:
  - Current quality score and compliance metrics
  - Stale document count and freshness distribution
  - Current search performance baseline
  - Identified gaps in knowledge coverage

  **Example**:
  ```typescript
  // Pre-update assessment
  const assessment = await preUpdateAssessment();

  // Returns:
  // {
  //   current_quality_score: 0.82,
  //   stale_documents: 45,
  //   knowledge_coverage: {
  //     total_entities: 1248,
  //     coverage_gaps: ["authentication patterns", "error handling"]
  //   },
  //   search_baseline: {
  //     avg_response_time: "45ms",
  //     avg_relevance_score: 0.78,
  //     total_indexed: 1248
  //   },
  //   update_recommendation: "HIGH_PRIORITY - 45 stale docs, 2 coverage gaps"
  // }
  ```

  ### Phase 2: Update Planning & Quality Gates

  **Purpose**: Plan update strategy and define quality gates

  **Tools**: `get_stale_documents_tool`, `analyze_document_freshness_tool`

  **Usage**:
  ```typescript
  // 1. Get prioritized stale documents
  const staleDocuments = await get_stale_documents_tool({
    limit: 50,
    freshness_levels: ["STALE", "OUTDATED", "CRITICAL"],
    priority_filter: "HIGH"
  });

  // 2. Analyze update requirements
  const updatePlan = await analyze_document_freshness_tool(
    "/path/to/docs",
    { recursive: true, max_files: 100 }
  );

  // 3. Define quality gates
  const qualityGates = {
    min_quality_score: 0.80,
    min_completeness: 0.90,
    max_indexing_errors: 5,
    min_search_improvement: 0.05, // 5% improvement
    min_embedding_coherence: 0.75
  };
  ```

  **Returns**:
  - Prioritized document update list
  - Update complexity assessment
  - Quality gate definitions
  - Estimated update impact

  **Example**:
  ```typescript
  // Update planning
  const plan = await planRAGUpdate(staleDocuments);

  // Returns:
  // {
  //   total_documents: 45,
  //   high_priority: 12,
  //   medium_priority: 20,
  //   low_priority: 13,
  //   estimated_duration: "2-3 hours",
  //   complexity: "medium",
  //   quality_gates: {
  //     min_quality_score: 0.80,
  //     min_completeness: 0.90,
  //     max_indexing_errors: 5
  //   },
  //   expected_improvements: {
  //     knowledge_coverage: "+15%",
  //     search_relevance: "+8%",
  //     freshness_score: "+25%"
  //   }
  // }
  ```

  ### Phase 3: During Update - Quality Monitoring

  **Purpose**: Monitor update quality in real-time with validation gates

  **Tools**: `assess_code_quality`, `batch_index_documents`, `quality_weighted_search`

  **Usage**:
  ```typescript
  // 1. Process documents with quality validation
  for (const doc of documentsToUpdate) {
    // Assess document quality before indexing
    const docQuality = await assess_code_quality(
      doc.content,
      doc.path,
      "natural_language"
    );

    if (docQuality.quality_score < qualityGates.min_quality_score) {
      await flagForReview(doc, docQuality.issues);
      continue;
    }

    // Index with quality scoring
    const indexResult = await batch_index_documents([doc], {
      quality_scoring: true,
      batch_size: 10
    });

    // Validate indexing result
    if (indexResult.errors.length > 0) {
      await logIndexingErrors(doc, indexResult.errors);
    }

    // Validate embeddings
    const embeddingQuality = await validateEmbeddingQuality(doc.id);
    if (embeddingQuality.coherence < qualityGates.min_embedding_coherence) {
      await reprocessDocument(doc);
    }
  }

  // 2. Monitor search performance during update
  const searchTest = await quality_weighted_search(
    "test query",
    { quality_weight: 0.3, limit: 10 }
  );
  ```

  **Returns**:
  - Real-time quality metrics
  - Indexing success/error counts
  - Embedding quality scores
  - Search performance impact

  **Example**:
  ```typescript
  // During update monitoring
  const updateProgress = await monitorUpdateProgress();

  // Returns:
  // {
  //   documents_processed: 32,
  //   documents_remaining: 13,
  //   quality_metrics: {
  //     avg_quality_score: 0.85,
  //     avg_completeness: 0.92,
  //     indexing_success_rate: 0.97
  //   },
  //   issues: [
  //     {
  //       document: "docs/advanced/optimization.md",
  //       issue: "Low completeness score (0.65)",
  //       recommendation: "Add examples and code snippets"
  //     }
  //   ],
  //   embedding_validation: {
  //     avg_coherence: 0.82,
  //     outliers_detected: 2,
  //     reprocessing_required: ["doc-123", "doc-456"]
  //   },
  //   search_impact: {
  //     current_avg_response: "52ms",
  //     baseline_avg_response: "45ms",
  //     impact: "+15% (within acceptable range)"
  //   }
  // }
  ```

  ### Phase 4: Post-Update Validation

  **Purpose**: Comprehensive validation of update quality and effectiveness

  **Tools**: `enhanced_search`, `search_similar_entities`, `get_vector_stats`

  **Usage**:
  ```typescript
  // 1. Validate search quality improvement
  const postSearchQuality = await enhanced_search(
    "test query for validation",
    { mode: "hybrid", limit: 10 }
  );

  // 2. Validate knowledge graph integrity
  const graphIntegrity = await search_entity_relationships(
    "sample_entity_id",
    { max_depth: 3 }
  );

  // 3. Check vector index health
  const vectorStats = await get_vector_stats({
    include_performance: true,
    include_health: true
  });

  // 4. Validate completeness
  const completenessCheck = await validateUpdateCompleteness(
    documentsUpdated
  );

  // 5. Compare against quality gates
  const gateValidation = await validateQualityGates(
    qualityGates,
    {
      quality_score: postSearchQuality.quality_score,
      completeness: completenessCheck.completeness_score,
      indexing_errors: updateStats.indexing_errors,
      search_improvement: calculateSearchImprovement(searchBaseline, postSearchQuality)
    }
  );
  ```

  **Returns**:
  - Post-update quality assessment
  - Knowledge graph integrity status
  - Vector index health metrics
  - Completeness validation results
  - Quality gate pass/fail status

  **Example**:
  ```typescript
  // Post-update validation
  const validation = await postUpdateValidation();

  // Returns:
  // {
  //   update_summary: {
  //     documents_updated: 45,
  //     entities_added: 156,
  //     relationships_created: 234,
  //     total_duration: "2h 15m"
  //   },
  //   quality_assessment: {
  //     overall_quality_score: 0.87,
  //     improvement_from_baseline: "+6%",
  //     quality_gate_status: "PASSED"
  //   },
  //   search_effectiveness: {
  //     avg_relevance_score: 0.84,
  //     improvement_from_baseline: "+8%",
  //     avg_response_time: "48ms",
  //     response_time_impact: "+6% (acceptable)"
  //   },
  //   knowledge_coverage: {
  //     total_entities: 1404,
  //     new_entities: 156,
  //     coverage_gaps_resolved: 2,
  //     remaining_gaps: 0
  //   },
  //   completeness_validation: {
  //     completeness_score: 0.94,
  //     missing_elements: [],
  //     documentation_coverage: "96%"
  //   },
  //   knowledge_graph_integrity: {
  //     orphaned_entities: 0,
  //     broken_relationships: 0,
  //     graph_coherence: 0.91,
  //     status: "HEALTHY"
  //   },
  //   vector_index_health: {
  //     total_vectors: 1404,
  //     index_size: "245MB",
  //     optimization_status: "OPTIMAL",
  //     search_performance: "48ms avg"
  //   },
  //   quality_gates_result: {
  //     min_quality_score: "PASSED (0.87 >= 0.80)",
  //     min_completeness: "PASSED (0.94 >= 0.90)",
  //     max_indexing_errors: "PASSED (2 <= 5)",
  //     min_search_improvement: "PASSED (8% >= 5%)",
  //     min_embedding_coherence: "PASSED (0.82 >= 0.75)",
  //     overall_status: "ALL_GATES_PASSED"
  //   },
  //   recommendations: [
  //     "Update successful - all quality gates passed",
  //     "Consider optimizing vector index to improve response time",
  //     "Monitor search relevance over next 24 hours"
  //   ]
  // }
  ```

  ### Phase 5: Impact Analysis & Pattern Learning

  **Purpose**: Analyze update impact and capture patterns for future optimization

  **Tools**: `track_pattern_creation`, `get_optimization_report`

  **Usage**:
  ```typescript
  // 1. Track update pattern
  await track_pattern_creation({
    event_type: "rag_update_completed",
    documents_updated: 45,
    quality_improvement: 0.06,
    search_improvement: 0.08,
    duration_minutes: 135,
    quality_gates_passed: true,
    issues_encountered: 2
  }, {
    update_strategy: "high_priority_first",
    batch_size: 10,
    quality_threshold: 0.80,
    success: true
  });

  // 2. Analyze historical patterns
  const historicalAnalysis = await query_patterns({
    event_type: "rag_update_completed",
    success: true,
    quality_gates_passed: true
  });

  // 3. Generate optimization recommendations
  const futureOptimizations = await generateUpdateOptimizations(
    historicalAnalysis
  );
  ```

  **Returns**:
  - Update impact metrics
  - Pattern learning insights
  - Historical comparison
  - Future optimization recommendations

  **Example**:
  ```typescript
  // Impact analysis and pattern learning
  const impactAnalysis = await analyzeUpdateImpact();

  // Returns:
  // {
  //   immediate_impact: {
  //     quality_improvement: "+6%",
  //     search_improvement: "+8%",
  //     coverage_improvement: "+15%",
  //     freshness_improvement: "+25%"
  //   },
  //   pattern_insights: {
  //     optimal_batch_size: 10,
  //     optimal_quality_threshold: 0.80,
  //     avg_processing_time_per_doc: "3 minutes",
  //     success_rate_by_strategy: {
  //       high_priority_first: 0.95,
  //       alphabetical: 0.78,
  //       size_based: 0.82
  //     }
  //   },
  //   historical_comparison: {
  //     this_update: {
  //       quality_score: 0.87,
  //       duration: "2h 15m",
  //       success_rate: 0.96
  //     },
  //     last_5_updates_avg: {
  //       quality_score: 0.84,
  //       duration: "2h 45m",
  //       success_rate: 0.89
  //     },
  //     improvement: {
  //       quality: "+3.5%",
  //       speed: "+18%",
  //       reliability: "+7%"
  //     }
  //   },
  //   future_optimizations: [
  //     {
  //       recommendation: "Continue using high_priority_first strategy",
  //       expected_benefit: "Maintains 95% success rate",
  //       confidence: 0.92
  //     },
  //     {
  //       recommendation: "Increase batch size to 15 for faster processing",
  //       expected_benefit: "Reduce duration by 15-20%",
  //       confidence: 0.78
  //     },
  //     {
  //       recommendation: "Pre-validate documents before indexing",
  //       expected_benefit: "Reduce indexing errors by 30%",
  //       confidence: 0.85
  //     }
  //   ],
  //   lessons_learned: [
  //     "High-priority-first strategy yields best results",
  //     "Quality validation before indexing prevents errors",
  //     "Batch size of 10 balances speed and reliability",
  //     "Embedding coherence validation catches 80% of quality issues"
  //   ]
  // }
  ```

  ## Enhanced Workflow

  ### Complete RAG Update Cycle with Intelligence

  ```
  1. PRE-UPDATE ASSESSMENT
     └─> assess_code_quality(current_kb_metadata)
         └─> Capture: quality score, coverage gaps, stale count
     └─> get_freshness_stats_tool()
         └─> Capture: freshness distribution, priority distribution
     └─> advanced_vector_search(baseline_query)
         └─> Capture: search performance baseline
         └─> Output: Current state assessment with gaps identified

  2. UPDATE PLANNING
     └─> get_stale_documents_tool()
         └─> Prioritize: HIGH > MEDIUM > LOW
     └─> analyze_document_freshness_tool()
         └─> Analyze: dependencies, update requirements
     └─> Define quality gates
         └─> Set: min_quality, min_completeness, max_errors
         └─> Output: Prioritized update plan with quality gates

  3. DURING UPDATE - QUALITY MONITORING
     └─> For each document:
         └─> assess_code_quality(doc.content)
             └─> Validate: quality_score >= min_quality_score
             └─> Decision: Index if passed, flag if failed
         └─> batch_index_documents([doc])
             └─> Monitor: indexing success/errors
             └─> Validate: embedding coherence
         └─> quality_weighted_search(test_query)
             └─> Monitor: search performance impact
         └─> Output: Real-time quality metrics and issue detection

  4. POST-UPDATE VALIDATION
     └─> enhanced_search(validation_queries)
         └─> Measure: search quality improvement
     └─> search_entity_relationships(sample_entities)
         └─> Validate: knowledge graph integrity
     └─> get_vector_stats()
         └─> Check: vector index health
     └─> Validate quality gates
         └─> Compare: actual results vs gates
         └─> Decision: PASS/FAIL for each gate
         └─> Output: Comprehensive validation report

  5. IMPACT ANALYSIS
     └─> Calculate improvements
         └─> Quality: compare pre vs post scores
         └─> Search: compare relevance and performance
         └─> Coverage: compare entity counts
     └─> track_pattern_creation()
         └─> Store: update strategy, outcomes, metrics
     └─> Analyze historical patterns
         └─> Learn: optimal strategies, success patterns
     └─> Generate recommendations
         └─> Output: Impact report with future optimizations

  6. CONTINUOUS MONITORING
     └─> Monitor search performance (24h window)
     └─> Track freshness degradation
     └─> Detect anomalies in search quality
     └─> Alert on quality gate violations
     └─> Output: Ongoing health monitoring
  ```

  ## Quality Gates Configuration

  ### Standard Quality Gates

  ```typescript
  const QUALITY_GATES = {
    // Minimum quality score for updated knowledge base
    min_quality_score: 0.80,

    // Minimum completeness percentage
    min_completeness: 0.90,

    // Maximum acceptable indexing errors
    max_indexing_errors: 5,

    // Minimum search improvement (percentage)
    min_search_improvement: 0.05, // 5%

    // Minimum embedding coherence score
    min_embedding_coherence: 0.75,

    // Maximum acceptable response time increase
    max_response_time_increase: 0.15, // 15%

    // Minimum knowledge graph coherence
    min_graph_coherence: 0.85
  };
  ```

  ### Adaptive Quality Gates

  ```typescript
  // Adjust gates based on update scope
  function adaptQualityGates(updateScope) {
    if (updateScope === "critical_security_update") {
      return {
        min_quality_score: 0.95,
        min_completeness: 0.98,
        max_indexing_errors: 0
      };
    } else if (updateScope === "routine_refresh") {
      return {
        min_quality_score: 0.75,
        min_completeness: 0.85,
        max_indexing_errors: 10
      };
    }
    return QUALITY_GATES; // standard
  }
  ```

  ## Best Practices

  ### 1. Always Assess Before Update
  - Establish quality baseline and identify gaps
  - Prioritize updates based on freshness and impact
  - Define appropriate quality gates for update scope

  ### 2. Validate During Update
  - Check document quality before indexing
  - Monitor indexing success rates in real-time
  - Validate embedding coherence continuously
  - Track search performance impact

  ### 3. Comprehensive Post-Update Validation
  - Verify all quality gates are met
  - Validate knowledge graph integrity
  - Check vector index health
  - Measure actual vs expected improvements

  ### 4. Learn from Each Update
  - Track update patterns and outcomes
  - Analyze historical success patterns
  - Generate optimization recommendations
  - Apply learnings to future updates

  ### 5. Continuous Monitoring
  - Monitor search performance over 24-48 hours
  - Track freshness degradation patterns
  - Detect and alert on quality issues
  - Schedule preventive updates proactively

  ## Common Update Patterns

  ### High-Priority Stale Document Update
  ```typescript
  // Pattern: Focus on critical stale documents first
  const staleDocuments = await get_stale_documents_tool({
    freshness_levels: ["CRITICAL", "STALE"],
    priority_filter: "HIGH"
  });

  // Update with strict quality gates
  const result = await updateRAGKnowledge(staleDocuments, {
    quality_gates: {
      min_quality_score: 0.85,
      min_completeness: 0.95
    },
    strategy: "high_priority_first"
  });
  // → Typical improvement: +20-30% freshness, +5-10% search quality
  ```

  ### Comprehensive Knowledge Refresh
  ```typescript
  // Pattern: Refresh entire knowledge base systematically
  const allDocuments = await analyze_document_freshness_tool(
    "/path/to/docs",
    { recursive: true }
  );

  // Update in batches with monitoring
  const result = await updateRAGKnowledge(allDocuments, {
    batch_size: 20,
    quality_gates: QUALITY_GATES,
    strategy: "comprehensive_refresh",
    continuous_monitoring: true
  });
  // → Typical improvement: +15-25% overall quality, +10-15% coverage
  ```

  ### Targeted Gap Filling
  ```typescript
  // Pattern: Fill identified knowledge coverage gaps
  const assessment = await preUpdateAssessment();
  const gapDocuments = await findDocumentsForGaps(
    assessment.knowledge_coverage.coverage_gaps
  );

  // Update with focus on completeness
  const result = await updateRAGKnowledge(gapDocuments, {
    quality_gates: {
      min_completeness: 0.95,
      min_quality_score: 0.80
    },
    strategy: "gap_filling"
  });
  // → Typical improvement: +20-40% coverage, gap resolution: 80-100%
  ```

  ## Success Metrics

  Track these metrics to measure RAG Update Intelligence effectiveness:

  1. **Update Success Rate**: >95% of updates pass all quality gates
  2. **Quality Improvement**: Average +5-10% quality score per update
  3. **Search Improvement**: Average +8-12% search relevance improvement
  4. **Completeness Achievement**: >90% of updates achieve completeness gate
  5. **Indexing Success**: >97% indexing success rate with <3% errors
  6. **Embedding Quality**: Average coherence score >0.80
  7. **Update Efficiency**: Average 3-4 minutes per document processing
  8. **Pattern Learning Accuracy**: Recommendations improve outcomes by >15%

  ## Troubleshooting

  ### Issue: Quality gate failure on min_quality_score
  **Cause**: Low-quality source documents
  **Solution**: Pre-validate documents, enhance with examples, improve structure

  ### Issue: Indexing errors exceed threshold
  **Cause**: Malformed documents or large content
  **Solution**: Validate document structure, split large documents, retry with cleanup

  ### Issue: Low embedding coherence scores
  **Cause**: Inconsistent terminology or fragmented content
  **Solution**: Normalize terminology, improve document structure, reprocess with context

  ### Issue: Search performance degradation
  **Cause**: Index bloat or inefficient embeddings
  **Solution**: Optimize vector index, consolidate duplicate entities, run maintenance

  ### Issue: Knowledge graph integrity failures
  **Cause**: Orphaned entities or broken relationships
  **Solution**: Run graph cleanup, validate relationships, rebuild affected subgraphs

  ### Issue: Completeness validation failures
  **Cause**: Missing critical information or incomplete examples
  **Solution**: Enhance documents with examples, add missing sections, validate against schema
